#**************************************************
# Copyright (c) 2019 Cisco Systems, Inc.
# All rights reserved.
#**************************************************
import json
import re
import time
import csv
import datetime
import requests
import sys
import os
import tabulate
import urllib3
import getpass
import netaddr
import ipaddress
import dpkt
from dpkt.utils import inet_to_str
import inspect
from zipfile import ZipFile
from itertools import islice, product
import functools
import random
from scapy.layers.l2 import Ether
os.environ['OPENBLAS_NUM_THREADS'] = '1'
import pandas as pd
import numpy as np
from typing import List, Union, Optional, AnyStr, Dict
from ixnetwork_restpy import BatchFind

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

from logger.cafylog import CafyLog
from utils.cafyexception import CafyException
from utils.timer import Timer
from utils.helper import Helper

from tgn.base import TGN
from tgn.ixia_ixnetwork import TrafficStats
try:
    from tgn.ixia_ixnetwork import VLAN, IPV46, IGMP, MLD, OSPFv2, OSPFv3, LDPv4, LDPv6, BGPv4, BGPv6 , ISIS
except:pass
log = CafyLog("ixia")

# Import Restpy library
from ixnetwork_restpy.testplatform.testplatform import TestPlatform
from ixnetwork_restpy.assistants.statistics.statviewassistant import StatViewAssistant
from ixnetwork_restpy.files import Files
from ixnetwork_restpy import BatchUpdate

class IxiaConfigException(Exception):
    """
    IXIA config exception
    """
    pass

class IxiaOperationException(Exception):
    """
    IXIA operation exception
    """
    pass

class IxiaStatsException(Exception):
    """
    IXIA stats exception
    """
    pass

def debug_log_decorator(func):
    """
    Decorator to download debug files on Ixia exception.
    :param None
    :return: None
    """
    @functools.wraps(func)
    def wrapper_decorator(*args, **kwargs):
        try:
            value = func(*args, **kwargs)
            return value
        except Exception as ex:
            try:
                args[0]._download_debug_files()
            except:
                pass
            log.error(ex)
            raise ex
    return wrapper_decorator

def decorator_for_class(cls):
    """
    Class Decorator to apply decorator on all the public methods of Ixia class.
    :param None
    :return: None
    """
    for name, method in inspect.getmembers(cls):
        if (not inspect.ismethod(method) and not inspect.isfunction(method)) or inspect.isbuiltin(method):
            continue
        if name.startswith("_"):
            continue
        setattr(cls, name, debug_log_decorator(method))
    return cls


@decorator_for_class
class IXIA(TGN):
    def get_handles(self):
        """
        get handles

        :return: list()
        """
        return list()

    def __init__(self, tgn_server_type='windows', server_ip=None, debug_print=False,
                 time_factor=1.0, verbose=True, timeout=300, api_version=1, session_name=None, user_name=None, topology='', **kwargs):
        """
        Initialize the REST API wrapper object.
        IxNetwork version should be 8.0 or above for REST api's to work.
        If the port to connect to is not specified by the port argument,then
        try connecting on the default port, 11009
        :param tgn_server_type (str): The type of IXIA lab server to be used
            e.g. 'windows', 'linux', 'windows_cm' (windows connection manager)
        :param use server_ip same as spirent lib
                server: Ixia REST Tcl server to connect to.
                    if None, raise IxiaConfigException
        :param port: HTTP port to connect to server on.
                    Default is '11009'
        :param debug_print: if True, enable debug print statements
        :param Use time_factor same as spirent lib
                    timer_scale_factor: multiplication factor for the methods using
        :param session_name: session_name for linux API server
        :param user_name: user_name for linux API server
        :param topology : Testbed name from topology file
        :param kwargs:
                    sessionId : sessionId for linux and windows
        :param verbose: verbose
        """
        self.log = CafyLog('IXIA')
        self.exception = CafyException()
        self.tgn_server_type = tgn_server_type
        if self.tgn_server_type == 'windows':
            self.port = kwargs.get('port', 11009)
        elif self.tgn_server_type == 'linux':
            self.port = kwargs.get('port', 443)
        self.tgn_server_user = kwargs.get('tgn_server_user', 'admin')
        self.tgn_server_pw = kwargs.get('tgn_server_pw', 'admin')
        self.log_level = kwargs.get('log_level', 'warning')

        self.topology_name = topology

        self._lab_servers = []
        if type(server_ip) in (list, tuple):
            self._lab_servers = server_ip
            self.server_ip = self._lab_servers[0].split(':')[0]
            if ':' in self._lab_servers[0]:
                self.port = self._lab_servers[0].split(':')[1]
        elif ':' in server_ip:
            self.port = server_ip.split(':')[1]
            self.server_ip = server_ip.split(':')[0]
        else:
            self.server_ip = server_ip

        if not user_name:
            self.user_name = getpass.getuser()
        else:
            self.user_name = user_name

        if not session_name:
            self.session_name = "testbed" + '_' + self.user_name
        else:
            self.session_name = session_name.replace('-', '_')
            self.session_name = ' - '.join((self.session_name, self.user_name))

        self.pxe = list()
        self.interfaces_info = kwargs.get('interfaces', [])
        self.interfaces = dict()
        self.interfaces_by_alias = dict()
        self.interfaces_in_zap = dict()
        self.links = dict()
        self.power_cycle_info = list()

        self.config_file = None
        self.timer_scale_factor = time_factor  # default timer  of 1s
        self.verbose = verbose
        self.device_type = kwargs.get('type')
        self.name = kwargs.get('name')
        self.alias = kwargs.get('alias')
        self.platform = kwargs.get('platform')
        self.chassis_ip = kwargs.get('chassis_ip')
        self.slave_chassis = kwargs.get('slave_chassis')
        self.timeout = timeout
        self.api_version = api_version
        self.session_id = None
        self.update_license = False
        self.bgp_devices = {}
        self.bgp_routes_startip_rid_v4 = {}
        self.bgp_routes_startip_device_name_v4 = {}
        self.bgp_routes_startip_port_name_v4 = {}
        self.bgp_routes_startip_rid_v6 = {}
        self.bgp_routes_startip_device_name_v6 = {}
        self.bgp_routes_startip_port_name_v6 = {}
        self.license_server = kwargs.get('license_server')

    def get_license_server(self):
        """
        Retrieve the license server for the IXIA TGEN device.
        :return: License server for IXIA TGEN
        """
        return self.license_server
    
    def _new_session(self, user_name=None, session_name=None, kill_existing=False):
        """
        API used internally

        :param user_name: user name
        :param session_name: session name for linux API server
        :param kill_existing: kill existing session in Linux API Server
        :return:
        """
        if self.tgn_server_type == 'windows':
            self.testPlatform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='windows',
                                             log_file_name=CafyLog.work_dir + '/restpy.log')
            # Console output verbosity: None|request|'request response'
            # self.testPlatform.Trace = 'request_response'
            self.session = self.testPlatform.Sessions.add()
            self.ixNetwork = self.session.Ixnetwork
            if kill_existing:
                self.ixNetwork.NewConfig()
            self.session_id = 1
            self.log.info("Ixia Lab Server - '%s'" % (self.server_ip))
        elif self.tgn_server_type == 'linux':
            self.testPlatform = TestPlatform(ip_address=self.server_ip, rest_port=self.port, platform='linux',
                                             log_file_name=CafyLog.work_dir + '/restpy.log')
            self.testPlatform.Trace = self.log_level
            self.testPlatform.Authenticate(self.tgn_server_user, self.tgn_server_pw)

            self.log.info("Ixia Lab Server - '%s'" % (self.server_ip))
            self.get_sessions()

            if session_name and kill_existing == True:
                for session in self.testPlatform.Sessions.find(Name=session_name):
                    session.remove()
                    Helper.sleep(15, msg='Waiting for Session Deletion')
                self.session = self.testPlatform.Sessions.add(Name=session_name)
                self.log.info("Ixia Session Created - '%s'" % session_name)
            elif session_name and kill_existing == False:
                if not self.testPlatform.Sessions.find(Name=session_name):
                    raise IxiaConfigException("Session Name '%s' not configured or Failed to connect" % session_name)
                else:
                    self.session = self.testPlatform.Sessions.find(Name=session_name)
            else:
                if self.testPlatform.Sessions.find(Name=self.session_name):
                    self.session = self.testPlatform.Sessions.find(Name=self.session_name)
                else:
                    self.session = self.testPlatform.Sessions.add(Name=self.session_name)
                    self.log.info("Ixia Session Created - '%s'" % session_name)
            self.ixNetwork = self.session.Ixnetwork
            self.session_name = self.session.Name

        # RestPy main entry point object self.ixNetwork

        self.ixNetworkSession = self.testPlatform.Sessions

    def get_remote(self, link):
        """
        Get remote interface

        :param link: link in topology. Ex: 'R1_R2_1'
        :return: Remote interface of link in current device object

        :Example: get_remote('R1_R2_1')
        """
        int1 = link.interface1
        int2 = link.interface2

        if int1.device == self:
            return int2
        return int1

    def get_local(self, link):
        """
        Get local interface

        :param link: link in topology. Ex: 'R1_R2_1'
        :return: Local interface of link in current device object

        :Example: get_local('R1_R2_1')
        """
        int1 = link.interface1
        int2 = link.interface2

        if int1.device == self:
            return int1
        return int2

    def get_links(self, peer=None, link_type=None):
        """
        Returns links between IXIA and its peer

        :param peer: Peer device object
        :param link_type: Link type

        :Example: get_links()
        """
        if peer is None:
            return self.links
        links = {}
        for _interface, int_obj in self.interfaces.items():
            if int_obj.remote is not None and int_obj.remote.device.name == peer:
                if link_type is None:
                    links[int_obj.link.name] = int_obj.link
                else:
                    if int_obj.type == link_type:
                        links[int_obj.link.name] = int_obj.link
        return links

    def get_list_ports(self):
        """
        To get ports in config file

        :return: list of ports in configuration

        :Example: get_list_ports()
        """
        self.log.info("Getting List of Ports")
        return self.ixNetwork.Vport.find()

    def get_list_port_name(self):
        """
        Get list of port names in config

        :return: list of ports in user readable format in the session

        :Example: get_list_port_name()
        """
        self.log.info("vport name list:")
        print(self.ixNetwork.Vport.find())
        vport_name_list =[vport.Name for vport in self.ixNetwork.Vport.find()]
        return vport_name_list

    def new_blank_config(self):
        """
        Upload a new blank config file before loading a new config file

        :Example: new_blank_config()
        """
        self.log.info("Creating new blank config")
        self.ixNetwork.NewConfig()

    def get_traffic_items(self):
        """
        Get trafficItem Names available in the config

        :return: List of enabled traffic name.If failed, raise IxiaOperationException

        :Example: get_traffic_items()
        """
        self.log.info("Available traffic Items")
        try:
            trafficItems = []
            if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                trafficItems.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find()])
            if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
                trafficItems.append([quickFlow.Name for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find()])
            return trafficItems[0]
        except:
            raise IxiaOperationException("No Traffic Items Found")

    def get_active_streams(self):
        """
        Get list of enabled(active) streams in config

        :return: list of active stream names in config

        :Example: get_active_streams()
        """
        self.log.info("Streams in Active State")
        trafficItems = []
        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            trafficItems = self.ixNetwork.Traffic.TrafficItem.find(Enabled=True)
            return [trafficItem.Name for trafficItem in trafficItems if trafficItem]
        elif self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
            if self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True):
                trafficItems = self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Enabled=True)
                return [trafficItem.Name for trafficItem in trafficItems if trafficItem]
        if not trafficItems:
            self.log.error("No Active Traffic Streams")

    def get_interface(self, alias=None, name=None):
        """
        Gets a single interface object based on a name or alias

        :param alias: Alias of interface
        :param name:  Name of the interface
        :return: Interface object

        :Example: get_interface()
        """
        if name:
            return self.interfaces[name]
        return self.interfaces_by_alias[alias]

    def get_interfaces(self, peer=None, int_type=None, zap_only=False, by_name=False, sub_interfaces=False):
        """
        Gets a dict of interface objects based on a name or alias

        :param peer: Per device object
        :param int_type: Interface type
        :param zap_only: True if you want only interfaces defined in zap
        :param by_name: True if key needs to be interface name instead of alias in dictionary of interfaces returned
        :param sub_interfaces: True if sub interfaces are to be included
        :return: Dictionary of interfaces

        :Example: get_interfaces()
        """
        if zap_only:
            interfaces = self.interfaces_in_zap
        else:
            interfaces = self.interfaces

        new_interfaces = {}

        if by_name:
                intf_by_name = {}
                for intf,intf_obj in interfaces.items():
                    intf_by_name[intf_obj.name] = intf_obj
                interfaces = intf_by_name

        if int_type:
            int_type = int_type.upper()
            for intf, intf_obj in interfaces.items():
                if intf_obj.type == int_type:
                    new_interfaces[intf] = intf_obj
            interfaces = new_interfaces

        new_interfaces = {}

        if peer:
            for intf, intf_obj in interfaces.items():
                if intf_obj.remote is not None and intf_obj.remote.device == peer:
                    new_interfaces[intf_obj] = intf_obj.remote
            interfaces = new_interfaces

        for intf, intf_obj in interfaces.items():
                if intf_obj.type == 'vlan':
                    if sub_interfaces:
                        new_interfaces[intf] = intf_obj
                else:
                     new_interfaces[intf] = intf_obj
        interfaces = new_interfaces
        return interfaces

    def get_interfaces_by_name(self, peer=None, int_type=None, zap_only=False):
        """
        get interface by name

        :param peer: The name of the peer
        :param int_type: The interface type
        :param zap_only: Whether or not this interface is zap only

        :Example: get_interfaces_by_name()
        """
        new_interfaces = {}
        if zap_only:
            interfaces = self.interfaces_in_zap
        else:
            interfaces = self.interfaces
        if peer:
            for intf, intf_obj in interfaces.items():
                if intf_obj.remote is not None and intf_obj.remote.device == peer:
                    if int_type:
                        int_type = int_type.upper()
                        if intf_obj.type == int_type:
                            new_interfaces[intf] = intf_obj.remote.name
                    else:
                        new_interfaces[intf] = intf_obj.remote.name
            return list(new_interfaces.keys())
        return list(interfaces.keys())

    def connect_to_chassis(self, chassis_ip_list):
        """
        Connect to IXIA Chassis

        :param chassis_ip_list: list of chassis' IPs to which session has to connect
        :return: True if successful

        :Example: connect_to_chassis(["10.39.60.120"])
        """
        self.log.info("Connection to the Chassis:%s" % (chassis_ip_list))
        timeout = 100
        for chassisIp in chassis_ip_list:
            self.ixNetwork.AvailableHardware.Chassis.add(Hostname=chassisIp)
            for counter in range(1, timeout):
                if self.ixNetwork.AvailableHardware.Chassis.find(Hostname=chassisIp).State == 'ready':
                    break
                else:
                    time.sleep(1)
                if counter == 99:
                    raise IxiaConfigException('Connect Chassis: Connecting to chassis {0} failed'.format(chassisIp))
        return True

    def _update_media_type(self):
        """
        Internal function to update the ports media type to 'Fiber' for NOVUS10G Load Modules
        :return:
        """
        for vport in self.ixNetwork.Vport.find():
            cardType = vport.Type
            if cardType == 'novusTenGigLan':
                cardType = cardType[0].upper() + cardType[1:]
                cardObj = eval('vport.L1Config.' + cardType)
                cardObj.Media = 'fiber'
            if cardType == 'novusHundredGigLan':
                cardType = cardType[0].upper() + cardType[1:]
                cardObj = eval('vport.L1Config.' + cardType)
                cardObj.IeeeL1Defaults = True

    def _assign_ports(self, port_tuple, update_portname=False):
        """
        Function used internally by other APIS,Assign Ports and Verify
        
        :param port_tuple: [[chassisIP, card, port], [chassisIP, card, port],..]
        :param update_portname: True/False
        """
        forceTakePortOwnership = True
        # Forcefully take port ownership if the portList are owned by other users.
        testPorts = []
        self.ixNetwork.Vport.find().UnassignPorts(arg2=False)
        vportList = [vport.href for vport in self.ixNetwork.Vport.find()]
        for port in port_tuple:
            testPorts.append(dict(Arg1=port[0], Arg2=port[1], Arg3=port[2]))
        self.ixNetwork.AssignPorts(testPorts, [], vportList, forceTakePortOwnership)
        self._update_media_type()
        if update_portname:
            for portObj in self.ixNetwork.Vport.find():
                assignedCard = portObj.AssignedTo.split(":")[1]
                assignedPort = portObj.AssignedTo.split(":")[2]
                portObj.Name = assignedCard + '/' + assignedPort

    def _update_port_name(self):
        """
        update the port name accordingly as connected to Chassis

        :return:
        """
        for vport in self.ixNetwork.Vport.find():
            assignedCard = vport.AssignedTo.split(":")[1]
            assignedPort = vport.AssignedTo.split(":")[2]
            portName = vport.Name
            if re.search('//(\d+)/(\d+)', portName):
                existingCard = re.search('//(\d+)/(\d+)', portName).group(1)
                existingPort = re.search('//(\d+)/(\d+)', portName).group(2)

                existing = '//' + existingCard + '/' + existingPort
                assigned = '//' + assignedCard + '/' + assignedPort
                portName = portName.replace(existing, assigned)
                vport.Name = portName

    def load_config(self, config_file=None, port_tuple=None, debug_print=False, reserve_ports=True, **kwargs):
        """
        API used to load existing config file with extension .ixncfg or .json

        :param config_file: The full path including the saved config file
        :param port_tuple: [chassisIP/card/port,chassisIP/card/port,...]
        :param debug_print: Enables the debug - optional
        :param reserve_ports: Reserve the mapped ports in the config - optional
        :return: True if successful else raise Exception

        :Example: load_config(config_file='ospf_bgp_ldp_config.ixncfg', port_tuple=["10.39.60.120/1/1","10.39.60.120/1/2"])
        """
        if self.tgn_server_type == 'linux' and kwargs.get('session_name', None) != None:
            self.connect_to_session(sid=kwargs.get('session_name'))
        else:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        if config_file:
            self.log.info("Loading config file {0}".format(config_file))
            self.ixNetwork.LoadConfig(Files(config_file,local_file=True))
        else:
            self.log.debug('No config file given, attaching to existing session')
            self.new_blank_config()
        self.ixNetwork.Traffic.UseRfc5952 = True
        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True
        if port_tuple:
            self.log.info('List of ports {0}'.format(port_tuple))
            chassis_list = []
            port_list = []
            for port in port_tuple:
                chassis_list_temp = port.split('/')
                port_list_temp = port.split('/')
                if len(chassis_list_temp) < 3:
                    chassis_list.append(self.chassis_ip)
                    port_list_temp.insert(0, self.chassis_ip)
                else:
                    chassis_list.append(port.split('/')[0])
                port_list.append(port_list_temp)
            chassis_list = list(set(chassis_list))
            self.connect_to_chassis(chassis_list)
            self._assign_ports(port_tuple=port_list)
            self._update_port_name()
            # Check if existing session is active
            if self.ixNetworkSession.find().Id == 0:
                raise IxiaConfigException("Existing session inactive")

        # self.get_frame_l4_information()
        if config_file:
            try:self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Start()
            except:pass
            try:self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Start()
            except:pass
            try:self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Start()
            except:pass

        self.log.info("Loading config file complete")
        return True

    def _perform(self, clear_value=None, **kwargs):
        """
        Clears the traffic statistics on the chassis

        :param clear_value: NA for IXIA
        :return: True if success, false if error
        """

        self.clear_traffic_stats()

    def start_all_protocols(self, **kwargs):
        """
        Start all the configured protocols in config file

        :return: True if successful else Raise Exception

        :Example: start_all_protocols()
        """
        self.log.info("Starting all Protocols")
        try: self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().SendNs()
        except: pass
        self.ixNetwork.StartAllProtocols(Arg1='sync')
        return True

    def stop_all_protocols(self, **kwargs):
        """
        Stop all the configured protocols in config file

        :return: True if successful else Raise Exception

        :Example: stop_all_protocols()
        """
        self.log.info("Stopping all Protocols")
        self.ixNetwork.StopAllProtocols(Arg1='sync')
        return True

    def regenerate_traffic(self):
        """
        Regenerate all traffic items

        :return: True else Raise IxiaOperationException if failed

        :Example: regenerate_traffic()
        """
        try:
            self.log.info('Regenerating Traffic Items')
            if self.ixNetwork.Traffic.State == 'started':
                pass
            else:
                trafficItem = self.ixNetwork.Traffic.TrafficItem.find()
                trafficItem.Generate()
        except:
            raise IxiaOperationException("Failed to Re-Generate Traffic")
        return True

    def get_license_details(self):
        """
        Get the Chassis license details from global licensing settings

        :return: License details

        :Example: get_license_details()
        """

        self.log.info("Current License Info: {}".format(self.ixNetwork.Globals.Licensing))
        return self.ixNetwork.Globals.Licensing

    def update_license_server(self, server_ip=None, mode=None, tier=None):
        """
        Update the license server ip, mode, tier

        :param server_ip: license server ip in list
        :param mode: license mode: subscription, perpetual or mixed.
        :param tier: tier1, tier2, tier3, tier3-10g etc.

        :Example: update_license_server(server_ip=["10.39.64.130"], mode="subscription", tier="tier3")
        """
        self._new_session(self.user_name, self.session_name, kill_existing=True)
        if server_ip:
            log.info("setting license info for server : %s" % (server_ip))
            self.ixNetwork.Globals.Licensing.LicensingServers  = server_ip
        if mode:
            log.info("setting license mode : %s" % (mode))
            self.ixNetwork.Globals.Licensing.Mode = mode
        if tier:
            log.info("setting license tier : %s" % (tier))
            self.ixNetwork.Globals.Licensing.Tier = tier
        self.update_license = True

    def _apply_traffic(self):
        """
        API to apply the traffic
        :return:
        """
        self.ixNetwork.Traffic.Apply()
        globals = self.ixNetwork.Globals
        for apperrors in globals.AppErrors.find():
            for error in apperrors.Error.find():
                if hasattr(error, 'Description'):
                    if "One or more destination MACs or VPNs are invalid" in error.Description:
                        raise IxiaOperationException("Failed to apply traffic as packets are not generated properly")
                else:
                    self.log.warning('No Errors: %s' % error)

    def start_traffic(self, traffic_list=None, **kwargs):
        """
        Starts traffic on streams on all Ports or selected Stream blocks

        :param traffic_list: Traffic stream list names on which traffic will be started.
                             If None traffic starts with streams that are already active in config
        :param kwargs: Spirent specific optional argument
                       start_object: Port or Stream
                       ignore_errors : Default is False, send True if want to avoid erros
        :return: True on success

        :Example: start_traffic()
        """

        timeout = 60

        ignore_errors = kwargs.get("ignore_errors",False)
        quick_flow_group = kwargs.get("quick_flow_group", False)
        regenerate = kwargs.get("regenerate", True)

        if self.ixNetwork.Traffic.State not in ['stopped','stoppedWaitingForStats','unapplied']:
            self.stop_traffic()

        if 'traffic_item_list' in kwargs:
            traffic_list = kwargs['traffic_item_list']
        startObject = kwargs.get('start_object', 'stream')
        if startObject.lower() != 'port':
            startObject = 'stream'

        for counter in range(1, timeout):
            if self.ixNetwork.Traffic.State not in ['stopped','stoppedWaitingForStats','unapplied']:
                time.sleep(1)
            else:
                break

        if traffic_list:
            if not quick_flow_group:
                self.enable_traffic_item(traffic_item_list=traffic_list)
            if quick_flow_group:
                for trafficStream in traffic_list:
                    self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Name='^' + trafficStream + '$').Enabled = True

        if regenerate:
            self.log.info('Regenerate traffic items')
            self.regenerate_traffic()
        for counter in range(1, timeout):
            if self.ixNetwork.Traffic.State in ['stopped','stoppedWaitingForStats','unapplied']:
                break
            else:
                time.sleep(1)

        self.log.info('Apply all traffic items')
        if ignore_errors:
            self.ixNetwork.Traffic.Apply()
        else:
            self._apply_traffic()
        for counter in range(1, timeout):
            if self.ixNetwork.Traffic.State in ['stopped','stoppedWaitingForStats','unapplied']:
                break
            else:
                time.sleep(1)

        self.log.info('Starting traffic...')
        if startObject == 'port':
            if 'port_list' in kwargs:
                for name in kwargs['port_list']:
                    self.ixNetwork.Vport.find(Name=name).StartStatelessTraffic()
            else:
                for vport in self.ixNetwork.Vport.find():
                    try:vport.StartStatelessTraffic()
                    except:pass
        elif traffic_list:
            try:
                for trafficStream in traffic_list:
                    trafficStream = trafficStream.replace('+', '\+').replace('*', '\*')
                    try:
                        self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficStream + '$').StartStatelessTraffic()
                    except:
                        self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(
                            Name='^' + trafficStream + '$').StartStatelessTraffic()
            except:
                raise IxiaOperationException("Failed to start Traffic on traffic_stream")
        else:
            try:
                if quick_flow_group:
                    self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find().StartStatelessTraffic()
                    self.log.info("Starting Traffic on all Enabled Quick Flow Groups")
                else:
                    self.ixNetwork.Traffic.Start()
                    self.log.info("Starting Traffic on all Enabled Traffic Items")
            except:
                raise IxiaOperationException("Failed to start Traffic on all enabled Traffic Items")
        for counter in range(1, timeout):
            if self.ixNetwork.Traffic.State == 'started':
                self.log.info('Traffic started')
                break
            else:
                time.sleep(1)
        return True

    def stop_traffic(self,traffic_list=None,**kwargs):
        """
        To Stop traffic

        :param traffic_list: Traffic stream list names on which traffic will be stopped.
                     If None traffic stops with streams that are already active in config
        :return: True if successful else Raise Exception

        :Example: stop_traffic()
        """

        timeout = 60
        sleep_time = kwargs.get('sleep_time', 10)

        if 'traffic_item_list' in kwargs:
            traffic_list = kwargs['traffic_item_list']
        if traffic_list:
            self.log.info('Stopping traffic...')
            try:
                for trafficStream in traffic_list:
                    trafficStream = trafficStream.replace('+', '\+').replace('*', '\*')
                    try: self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficStream + '$').StopStatelessTraffic()
                    except: self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find(Name='^'+trafficStream+'$').StopStatelessTraffic()
            except:
                raise IxiaOperationException("Failed to start Traffic on traffic_stream")
        else:
            self.log.info('Stopping Traffic on All Traffic Items')
            try:
                self.ixNetwork.Traffic.Stop()
                self.log.info("Traffic Stopped Successfully")
            except:
                raise IxiaOperationException("Failed to stop Traffic")
        self.log.info(f'Waiting for {sleep_time} seconds for traffic to fully stop...')
        time.sleep(sleep_time)
        for _ in range(1, timeout):
            if self.ixNetwork.Traffic.State == 'stopped':
                self.log.info("Traffic Stopped Successfully")
                break
            else:
                time.sleep(1)
        return True

    def check_traffic_state(self, expected='stopped', **kwargs):
        """
        Check the traffic current state.
        This is best used before getting stats when you want to assure
        that the traffic is completely stopped to get accurate stats
        Traffic states are:
        startedWaitingForStats, startedWaitingForStreams, started, stopped,
        stoppedWaitingForStats, txStopWatchExpected, locked, unapplied

        :param expected: expected traffic state
        :param kwargs: Optional
        :return: True if state is same as expected value, False otherwise

        :Example: check_traffic_state(expected='stopped')
                check_traffic_state(expected='started')
        """
        self.log.info("Checking Traffic State as: %s" % (expected))
        if self.ixNetwork.Traffic.State == "unapplied":
            self.regenerate_traffic()
            self.ixNetwork.Traffic.Apply()
            trafficState = self.ixNetwork.Traffic.State
        else:
            trafficState = self.ixNetwork.Traffic.State
        self.log.info(trafficState)
        if trafficState.lower() != expected.lower():
            return False
        else:
            return True

    def _portname_location_mapping(self):
        """
        Internal API used by get_stats to map portname with location

        :return:
        """
        portnameLocationDict = {}
        for vport in self.ixNetwork.Vport.find():
            try:
                assignedChassis = vport.AssignedTo.split(":")[0]
                assignedCard = vport.AssignedTo.split(":")[1]
                assignedPort = vport.AssignedTo.split(":")[2]
                portnameLocationDict[vport.Name] = "//"+assignedChassis+"/"+assignedCard+"/"+assignedPort
            except:
                pass

        return portnameLocationDict

    def _change_to_int(self,value):
        """
        internal API used by get_stats to change type
        :param value: value whose datatype to be updated
        :return:
        """
        if value in ('' , ' ' , 'N/A'):
            value = 0
        elif (value != '' or value != ' ') and value != 'N/A':
            value = int(float(value))
        return value

    def get_stats(self, csv_file=None, csv_enable_file_timestamp=False,
                  view_name='Flow Statistics'):
        """
        Get flow statistics and save it in a csv file

        :param csv_file: None or <filename.csv>.
               None will not create a CSV file.
               Provide a <filename>.csv to record all stats to a CSV file.
               Example: getStats(csv_file='Flow_Statistics.csv')
        :param csv_enable_file_timestamp: True or False. If True, timestamp
                will be appended to the filename.
        :param view_name: view_name options (case sensitive):
                "Port Statistics",
                "Tx-Rx Frame Rate Statistics",
                "Port CPU Statistics",
                "Global Protocol Statistics",
                "Protocols Summary",
                "Port Summary",
                "OSPFv2-RTR Drill Down",
                "OSPFv2-RTR Per Port",
                "IPv4 Drill Down",
                "L2-L3 Test Summary Statistics",
                "Flow Statistics",
                "Traffic Item Statistics", \n
                Note: Not all of the view_names are listed here. You have to get the
                exact names from the IxNetwork GUI in statistics based on your
                protocol(s)
        :return:  A dictionary of all the stats: stat_dict[rowNumber][columnName]== stat_value

        :Example: get_stats() \n
                  get_stats(csv_file=None, csv_enable_file_timestamp=False,view_name='Port CPU Statistics') \n
                  get_stats(csv_file="TrafficItemStatistics.csv", csv_enable_file_timestamp=False,view_name='Traffic Item Statistics')
        """
        self.log.info('\ngetStats: %s' % (view_name))
        if csv_file:
            try:
                statsSummary = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)
            except:
                raise IxiaStatsException('getStats: Failed to get stats values')

            csv_filename = csv_file.replace(' ', '_')
            if csv_enable_file_timestamp:
                timestamp = datetime.datetime.now().strftime('%H%M%S')
                if '.' in csv_filename:
                    csv_filename_temp = csv_filename.split('.')[0]
                    csv_filename_extension = csv_filename.split('.')[1]
                    csv_filename = csv_filename_temp + '_' + timestamp + '.' + \
                                   csv_filename_extension
                else:
                    csv_filename = csv_filename + '_' + timestamp

            csv_file = open(csv_filename, 'w')
            csv_write_obj = csv.writer(csv_file)
            # Get the stat column names
            columnCaptions = statsSummary.ColumnHeaders
            if csv_file != None:
                csv_write_obj.writerow(columnCaptions)
                for rowNumber, stat in enumerate(statsSummary.Rows):
                    rowStats = stat.RawData
                for row in rowStats:
                    csv_write_obj.writerow(row)
            return statsSummary, csv_file.name
        else:
            portNameLocationMapping = self._portname_location_mapping()
            TrafficItemStats = StatViewAssistant(self.ixNetwork, view_name, LocalCsvStorage=CafyLog.work_dir)
            column_list = TrafficItemStats.ColumnHeaders

            sequence_check = False
            if self.ixNetwork.Traffic.Statistics.SequenceChecking.Enabled:
                sequence_check = True

            # columns to be deleted from ColumnHeader
            if 'Gap' in column_list:
                column_list.remove('Gap')

            traffic_rows = TrafficItemStats.Rows
            try:
                flow_stats = pd.DataFrame(traffic_rows.RawData, columns=traffic_rows.Columns)
            except:
                self.log.info('printing stats first row')
                self.log.info(traffic_rows.RawData[0])
                self.log.info('printing column names')
                self.log.info(traffic_rows.Columns)
                raise IxiaOperationException("data and columns length doesn't match Exiting !!")

            if 'Packet Loss Duration (ms)' in flow_stats:
                flow_stats['Packet Loss Duration (ms)'] = flow_stats['Packet Loss Duration (ms)'].apply(
                    self._change_to_int)
            if 'Tx Frames' in flow_stats:
                flow_stats['Tx Frames'] = flow_stats['Tx Frames'].apply(self._change_to_int)
            if 'Rx Frames' in flow_stats:
                flow_stats['Rx Frames'] = flow_stats['Rx Frames'].apply(self._change_to_int)

            if 'Tx Rate (Bps)' in flow_stats:
                flow_stats['Tx Rate (Bps)'] = flow_stats['Tx Rate (Bps)'].apply(self._change_to_int)
            if 'Rx Rate (Bps)' in flow_stats:
                flow_stats['Rx Rate (Bps)'] = flow_stats['Rx Rate (Bps)'].apply(self._change_to_int)

            if 'Tx Rate (bps)' in flow_stats:
                flow_stats['Tx Rate (bps)'] = flow_stats['Tx Rate (bps)'].apply(self._change_to_int)
            if 'Rx Rate (bps)' in flow_stats:
                flow_stats['Rx Rate (bps)'] = flow_stats['Rx Rate (bps)'].apply(self._change_to_int)

            if 'Rx L1 Rate (bps)' in flow_stats:
                flow_stats['Rx L1 Rate (bps)'] = flow_stats['Rx L1 Rate (bps)'].apply(self._change_to_int)
            if 'Tx L1 Rate (bps)' in flow_stats:
                flow_stats['Tx L1 Rate (bps)'] = flow_stats['Tx L1 Rate (bps)'].apply(self._change_to_int)

            if 'Loss %' in flow_stats:
                flow_stats['Loss %'] = np.where(flow_stats['Loss %'] == '', '0.00', flow_stats['Loss %'])

            if 'Tx Port' in flow_stats:
                flow_stats['Tx Port Location'] = [portNameLocationMapping[port] for port in flow_stats['Tx Port'].to_list()]
            if 'Rx Port' in flow_stats:
                flow_stats['Rx Port Location'] = [portNameLocationMapping[port] for port in flow_stats['Rx Port'].to_list()]

            if 'IPv4 :Source Address' in flow_stats:
                flow_stats['IP :Source Address'] = flow_stats['IPv4 :Source Address']
            if 'IPv4 :Destination Address' in flow_stats:
                flow_stats['IP :Destination Address'] = flow_stats['IPv4 :Destination Address']
            if 'IPv6 :Source Address' in flow_stats:
                flow_stats['IP :Source Address'] = flow_stats['IPv6 :Source Address']
            if 'IPv6 :Destination Address' in flow_stats:
                flow_stats['IP :Destination Address'] = flow_stats['IPv6 :Destination Address']

            if sequence_check:
                if 'Small Error' in flow_stats:
                    flow_stats['Small Error'] = flow_stats['Small Error'].apply(self._change_to_int)
                if 'Big Error' in flow_stats:
                    flow_stats['Big Error'] = flow_stats['Big Error'].apply(self._change_to_int)
                if 'Reverse Error' in flow_stats:
                    flow_stats['Reverse Error'] = flow_stats['Reverse Error'].apply(self._change_to_int)

                if 'Small Error' in flow_stats and 'Big Error' in flow_stats and \
                        'Reverse Error' in flow_stats:
                    flow_stats['ReorderedFrameCount'] = flow_stats['Small Error'] + flow_stats['Big Error'] + \
                                                        flow_stats['Reverse Error']
                    flow_stats['ReorderedFrameCount'] = flow_stats['ReorderedFrameCount'].apply(self._change_to_int)

                    flow_stats['InOrderFrameCount'] = flow_stats['Rx Frames'] - flow_stats['ReorderedFrameCount']
                    flow_stats['InOrderFrameCount'] = flow_stats['InOrderFrameCount'].apply(self._change_to_int)

                    flow_stats['OutSeqFrameCount'] = flow_stats['ReorderedFrameCount']
        flow_stats.index = np.arange(1, len(flow_stats) + 1)
        return flow_stats.to_dict('index')

    def _traffic_verify(self, RxFrames, TxFrames, FrameDelta, Loss):
        """
        Function used internally by API verify_traffic

        :param RxFrames: Received Frames
        :param TxFrames: Transmitted Frames
        :param FrameDelta: User Passed FrameDelta Value
        :param Loss: Traffic Loss
        """
        if self.expected != None and self.expected_mode == 'percent':
            self.verify_mode = 'Expected Percent'
            actualRate = 100.0 * RxFrames / TxFrames
            expectMax = float(self.expected) + float(self.tolerance)
            expectMin = float(self.expected) - float(self.tolerance)
            if expectMin < 0:
                expectMin = 0
            if actualRate > expectMax or actualRate < expectMin:
                verifyResults = False
            else:
                verifyResults = True
        elif self.expected and self.expected_mode == 'frame':
            self.verify_mode = 'Expected Frame'
            expectMax = TxFrames + int(self.tolerance)
            expectMin = TxFrames - int(self.tolerance)
            if int(RxFrames) > expectMax or int(RxFrames) < expectMin:
                verifyResults = False
            else:
                verifyResults = True
        elif self.tolerance_mode == 'percent':
            self.verify_mode = 'Loss Percent'
            if Loss.isdigit():
                actualRate = float(0)
            else:
                actualRate = float(Loss)
            if actualRate > float(self.tolerance):
                verifyResults = False
            else:
                verifyResults = True
        else:
            self.verify_mode = 'Loss Frame'
            expectMax = int(self.tolerance)
            actualRate = int(FrameDelta)
            if actualRate > expectMax:
                verifyResults = False
            else:
                verifyResults = True

        return verifyResults

    def _mode_flow_stats(self, port, flowStats, modeValue, flowStatHeaderValues, flowStatHeader, flowStatResults):
        """
        Function used internally by API verify_traffic

        :param port: port passed by user
        :param flowStats: Flow Statistics from csv file
        :param modeValue: Mode Value
        :param flowStatHeaderValues: Flow Statistics Header Values from csv file
        :param flowStatHeader: Flow Statistics Header
        :param flowStatResults: Flow Statistics Results
        """
        for rowNumber, flowStat in enumerate(flowStats.Rows):
            if flowStat[modeValue].lower() == port.lower():
                # flowStatHeaderValues.append([flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'],flowStat['Store-Forward Avg Latency (ns)'], flowStat['Frames Delta'], flowStat['Loss %']])
                flowStatHeaderValues.append(
                    [flowStat['Traffic Item'], flowStat[modeValue], flowStat['Tx Frames'], flowStat['Rx Frames'], flowStat['Frames Delta'],
                     flowStat['Loss %']])
                RxFrames = flowStat['Rx Frames']
                TxFrames = flowStat['Tx Frames']
                FrameDelta = flowStat['Frames Delta']
                Loss = flowStat['Loss %']
                flowStatResults.append(self._traffic_verify(RxFrames, TxFrames, FrameDelta, Loss))
        flowStatTable = tabulate.tabulate(flowStatHeaderValues, headers=flowStatHeader, tablefmt='rst')
        self.log.info('Flow Stats for Port: %s',port)
        self.log.info(flowStatTable)

    def verify_traffic(self,
                       traffic_items=None,
                       mode='trafficItem',
                       ports=None,
                       debug=True,
                       tolerance_mode='percent',
                       tolerance=0,
                       expected_mode='percent',
                       expected=None,
                       verify_mode='tx_rx',
                       **kwargs):
        """
        API used to verify traffic

        :param traffic_items: CHOICES Nested dictionary for Traffic Item, tolerance and expect_loss.
                            Default value : {'all_traffic_items':True}
                            OR list of traffic items. Ex: ['traffic item1', 'traffic item2']
        :param mode: CHOICES 'trafficItem', 'rx_port', 'tx_port' Default is 'trafficItem'
        :param ports: A list of ports to verify against
        :param debug: CHOICES None, True (Default)
                    Debug value None is for traffic item or port level verification
                    Debug value is True, verify traffic loss in flow level, when
                    when traffic loss is seen in traffic item or port level, which defined in configuration for flow tracking
        :param tolerance_mode: CHOICES percent, frame. Default is percent
        :param tolerance: CHOICES 0, integer/float. Default is 0
        :param expected_mode: CHOICES percent, frame. Default is percent
        :param expected: CHOICES None, integer/float. Default is None
        :param verify_mode: The verify mode (Spirent only)
        :param kwargs: verify_mode, return_fromat, flow_per_stream
        :return: When no traffic loss,and None for debug option, return stats dictionary of STREAMBLOCK level
                When traffic loss or unexpected traffic, and None for debug option, raise Exception
                with stats dictionary of STREAMBLOCK level
                When traffic loss or unexpected traffic, and debug option is not None, raise Exception
                with 2 stats dictionary. First one is for STREAMBLOCK level and second one is for STREAM level

        :Example: verify_traffic() \n
                  verify_traffic(tolerance=10)
        """
        self.log.info("Traffic Verification Started")
        if 'tolerance_frame' in kwargs.keys():
            tolerance_mode = 'frame'
            tolerance = kwargs['tolerance_frame']
        elif 'tolerance_percent' in kwargs.keys():
            tolerance = kwargs['tolerance_percent']
        if traffic_items is None:
            traffic_items = {'all_traffic_items': True}
        elif isinstance(traffic_items, list):
            _tmp = {'all_traffic_items': False}
            for one_item in traffic_items:
                _tmp[one_item] = {}
            traffic_items = _tmp
        elif isinstance(traffic_items, dict):
            traffic_items['all_traffic_items'] = False

        # check if traffic items passed are present in config
        active_streams = self.get_active_streams()
        traffic_items_to_verify = list(traffic_items)
        if 'all_traffic_items' in traffic_items_to_verify:
            traffic_items_to_verify.remove('all_traffic_items')
        streams_not_in_config = []
        for traffic_item in traffic_items_to_verify:
            if traffic_item not in active_streams:
                streams_not_in_config.append(traffic_item)
        if streams_not_in_config:
            err_msg = 'Streams %s are not in config' % streams_not_in_config
            raise CafyException.InvalidValueError(err_msg)

        if traffic_items_to_verify == []:
            traffic_items_to_verify = active_streams
        if ports is None:
            ports = {'all_ports': True}
        item_stats = self.get_stats(view_name='Traffic Item Statistics')
        if mode == 'trafficItem' and debug == None:
            flow_stats = None
        else:
            flow_stats = self.get_stats()

        stats_objs = TrafficStats(debug=debug,
                                  item_stats=item_stats,
                                  flow_stats=flow_stats,
                                  tolerance_mode=tolerance_mode,
                                  tolerance=tolerance,
                                  expected=expected,
                                  expected_mode=expected_mode,
                                  **kwargs)

        if mode == 'trafficItem':
            stats_objs.drilldown(traffic_items=traffic_items)
        elif mode == 'rx_port' or mode == 'tx_port':
            stats_objs.port_drilldown(ports=ports,
                                      mode=mode,
                                      traffic_items=traffic_items)
        else:
            tmp_msg = "mode:%s not supported" % mode
            return tmp_msg

        item_tb = stats_objs.report(objs=stats_objs.item_objs,
                                    **kwargs)
        if debug:
            flow_tb = stats_objs.report(objs=stats_objs.flow_sorted_objs,
                                        **kwargs)
        if not stats_objs.verify_results:
            self.log.error('Traffic Item:\n' + item_tb)
            if debug:
                self.log.error('Flow:\n' + flow_tb)
            time.sleep(10)
            stats_dict = {}
            i = 1
            for obj in stats_objs.item_objs:
                stats_dict[i] = (obj.traffic_stats)
                i += 1
            if kwargs.get('full_logs', None):
                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()}
                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats, flow_stats])
            else:
                stats_objs.item_stats = {key: value for (key, value) in stats_dict.items()
                                         if stats_dict[key]['Status'] == "fail"}
                exception = CafyException.TgenCheckTrafficError([stats_objs.item_stats])
            exception.item_stats = stats_objs.item_stats
            exception.flow_stats = flow_stats
            raise exception
        self.log.info('Traffic Item:\n' + item_tb)
        if debug:
            self.log.info('Flow:\n' + flow_tb)

            for index in stats_objs.item_stats, flow_stats:
                for item in index.values():
                    if 'Traffic Item' in item:
                        if item['Traffic Item'] in traffic_items_to_verify:
                            if item['Tx Frames'] == 0:
                                msg = 'Tx frames of 0 found for traffic item {}: A problem has occurred\n\
                                       Item Stats: {}\nFlow Stats: {}'.format(item['Traffic Item'],
                                                                              stats_objs.item_stats, flow_stats)
                                raise IxiaOperationException(msg)
                    else:
                        if item['Tx Frames'] == 0:
                            msg = 'Tx frames of 0 found for traffic item {}: A problem has occurred\n\
                                                               Item Stats: {}'.format(item['Rx Port'],stats_objs.item_stats,
                                                                                                      flow_stats)
                            raise IxiaOperationException(msg)

        self.log.info("Traffic Verified Successfully")
        return stats_objs.item_stats, flow_stats

    def get_convergence_time(self,
                             traffic_control=False,
                             traffic_duration=None,
                             return_by='Traffic Item',
                             traffic_items=None,
                             tolerance=0.01,
                             retry_count=1,
                             report_mode='streams',
                             print_flows=True,
                             verify_mode='tx_rx',
                             **kwargs):
        """
        Calculates when the last flow converges in the traffic item and returns the convergence time in sec
        IXIA flow tracking is needed for traffic stats view

        :param traffic_control: optional, default set to False. Make sure the traffic is stopped before calling traffic_control
        :param traffic_duration: must have when traffic_control is set to True
        :param return_by: return convergence time by 'Traffic Item' or 'Source/Dest Port Pair', defaut set to 'Traffic Item'
                raise exceptions when return_by type is not existed in keys of flow.
        :param traffic_items: Traffic Item level stats view, if None is given, all the traffic item will be returned
        :param tolerance: Tolerance percentage for tx and rx rate comparison as rx rate might be a little less than tx
        :param retry_count: number of times to retry
        :param report_mode: (str) Determines the report output type e.g. 'streams', 'flows'
        :param print_flows: Print convergence times for each flow if True
        :param verify_mode: (str) Can be either tx_rx or dropped_frames
        :return: convergence time in ms (milli sec) and last convergence flow for each/given traffic_items.
                If None is returned by convergence time, the flow/traffic item is not converged yet with Loss % 100% loss

        :Example: get_convergence_time() \n
                  get_convergence_time(traffic_items=["Traffic Item 1", "Traffic Item 2"])
        """

        # updated as requested by Olivia(oliviaj@cisco.com)

        self.log.info("Calculating Convergence Time")
        if not traffic_items:
            traffic_items = {'all_traffic_items': True}
        elif isinstance(traffic_items, list):
            _tmp = {'all_traffic_items': False}
            for one_item in traffic_items:
                _tmp[one_item] = {}
            traffic_items = _tmp

        if not isinstance(return_by, str):
            msg = "Only take str for return_by. %s is %s" % (return_by, type(return_by))
            raise TypeError(msg)

        if not isinstance(retry_count, int) or retry_count < 0:
            msg = "Retry count should be int and >=0. %s is %s" % (retry_count, type(retry_count))
            raise TypeError(msg)

        trials = retry_count
        while (trials != 0):
            itemDict = {}
            if traffic_control:
                self.start_traffic()
                if traffic_duration:
                    time.sleep(int(traffic_duration))
                else:
                    msg = 'Cannot control traffic start/stop without duration'
                    self.log.error(msg)
                    raise IxiaOperationException(msg)
                self.stop_traffic()
            if report_mode == 'streams':
                flowStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics', LocalCsvStorage=CafyLog.work_dir)
            else:
                flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
            convergence = True
            flowHeadersList = flowStats.ColumnHeaders
            flowStatHeaderValues = []

            for rowNumber, stat in enumerate(flowStats.Rows):
                headerDict = {}
                for column in flowHeadersList:
                    headerDict[column] = stat[column]
                flowStatHeaderValues.append(headerDict)

            for flowDict in flowStatHeaderValues:
                if flowDict[return_by]:
                    item = flowDict[return_by]
                else:
                    msg = 'The return_by %s is not support in IXIA flow' % return_by
                    self.log.error(msg)
                    raise IxiaOperationException(msg)

                if return_by in 'Traffic Item' and not traffic_items['all_traffic_items']:
                    if item not in traffic_items:
                        continue
                itemDict.setdefault(item, []).append(flowStatHeaderValues.index(flowDict))

            for item, flow in itemDict.items():
                flowItemDict = {}
                for one_flow in flow:
                    flowValues = flowStatHeaderValues[one_flow]
                    firstTime = flowValues['First TimeStamp']
                    lastTime = flowValues['Last TimeStamp']
                    convergenceTime = float(flowValues['Packet Loss Duration (ms)'])
                    txFrames = int(float(flowValues['Tx Frames']))
                    rxFrames = int(float(flowValues['Rx Frames']))
                    rateDelta = txFrames - rxFrames
                    try:
                        loss = float('%.3f' % float(100 * rateDelta / txFrames))
                    except:
                        loss = float(0)
                    flowValues["Convergence Time"] = convergenceTime
                    flowValues["Loss %"] = loss

                    if not firstTime or not lastTime:
                        convergenceTime, convergence = None, False
                        self.log.error('"%s" Did NOT converge. Check if traffic is running.' % (item))
                    else:
                        if report_mode == 'streams':
                            self.log.info('"%s" Converges after %f ms' % (item, convergenceTime))
                        elif print_flows:
                            self.log.info('"Flow-%s" Converges after %f ms' % (one_flow+1, convergenceTime))
                    if report_mode == 'streams':
                        itemDict[item] = flowValues
                    else:
                        flowItemDict.update({"Flow-" + str(one_flow+1): flowValues})
                        itemDict[item] = flowItemDict

            if convergence:
                break
            trials -= 1
        self.clear_traffic_stats()
        return itemDict

    def disable_traffic_item(self, traffic_item_list=None):
        """
        Disable the given traffic items in the list, if no traffic
        items provided, then disable all traffic items instead.

        :param traffic_item_list: (list) list of traffic items to be disabled. if None, disable all
        :return: True if successful else raise exception

        :Example: disable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])
        """
        self.log.info("Disabling Traffic Item/Items")
        if traffic_item_list:
            if isinstance(traffic_item_list, list):
                try:
                    for trafficName in traffic_item_list:
                        trafficName = trafficName.replace('+', '\+').replace('*', '\*').replace('(','\(').replace(')','\)')
                        self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').Enabled = False
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to disable")
            if isinstance(traffic_item_list, str):
                try:
                    self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item_list+'$').Enabled = False
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to disable")
        else:
            try:
                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                    trafficItem.Enabled = False
            except:
                raise IxiaOperationException("Failed to disable TrafficItem")
        self.log.info("Traffic Item/Items Disabled Successfully")
        return True

    def enable_traffic_item(self, traffic_item_list=None):
        """
        Enable the given traffic items in the list, if None given enable all the traffic items

        :param traffic_item_list: list of traffic items to be enabled. if None, enable all
        :return: True if successful else raise Exception

        :Example: enable_traffic_item(traffic_item_list=['Traffic Item 1', 'Traffic Item 2'])
        """

        self.log.info("Enabling Traffic Item/Items")
        if traffic_item_list:
            if isinstance(traffic_item_list, list):
                try:
                    for trafficName in traffic_item_list:
                        trafficName = trafficName.replace('+', '\+').replace('*', '\*').replace('(','\(').replace(')','\)')
                        self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').Enabled = True
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Enable")
            if isinstance(traffic_item_list, str):
                try:
                    self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item_list+'$').Enabled = True
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Enable")
        else:
            try:
                for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                    trafficItem.Enabled = True
            except:
                raise IxiaOperationException("Failed to enable TrafficItem")
        self.log.info("Traffic Item/Items enabled Successfully")
        return True

    def delete_traffic_items(self,traffic_item_list=None):
        """
        API to deleted traffic items

        :param traffic_item_list: list of traffic items to be deleted. if None, delete all
        :return: True
        """
        if traffic_item_list:
            if isinstance(traffic_item_list, list):
                try:
                    for trafficName in traffic_item_list:
                        trafficName = trafficName.replace('+', '\+').replace('*', '\*')
                        self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').remove()
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Delete")
            elif isinstance(traffic_item_list, str):
                try:
                    self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item_list+'$').remove()
                except:
                    raise IxiaOperationException("Not able to find the TrafficItem to Delete")
        else:
            trafficItems = self.ixNetwork.Traffic.TrafficItem.find()
            trafficItems.remove()
        self.log.info("Traffic Item/Items Deleted Successfully")
        return True

    def change_ipv4_tos(self, cfg_dict, traffic_item_list=None):
        """
        Changes the Type of Service (ToS) values in ipv4 stack for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified\n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',
                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \n
                Example: cfg_dict={'displayName':'unused','valueType':'increment','fieldValue':'000 Routine','startValue':'2','stepValue':'1','countValue':'15',
                'randomMask':'3','seed':'1','maxValue':'11','minValue':'0','onTheFlyMask':'6','singleValue':'10'}
        :param traffic_item_list: List of traffic Items name. All Items if it is None. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions

        :Example: change_ipv4_tos(traffic_item_list=["Traffic Item 2"],
                    cfg_dict={'fieldValue':'001 Priority'})
        """

        self.log.info("Changing TOS values in Ipv4")
        if 'displayName' not in cfg_dict:
            cfg_dict['displayName'] = 'Precedence'
        if traffic_item_list:
            for trafficItemName in traffic_item_list:
                trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficItemName+'$').ConfigElement.find():
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        for key in cfg_dict:
                            if key != 'displayName':
                                stackObj.Field.find(DisplayName=cfg_dict['displayName']).ValueType = cfg_dict[
                                    'valueType']
                                if 'valueList' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['valueList'])
                                if 'singleValue' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['singleValue'])
                    else:
                        raise IxiaConfigException("Ipv4 stack not configured on %s" % trafficItemName)
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        for key in cfg_dict:
                            if key != 'displayName':
                                stackObj.Field.find(DisplayName=cfg_dict['displayName']).ValueType = cfg_dict[
                                    'valueType']
                                if 'valueList' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['valueList'])
                                if 'singleValue' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['singleValue'])
                except:pass
        self.log.info("IPv4 TOS Values Updated in Traffic Items")
        return True

    def change_ipv6_traffic_class(self, cfg_dict, traffic_item_list=None):
        """
        Changes the IPv6 traffic class configuration for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified \n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','fieldValue','startValue','stepValue','countValue','randomMask',
                'seed','maxValue','minValue','onTheFlyMask','singleValue', 'valueList' \n
        :param traffic_item_list: List of traffic Items name. All Items if it is None. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions

        :Example: change_ipv6_traffic_class(traffic_item_list=["Traffic Item 3"],
                    cfg_dict={'singleValue':'5'})
        """
        self.log.info("Changing Ipv6 Traffic Class")
        if 'displayName' not in cfg_dict:
            cfg_dict['displayName'] = 'Traffic Class'
        if traffic_item_list:
            for trafficItemName in traffic_item_list:
                trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
                for configObj in self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficItemName+'$').ConfigElement.find():
                    if configObj.Stack.find(DisplayName="IPv6"):
                        stackObj = configObj.Stack.find(DisplayName="IPv6")
                        for key in cfg_dict:
                            if key != 'displayName':
                                stackObj.Field.find(DisplayName=cfg_dict['displayName']).ValueType = cfg_dict[
                                    'valueType']
                                if 'valueList' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['valueList'])
                                if 'singleValue' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['singleValue'])
                    else:
                        raise IxiaConfigException("Ipv6 stack not configured on %s" % trafficItemName)
        else:
            for configObj in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if configObj.Stack.find(DisplayName="IPv6"):
                        stackObj = configObj.Stack.find(DisplayName="IPv6")
                        for key in cfg_dict:
                            if key != 'displayName':
                                stackObj.Field.find(DisplayName=cfg_dict['displayName']).ValueType = cfg_dict[
                                    'valueType']
                                if 'valueList' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['valueList'])
                                if 'singleValue' in cfg_dict['valueType']:
                                    setattr(stackObj.Field.find(DisplayName=cfg_dict['displayName']),
                                            cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                            cfg_dict['singleValue'])
                except:pass
        self.log.info("IPv6 Traffic Class updated in Traffic Items")
        return True

    def _update_prefix_step(self, prefix_step:Union[str, int, dict], pool_handle):
        """
        Internal Method to Set Network group prefix step based on prefix step type and pool handle.
        :param prefix_step: Prefix step value Integer/String/dict
        Ex : to set single value int/str prefix_step = 1 or prefix_step = "1"
        dict type to prefix step in increment/decrement/random type
        Ex : prefix_step = {'mode' : 'increment','start' : 10, 'step' : '1'}
        :param pool_handle: PrefixPool Handle
        """
        if isinstance(prefix_step, (str, int)):
            pool_handle.PrefixAddrStep.Single(prefix_step)
        elif isinstance(prefix_step, dict):
            if 'mode' in prefix_step.keys():
                if prefix_step['mode'] == 'increment':
                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():
                        pool_handle.PrefixAddrStep.Increment(prefix_step['start'], prefix_step['step'])
                    else:
                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')
                elif prefix_step['mode'] == 'decrement':
                    if 'start' in prefix_step.keys() and 'step' in prefix_step.keys():
                        pool_handle.PrefixAddrStep.Decrement(prefix_step['start'], prefix_step['step'])
                    else:
                        raise IxiaConfigException('Please pass Prefix Step Start and Step value')
                elif prefix_step['mode'] == 'random':
                    pool_handle.PrefixAddrStep.Random()
            else:
                raise IxiaConfigException('Please pass Prefix Step Mode increment/decrement/random')

    def _set_bgp_network_group_options(self, pool_handle, route_count, prefix_ip=None, prefixlen=None, prefix_step=None, router_id=None):
        """
        Set Route count and prefix based on Protocol handle.
        :param pool_handle: PrefixPool Handle
        :param route_count: route_count to be updated
        :param prefix_ip: prefix_ip as reference
        :param prefixlen: prefixlen as reference
        :param prefix_step: prefix_step as reference
        :param router_id: router_id as reference
        :return:
        """
        if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:
            if prefix_ip and router_id:
                if prefix_ip in pool_handle.NetworkAddress.Values:
                    ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)
                    value_list = pool_handle.NumberOfAddressesAsy.Values
                    value_list[ip_prefix_index] = route_count
                    pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
                    if prefixlen:
                        value_list = pool_handle.PrefixLength.Values
                        value_list[ip_prefix_index] = prefixlen
                        pool_handle.PrefixLength.ValueList(values=value_list)
                    if prefix_step:
                        value_list = pool_handle.PrefixAddrStep.Values
                        value_list[ip_prefix_index] = prefix_step
                        pool_handle.PrefixAddrStep.ValueList(values=value_list)
            elif router_id and prefix_ip is None:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            router_id_index = (deviceGroupObj.RouterData.find().RouterId.Values).index(router_id)
                            value_list = pool_handle.NumberOfAddressesAsy.Values
                            value_list[router_id_index] = route_count
                            pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
                            if prefixlen:
                                value_list = pool_handle.PrefixLength.Values
                                value_list[router_id_index] = prefixlen
                                pool_handle.PrefixLength.ValueList(values=value_list)
                            if prefix_step:
                                value_list = pool_handle.PrefixAddrStep.Values
                                value_list[router_id_index] = prefix_step
                                pool_handle.PrefixAddrStep.ValueList(values=value_list)
            else:
                pool_handle.NumberOfAddressesAsy.Single(route_count)
                if prefixlen:
                    pool_handle.PrefixLength.Single(prefixlen)
                if prefix_step:
                    self._update_prefix_step(prefix_step, pool_handle)

        # This block for 8.50 version
        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
            pool_handle.NumberOfAddresses = route_count
            if prefixlen:
                pool_handle.PrefixLength.Single(prefixlen)
            if prefix_step:
                self._update_prefix_step(prefix_step, pool_handle)

    def _modify_bgp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix, prefix_step,
                                router_id, **kwargs):
        """
        Internal API to support setting route count and prefix length of BGP network group

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param prefix: prefix
        :param prefix_step: prefix step
        :param router_id: router ID
        :return: result
        """
        protocolStatus = False
        deviceGroupName = None
        nested_network_group = kwargs.get('nested_network_group')
        network_group_name_list = []
        deviceGrpList = self.ixNetwork.Topology.find().DeviceGroup.find()
        for deviceGroupObj in deviceGrpList:
            if deviceGroupObj.RouterData.find():
                for routerId in router_id:
                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceGroupName = deviceGroupObj.Name
                        break
        if network_group:
            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if nested_network_group and network_group:
            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass

            try:
                network_group_name_list = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).
                                            DeviceGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group == networkObj.Name]
            except:
                pass

        if network_group_name_list:
            for each_network_group in network_group_name_list:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + each_network_group + '$')
                if nested_network_group:
                    try:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + each_network_group + '$')
                    except:
                        pass
                    try:
                        network_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).DeviceGroup.find().\
                            DeviceGroup.find().NetworkGroup.find(Name='^' + each_network_group + '$')
                    except:
                        pass

                if ip_type.lower() == "ipv4":
                    for network_group_obj in network_obj.Ipv4PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            protocolStatus = True
                            network_obj.Enabled.Single(True)
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
                if ip_type.lower() == "ipv6":
                    for network_group_obj in network_obj.Ipv6PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            network_obj.Enabled.Single(True)
                            protocolStatus = True
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
        elif router_id != None and deviceGroupName != None:
            networkGrpList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroupName).NetworkGroup.find()
            if ip_type.lower() == "ipv4":
                for networkObj in networkGrpList:
                    for network_group_obj in networkObj.Ipv4PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            protocolStatus = True
                            networkObj.Enabled.Single(True)
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix,prefix_step=prefix_step, router_id=routerid)
            if ip_type.lower() == "ipv6":
                for networkObj in networkGrpList:
                    for network_group_obj in networkObj.Ipv6PrefixPools.find():
                        if network_group_obj.BgpV6IPRouteProperty.find() or network_group_obj.BgpIPRouteProperty.find() or \
                                network_group_obj.BgpL3VpnRouteProperty.find() or network_group_obj.BgpV6L3VpnRouteProperty.find():
                            networkObj.Enabled.Single(True)
                            protocolStatus = True
                            for routerid in router_id:
                                self._set_bgp_network_group_options(network_group_obj, route_count, prefix_ip=start_ip_prefix,
                                                                    prefixlen=prefix, prefix_step=prefix_step, router_id=routerid)
        else:
            raise IxiaConfigException("Router Id or network_group not found ")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("BGP protocol not configured or Configuration issue.")

    def set_bgp_route_count(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                router_id: Router ID of the device
                route_block_name: route block name from config
                start_ip: represents the first IP of the route block
                prefix: Integer/String representing the new prefix
                prefix_step: Prefix step value Integer/String Ex : 1 or "1"
                nested_network_group : if nested network group, Need to pass Nested Network Group Name
        :return: True if the operation is successful, False otherwise

        :Example: set_bgp_route_count(route_count=10, ports=["Ethernet - 001"], network_group="Network Group 9")
        """
        network_group = kwargs.get('route_block_name')
        if 'network_group' in kwargs:
            network_group = kwargs.get('network_group')
        self.log.info("Setting Bgp Route Count for route_block_name:%s" % (network_group))
        startIp = kwargs.get('start_ip')
        prefixLength = kwargs.get('prefix')
        prefix_step = kwargs.get('prefix_step')
        routerId = kwargs.get('router_id')
        if not isinstance(routerId, list):
            routerId = [routerId]
        nestedGroup = kwargs.get('nested_network_group', False)
        if not network_group and routerId is None:
            raise IxiaConfigException('Please pass either Network group/Router Id')
        return self._modify_bgp_route_count(network_group, route_count, ip_type, start_ip_prefix=startIp,
                                            prefix=prefixLength,prefix_step=prefix_step, router_id=routerId,
                                            nested_network_group=nestedGroup)

    def get_frame_l4_information(self):
        """
        Check if L4 header is in traffic stream. Infomation is in the log

        :return: True if all streams with L4 header. False if any stream without L4 header

        :Example: get_frame_l4_information()
        """
        self.log.info("Checking L4 Information is Available in TrafficItem")
        withL4 = []
        withoutL4 = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                stackTypeIdList = [stackObj.StackTypeId for stackObj in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find()]
                if "tcp" in stackTypeIdList:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId="tcp").DisplayName:
                        withL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])
                elif "udp" in stackTypeIdList:
                    if (self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(StackTypeId="udp").DisplayName):
                        withL4.append(trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName[0])
                else:
                    withoutL4.append([trafficItem.Name for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Name == trafficItemName][0])
            if withL4:
                result = True
                self.log.info('Stream with L4 Header:%s' % withL4)
            if withoutL4:
                result = False
                self.log.info('Stream without L4 Header:%s' % withoutL4)
            return result

    def get_ipv4_tos_information(self):
        """
        Get IPv4 Type of Service (ToS) configuration for a given traffic stream

        :return: True if all streams have a ToS configuration.
                False if there is at least one stream without
                a ToS configuration

        :Example: get_ipv4_tos_information()
        """
        self.log.info("Checking Ipv4 TOS information is available in TrafficItem")
        withTos = []
        withoutTos = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                try:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(Name='precedence').ActiveFieldChoice == True:
                        withTos.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(Name='precedence').ActiveFieldChoice)
                except:
                    withoutTos.append(trafficItemName)
        if withoutTos:
            result = False
            self.log.warning('Stream without IPv4 TOS:%s' % withoutTos)
        else:
            if withTos:
                result = True
                self.log.info(withTos)
        return result

    def get_ipv6_traffic_class_information(self):
        """
        Get IPv6 Traffic Class (TC) configuration for a given traffic stream

        :return: True if all streams have a TC configuration.
                False if there is at least one stream without
                a TC configuration

        :Example: get_ipv6_traffic_class_information()
        """

        withTrafficClass = []
        withoutTrafficClass = []
        result = False
        if not self.ixNetwork.Traffic.TrafficItem.find():
            self.log.warning('Traffic Stream not configured')
        else:
            trafficItemNameList = [trafficItemObj.Name for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find() if trafficItemObj]
            for trafficItemName in trafficItemNameList:
                try:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(Name='trafficClass'):
                        withTrafficClass.append(self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(Name='trafficClass'))
                except:
                    withoutTrafficClass.append(trafficItemName)
        if withoutTrafficClass:
            result = False
            self.log.warning('Stream without IPv6 Traffic Class:%s' % withoutTrafficClass)
        else:
            if withTrafficClass:
                result = True
                self.log.info(withTrafficClass)
        return result

    def _connect_ports(self, port, testPorts, vportList, assign_to_physical_port, device_obj, forceTakePortOwnership):
        """
        Connect ports
        :param port:  virtual port
        :param testPorts: physical ports
        :param vportList: vportList
        :param assign_to_physical_port:  True or False
        :param device_obj: Device object
        :param forceTakePortOwnership: True or False

        :return:
        """
        tmp = port.split('/')
        if len(tmp) == 2:
            card, port = tmp
        else:
            chassis = tmp[0]
            card = tmp[1]
            port = tmp[2]
        vportList.append(self.ixNetwork.Vport.add().href)
        if assign_to_physical_port:
            # Assign ports
            if self.chassis_ip:
                testPorts.append(dict(Arg1=self.chassis_ip, Arg2=card, Arg3=port))
            else:
                testPorts.append(dict(Arg1=chassis, Arg2=card, Arg3=port))
        self.ixNetwork.Vport.find().Name = card + "/" + port
        if vportList and testPorts:
            device_obj['vport'] = self.ixNetwork.AssignPorts(testPorts, [], vportList,
                                                             forceTakePortOwnership)
        self._update_media_type()
        self.ixNetwork.Vport.find().ConnectPorts()

    def add_device(self,
                   port_list=None,
                   ipv4_address_start=None,
                   ipv6_address_start=None,
                   igmp_group_start=None,
                   mld_group_start=None,
                   new_config=False,
                   **kwargs):
        """
        Add new device to topology

        Mandatory Args:

        :param port_list: List of physical port name,Format of physical port name: 'chassisIP'/'card'/'port', 'card'/'port'
        :param ipv4_address_start: The starting address for ipv4 devices
        :param ipv6_address_start: The starting address for ipv6 devices
        :param igmp_group_start: The starting group for igmp devices
        :param mld_group_start: The starting group for mld devices
        :param new_config: True if you want to wipe out the old config, False to use the existing one

        Optional Args:

        :param assign_to_physical_port: CHOICES True, False. Default True
                True: Asign physical port to the vport created
                False: Create vport only
        :param port_name_list: CHOICES None, list of string. Default None
                None: use format 'card'/'port'
        :param device_name: Name of the device group name to be created
        :param interface_no_vlan_count: CHOICES integer. Default is 1 for main interface
        :param vlan_count: CHOICES integer. Number of vlan per device. Default 1
        :param vlan_id_count: CHOICES 0, integer. Number of vlan per port.
        :param vlan_id_start: CHOICES List RANGE 0 - 4096.
                Default None for no change, Example: [<outer vlan start id>,<inner vlan start id>]
        :param vlan_id_step: CHOICES integer. Default 0
        :param vlan_id_port_step: CHOICES integer. Default 0
        :param vlan_id_sequence_length: CHOICES integer.
        :param vlan_id_repeat_value: CHOICES integer.
        :param vlan_id_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_id_step_enable: CHOICE bool.
        :param vlan_priority_start: CHOICES integer, list RANGE 0 - 7. Default 0
        :param vlan_priority_step: CHOICES integer. Default 0
        :param vlan_priority_port_step: CHOICES integer. Default 0
        :param vlan_priority_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param vlan_priority_step_enable: CHOICES bool.
        :param vlan_priority_sequence_length: CHOICES integer.
        :param vlan_priority_repeat_value: CHOICES integer.
        :param vlan_tpid: CHOICES '0x8100', '0x88a8', '0x9100', '0x9200', '0x9300'
        :param ipv4_address_start: IPv4 address for first interface
        :param ipv4_address_step: IPv4 address for step
        :param ipv4_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_prefix: CHOICES integer
        :param ipv4_address_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_address_repeat_value(int): repeat value Ex: 1
        :param ipv4_address_sequence_length: CHOICES integer
        :param ipv4_gateway_start: IPv4 address for first interface gateway
        :param ipv4_gateway_step: IPv4 address for step
        :param ipv4_gateway_port_step: CHOICES 'disabled', IPv4 address
        :param ipv4_port_step_enable: CHOICES bool.
        :param ipv4_gateway_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_gateway_repeat_value (int): repeat value Ex: 1
        :param ipv4_gateway_sequence_length: CHOICES integer
        :param ipv4_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv4_address_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv4_gateway_repeat_increment (str): Ex: "0.0.0.1"
        :param ipv6_address_repeat_increment (str): Ex: "0::1"
        :param ipv6_gateway_repeat_increment (str): Ex: "0::1"
        :param ipv6_address_prefix_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_start: IPv6 address for first interface
        :param ipv6_address_step: IPv6 address for step
        :param ipv6_address_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param ipv6_address_prefix: CHOICES integer
        :param ipv6_address_repeat_value(int): repeat value Ex: 1
        :param ipv6_address_sequence_length: CHOICES integer
        :param ipv6_address_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_gateway_start: IPv6 address for first interface gateway
        :param ipv6_gateway_step: IPv6 address for step
        :param ipv6_gateway_port_step: CHOICES 'disabled', IPv6 address
        :param ipv6_port_step_enable: CHOICES bool.
        :param ipv6_gateway_repeat_value(int): repeat value Ex: 1
        :param ipv6_gateway_sequence_length: CHOICES integer
        :param ipv6_gateway_direction: CHOICES 'increment', 'decrement'
        :param igmp_version: CHOICES string/list. 'version1','version2','version3'
        :param igmp_num_of_group_range: CHOICES integer
        :param igmp_group_start: IPv4 multicast address.Default None for no configure igmp
        :param igmp_group_step: IPv4 address. Default '0.0.0.1'
        :param igmp_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_group_port_step: CHOICES 'disable', 'enable', IPv4 address
        :param igmp_group_port_step_enable: CHOICES 'disable', 'enable'
        :param igmp_group_address_count: CHOICES integer.
        :param igmp_group_address_increment: CHOICES IPv4 address
        :param igmp_group_repeat_value(int): repeat value Ex: 1
        :param igmp_group_sequence_length: CHOICES integer.
        :param igmp_source_mode: CHOICES 'include', 'exclude'
        :param igmp_num_source_range: CHOICES integer
        :param igmp_source_start: IPv4 address
        :param igmp_source_step: IPv4 address. Default '0.0.0.1'
        :param igmp_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param igmp_source_port_step: CHOICES 'disabled', IPv4 address
        :param igmp_source_port_step_enable: CHOICES 'disabled','enabled'
        :param igmp_source_addree_increment: IPv4 address
        :param igmp_source_address_count: CHOICES integer
        :param igmp_source_repeat_value(int): repeat value Ex: 1
        :param igmp_source_sequence_length: CHOICES integer
        :param mld_version: CHOICES string/list. 'version1','version2'
        :param mld_num_of group_range: CHOICES integer
        :param mld_group_start: IPv6 multicast address, Default None for no configure mld
        :param mld_group_step: IPv6 address. Default '::1'
        :param mld_group_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_group_port_step: CHOICES 'disabled', IPv6 address
        :param mld_group_port_step_enable: CHOICES 'disabled', 'enabled'
        :param mld_group_address_count: CHOICES integer
        :param mld_group_address_increment: CHOICE IPv6 address
        :param mld_group_repeat_value(int): repeat value Ex: 1
        :param mld_group_sequence_length: CHOICES integer
        :param mld_source_mode: CHOICES 'include', 'exclude'
        :param mld_num_source_range: CHOICES integer
        :param mld_source_start: IPv6 address
        :param mld_source_step: IPv6 address. Default '::1'
        :param mld_source_direction: CHOICES 'increment|decrement|random|repeatableRandom|repeatableRandomRange|custom|single' default is 'single'
        :param mld_source_port_step: CHOICES 'disabled', IPv6 address
        :param mld_source_port_step_enable: CHOICES 'disabled','enabled'
        :param mld_source_address_increment: IPv6 address
        :param mld_source_address_count: CHOICES integer
        :param mld_source_repeat_value(int): repeat value Ex: 1
        :param mld_source_sequence_length: CHOICES integer
        :param multiple_ports_per_topo: CHOICES bool
        :return: device_obj dictionary {'vport':<obj>, 'ipv4':<obj>....}

        #Create device BGP config
        :param bgp_v4_active = True,
        :param bgp_v4_dut = '100.1.0.2',
        :param bgp_v4_dut_ip_address = '100.1.0.2',
        :param bgp_v4_2_byte_as = 100,
        :param bgp_v4_type = 'external'
        :param bgp_v4_enable_4_byte_as = 'True',
        :param bgp_v4_4_byte_as = 66000,
        :param bgp_v4_hold_time_interval = 60,
        :param bgp_v4_keep_alive_interval = 20,
        :param bgp_v4_configure_keep_alive_timer = True,
        :param bgp_v4_enable_graceful_restart = True,
        :param bgp_v4_route_count = 5,
        :param bgp_v4_route_start ='11.11.11.1',
        :param bgp_v4_route_prefix = 28,
        :param bgp_v4_route_prefix_step = 2,
        :param bgp_v4_route_active = True,
        :param bgp_v4_route_segment_type = 'assetconfederation',
        :param bgp_v4_ttl =32,
        :param bgp_v4_authentication = 'md5',
        :param bgp_v4_password = 'ixia1',
        :param bgp_v4_minimum_label =20

        #Create device BGPv6 config
        :param bgp_v6_active=True,
        :param bgp_v6_dut='2000:1:1:1::1',
        :param bgp_v6_dut_ip_address='2000:1:1:1::1',
        :param bgp_v6_type: 'external',
        :param bgp_v6_enable_2_byte_as = 100,
        :param bgp_v6_enable_4_byte_as=True,
        :param bgp_v6_4_byte_as=66000,
        :param bgp_v6_hold_time_interval=60,
        :param bgp_v6_keep_alive_interval=20,
        :param bgp_v6_configure_keep_alive_timer=True,
        :param bgp_v6_enable_graceful_restart=True,
        :param bgp_v6_route_count=10,
        :param bgp_v6_route_start='2000:1:1:1::1',
        :param bgp_v6_route_prefix = 28,
        :param bgp_v6_route_prefix_step = 2,
        :param bgp_v6_route_active=True,
        :param bgp_v6_route_segment_type='assetconfederation',
        :param bgp_v6_ttl=32,
        :param bgp_v6_authentication='md5',
        :param bgp_v6_password='ixia1',
        :param bgp_v6_minimum_label = 20

        :Example: add_device(port_list= ["10.39.60.2/1/1"])
        """
        self.log.info("Adding New Device to the Topology")
        device_obj = kwargs.get('device_obj', {})
        port_name_list = kwargs.get('port_name_list', None)
        assign_to_physical_port = kwargs.get('assign_to_physical_port', True)
        interface_no_vlan_count = kwargs.get('interface_no_vlan_count', 1)
        vlan_id_count = kwargs.get('vlan_id_count', 0)
        forceTakePortOwnership = True
        existingDeviceObj = None
        testPorts = []
        vportList = []
        if self.update_license == False and new_config == True:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        if new_config:
            self.ixNetwork.NewConfig()
        if not new_config:
            vportData = [(vportConnect.AssignedTo).replace(':', '/') for vportConnect in self.get_list_ports()]
            self._update_media_type()
        else:
            vportData = None
        if kwargs.get('multiple_vports_topo', None):
            port_list = [port_list]
        for port in port_list:
            if kwargs.get('multiple_vports_topo', None):
                for vport in port_list[0]:
                    if vportData:
                        if vportData:
                            vportInfo = [port[port.index('/') + 1:] for port in vportData]
                        else:
                            vportInfo = None
                        if vportInfo:
                            if vport in vportInfo:
                                for portObj in self.ixNetwork.Vport.find():
                                    portAssigned = (portObj.AssignedTo).replace(':', '/')
                                    if vport == portAssigned[portAssigned.index('/') + 1:]:
                                        portName = portObj.Name
                                        device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                        break
                                    existingDeviceObj = True
                            else:
                                self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                                    forceTakePortOwnership)
                    else:
                        self._connect_ports(vport, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)
            else:
                if 'vport' not in device_obj and existingDeviceObj is None:
                    if port_name_list:
                        if len(port_list) != len(port_name_list):
                            msg = 'port name:%s do not match ports:%s' % (port_name_list, port_list)
                            self.log.error(msg)
                            raise CafyException.TgenConfigMissingError(msg)

                    if vportData:
                        vportInfo = [port[port.index('/') + 1:] for port in vportData]
                    else:
                        vportInfo = None
                    if vportInfo:
                        temp_port = port
                        port = port[port.index('/') + 1:]
                        if port in vportInfo:
                            for portObj in self.ixNetwork.Vport.find():
                                if port in (portObj.AssignedTo).replace(':', '/'):
                                    portName = portObj.Name
                                    device_obj['vport'] = self.ixNetwork.Vport.find(Name=portName)
                                    break
                            existingDeviceObj = True
                        else:
                            port = temp_port
                            self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                                forceTakePortOwnership)
                    else:
                        self._connect_ports(port, testPorts, vportList, assign_to_physical_port, device_obj,
                                            forceTakePortOwnership)

            if 'topology' not in device_obj:
                topologyObj = None
                if kwargs.get('multiple_vports_topo', None):
                    port = port[0]
                if vportData:
                    vportInfo = [port[port.index('/') + 1:] for port in vportData]
                    if port in vportInfo:
                        for topology in self.ixNetwork.Topology.find():
                            for portObj in self.ixNetwork.Vport.find():
                                portAssigned = (portObj.AssignedTo).replace(':', '/')
                                if port == portAssigned[portAssigned.index('/') + 1:]:
                                    portName = portObj.Name.replace('/', '\/').replace('(', '\(').replace(')', '\)') + '$'
                                    break
                            if self.ixNetwork.Vport.find(Name=portName).href in topology.Vports:
                                device_obj['topology'] = topology
                                topologyObj = True
                                break
                if not topologyObj:
                    if vportList == []:
                        for portObj in self.ixNetwork.Vport.find():
                            if temp_port in (portObj.AssignedTo).replace(':', '/'):
                                vportList.append(portObj.href)
                    device_obj['topology'] = self.ixNetwork.Topology.add(Vports=vportList)

            if 'interface_no_vlan_count' in kwargs:
                multiplier = interface_no_vlan_count + vlan_id_count
            elif vlan_id_count:
                multiplier = vlan_id_count
            else:
                multiplier = 1
            if 'devicegroup_name' not in kwargs:
                kwargs['devicegroup_name'] = None
            if 'device_name' in kwargs:
                kwargs['devicegroup_name'] = kwargs['device_name']
            if 'devicegroup' not in device_obj and existingDeviceObj is None:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            else:
                device_obj['devicegroup'] = device_obj['topology'].DeviceGroup.add(Name=kwargs['devicegroup_name'],
                                                                                   Multiplier=multiplier)
            vlanIdKwargs = {key: kwargs[key] for key in kwargs if "id" in key and kwargs[key] != ""}
            vlanPriorityKwargs = {key: kwargs[key] for key in kwargs if "priority" in key and kwargs[key] != ""}
            if ('ethernet' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                device_obj['ethernet'] = device_obj['devicegroup'].Ethernet.add(Name=None,
                                                                                VlanCount=kwargs.get('vlan_count',
                                                                                                     None))
                if kwargs.get('vlan_count', None) or kwargs.get('vlan_id_step', None):
                    device_obj['ethernet'].UseVlans = True
                if 'interface_no_vlan_count' in kwargs:
                    valueList = ['false' if i <= interface_no_vlan_count else 'true' for i in
                                 range(1, interface_no_vlan_count + vlan_id_count + 1)]
                    device_obj['ethernet'].EnableVlans.ValueList(valueList)
                if 'vlan_id_start' in kwargs:
                    vlanIdKwargs['vlan_id_direction'] = kwargs.get('vlan_id_direction', 'increment')
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanIdKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Id Info configured successfully")

                if 'vlan_priority_start' in kwargs:
                    vlanObj = VLAN(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'], **vlanPriorityKwargs)
                    vlanObj.config()
                    self.log.info("Vlan Priority Info configured successfully")

            ipv4Kwargs = {key: kwargs[key] for key in kwargs if "ipv4" in key and kwargs[key] != ""}
            ipv6Kwargs = {key: kwargs[key] for key in kwargs if "ipv6" in key and kwargs[key] != ""}
            igmpKwargs = {key: kwargs[key] for key in kwargs if "igmp" in key and kwargs[key] != ""}
            mldKwargs = {key: kwargs[key] for key in kwargs if "mld" in key and kwargs[key] != ""}
            bgpv4Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v4" in key and kwargs[key] != ""}
            bgpv6Kwargs = {key: kwargs[key] for key in kwargs if "bgp_v6" in key and kwargs[key] != ""}

            if ('ipv4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv4_address_start:
                    device_obj['ipv4'] = device_obj['ethernet'].Ipv4.add()
                    ipv4Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv4_address_start=ipv4_address_start, **ipv4Kwargs)
                    ipv4Obj.config()
                    self.log.info("Ipv4 Info configured successfully")

            if ('ipv6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if ipv6_address_start:
                    device_obj['ipv6'] = device_obj['ethernet'].Ipv6.add()
                    ipv6Obj = IPV46(ixNetwork=self.ixNetwork, obj=device_obj['ethernet'],
                                    ipv6_address_start=ipv6_address_start, **ipv6Kwargs)
                    ipv6Obj.config()
                    self.log.info("IPv6 Info configured successfully")

            # Create IGMP
            if ('igmp' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if igmp_group_start:
                    if 'ipv4' in device_obj:
                        igmpObj = IGMP(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'],
                                       igmp_group_start=igmp_group_start,
                                       **igmpKwargs)
                        igmpObj.config()
                        self.log.info("Igmp Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
            # Create MLD
            if ('mld' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if mld_group_start:
                    if 'ipv6' in device_obj:
                        mldObj = MLD(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], mld_group_start=mld_group_start,
                                     **mldKwargs)
                        mldObj.config()
                        self.log.info("Mld Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")
            # Create BGPv4
            if ('bgp_v4' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv4Kwargs != {}:
                    if 'ipv4' in device_obj:
                        bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork, obj=device_obj['ipv4'], **bgpv4Kwargs)
                        bgpv4Obj.config()
                        self.log.info("BGPv4 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv4 object not found")
            # Create BGPv6
            if ('bgp_v6' not in device_obj and existingDeviceObj is None) or existingDeviceObj:
                if bgpv6Kwargs != {}:
                    if 'ipv6' in device_obj:
                        bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork, obj=device_obj['ipv6'], **bgpv6Kwargs)
                        bgpv6Obj.config()
                        self.log.info("BGPv6 Info configured successfully")
                    else:
                        raise IxiaConfigException("Ipv6 object not found")

            retryCount = 0
            while True:
                if retryCount == 10: break
                try:
                    self.ixNetwork.Globals.Topology.ApplyOnTheFly()
                    break
                except:
                    time.sleep(3)
                    retryCount = retryCount + 1

        return device_obj

    def _update_traffic_vlan_data(self, configElement, **kwargs):

        """
        Function used internally by API add_traffic_stream

        :param configElement: Config Element of Traffic Item, related to IXIA
        :param kwargs: optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="VLAN")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "VLAN-ID":
                if kwargs.get('vlan_mod_mode', None) == "INCR" or kwargs.get('vlan_mod_mode', None) is None:
                    kwargs['vlan_mod_mode'] = 'increment'
                if kwargs.get('vlan_count', None):
                    kwargs['vlan_mod_count'] = kwargs.get('vlan_count', None)
                if kwargs.get('vlan_id_count', None):
                    kwargs['vlan_mod_count'] = kwargs.get('vlan_id_count', None)
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get('vlan_mod_mode', None), \
                        kwargs.get('vlan_id_start',None), kwargs.get('vlan_mod_count', None), kwargs.get('vlan_id_start', None), kwargs.get('vlan_mod_step', 1)
            if fieldName == "Protocol-ID":
                if kwargs.get('vlan_type', None):
                    kwargs['vlan_type'] = kwargs.get('vlan_type', None)
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    field.ValueType, field.SingleValue, field.Auto, field.FieldValue = 'singleValue', kwargs.get(
                        'vlan_type', None), 'False', kwargs.get('vlan_type', None)

    def _ipv6_address_rfc5952(self, ip):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv6 address
        :return: ipv6 address in rfc5952 format
        """
        output=ipaddress.IPv6Address(ip)
        output=output.compressed
        return output

    def _endpoint_source_handles(self, ip, sourcesList, topology, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param ip:  ipv4,ipv6 address
        :param sourcesList: Traffic Endpoints
        :param topology: TopologyName/TopologyObj which is endpoint
        Optional kwargs :
        :param src_network_group_name (list): Network group name if source is route start address
        """
        sources_route_name = kwargs.get('sources_route_name', None)
        if topology:
            if '.' in ip:
                for ipV4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                    ipv4List = ipV4.Address.Values
                    if ip in ipv4List:
                        sourcesList.append(
                            {"arg1": ipV4.href, "arg2": 1, "arg3": 1, "arg4": ipv4List.index(ip) + 1, "arg5": 1})
                try:
                    if sources_route_name:
                        for network_group in sources_route_name:
                            for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv4PrefixPools.find():
                                ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                if ip in ipv4PrefixPoolList:
                                    sourcesList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                        "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                        "arg5": 1})
                    else:
                        for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                            ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                            if ip in ipv4PrefixPoolList:
                                sourcesList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                    "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                    "arg5": 1})
                except:
                    pass
            elif ':' in ip:
                ip = self._ipv6_address_rfc5952(ip)
                for ipV6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                    ipv6List = ipV6.Address.Values
                    if ip in ipv6List:
                        sourcesList.append(
                            {"arg1": ipV6.href, "arg2": 1, "arg3": 1, "arg4": ipv6List.index(ip) + 1, "arg5": 1})
                try:
                    if sources_route_name:
                        for network_group in sources_route_name:
                            for ipv6PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv6PrefixPools.find():
                                ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                                if ip in ipv6PrefixPoolList:
                                    sourcesList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                        "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                        "arg5": 1})
                    else:
                        for ipv6PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                            ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                            if ip in ipv6PrefixPoolList:
                                sourcesList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                    "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                    "arg5": 1})
                except:
                    pass
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                    sourcesList.append(deviceGroupObj)
                else:
                    for ethernetObj in topology.DeviceGroup.find().Ethernet.find():
                        for vlanObj in ethernetObj.Vlan.find():
                            vlanObjList = vlanObj.VlanId.Values
                            for value in vlanObjList:
                                if value == ip:
                                    sourcesList.append({"arg1": ethernetObj.href, "arg2": 1, "arg3": 1,
                                                        "arg4": vlanObjList.index(ip) + 1,
                                                        "arg5": 1})
        else:
            if '.' in ip:
                for ipV4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                    ipv4List = ipV4.Address.Values
                    if ip in ipv4List:
                        sourcesList.append(
                            {"arg1": ipV4.href, "arg2": 1, "arg3": 1, "arg4": ipv4List.index(ip) + 1, "arg5": 1})
                try:
                    if sources_route_name:
                        for network_group in sources_route_name:
                            for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv4PrefixPools.find():
                                ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                if ip in ipv4PrefixPoolList:
                                    sourcesList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                        "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                        "arg5": 1})
                    else:
                        for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                            ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                            if ip in ipv4PrefixPoolList:
                                sourcesList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                    "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                    "arg5": 1})
                except:
                    pass
            elif ':' in ip:
                ip = self._ipv6_address_rfc5952(ip)
                for ipV6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                    ipv6List = ipV6.Address.Values
                    if ip in ipv6List:
                        sourcesList.append(
                            {"arg1": ipV6.href, "arg2": 1, "arg3": 1, "arg4": ipv6List.index(ip) + 1, "arg5": 1})
                try:
                    if sources_route_name:
                        for network_group in sources_route_name:
                            for ipv6PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv6PrefixPools.find():
                                ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                                if ip in ipv6PrefixPoolList:
                                    sourcesList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                        "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                        "arg5": 1})
                    else:
                        for ipv6PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                            ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                            if ip in ipv6PrefixPoolList:
                                sourcesList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                    "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                    "arg5": 1})
                except:
                    pass
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                    sourcesList.append(deviceGroupObj)
                elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href
                    sourcesList.append(networkGroupObj)
                else:
                    for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():
                        for vlanObj in ethernetObj.Vlan.find():
                            vlanObjList = vlanObj.VlanId.Values
                            for value in vlanObjList:
                                if value == ip:
                                    sourcesList.append({"arg1": ethernetObj.href, "arg2": 1, "arg3": 1,
                                                        "arg4": vlanObjList.index(ip) + 1,
                                                        "arg5": 1})
        return sourcesList

    def _endpoint_destination_handles(self, ip, destinationsList, topology, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv4,ipv6 address
        :param destinationsList: Traffic Endpoints
        :param topology: TopologyName/TopologyObj which is endpoint
        Optional kwargs :
        :param dst_network_group_name (list): Network group name if destination is route start address
        """
        destinations_route_name = kwargs.get('destinations_route_name', None)
        if topology:
            if '.' in ip:
                for ipV4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                    ipv4List = ipV4.Address.Values
                    if ip in ipv4List:
                        destinationsList.append(
                            {"arg1": ipV4.href, "arg2": 1, "arg3": 1, "arg4": ipv4List.index(ip) + 1, "arg5": 1})
                try:
                    if destinations_route_name:
                        for network_group in destinations_route_name:
                            for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv4PrefixPools.find():
                                ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                if ip in ipv4PrefixPoolList:
                                    destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                             "arg4": ipv4PrefixPoolList.index(ip) + 1, "arg5": 1})
                    else:
                        for ipv4PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                            ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                            if ip in ipv4PrefixPoolList:
                                destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                         "arg4": ipv4PrefixPoolList.index(ip) + 1, "arg5": 1})
                except:
                    pass

            elif ":" in ip:
                ip = self._ipv6_address_rfc5952(ip)
                for ipV6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                    ipv6List = ipV6.Address.Values
                    if ip in ipv6List:
                        destinationsList.append(
                            {"arg1": ipV6.href, "arg2": 1, "arg3": 1, "arg4": ipv6List.index(ip) + 1, "arg5": 1})
                try:
                    if destinations_route_name:
                        for network_group in destinations_route_name:
                            for ipv6PrefixPool in topology.DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$').Ipv6PrefixPools.find():
                                ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                                if ip in ipv6PrefixPoolList:
                                    destinationsList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                             "arg4": ipv6PrefixPoolList.index(ip) + 1, "arg5": 1})
                    else:
                        for ipv6PrefixPool in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                            ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                            if ip in ipv6PrefixPoolList:
                                destinationsList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                         "arg4": ipv6PrefixPoolList.index(ip) + 1, "arg5": 1})

                except:
                    pass
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                    destinationsList.append(deviceGroupObj)
                else:
                    for ethernetObj in topology.DeviceGroup.find().Ethernet.find():
                        for vlanObj in ethernetObj.Vlan.find():
                            vlanObjList = vlanObj.VlanId.Values
                            for value in vlanObjList:
                                if value == ip:
                                    destinationsList.append({"arg1": ethernetObj.href, "arg2": 1, "arg3": 1,
                                                             "arg4": vlanObjList.index(ip) + 1, "arg5": 1})

        else:
            if '.' in ip:
                for ipV4 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                    ipv4List = ipV4.Address.Values
                    if ip in ipv4List:
                        destinationsList.append(
                            {"arg1": ipV4.href, "arg2": 1, "arg3": 1, "arg4": ipv4List.index(ip) + 1, "arg5": 1})
                try:
                    if destinations_route_name:
                        for network_group in destinations_route_name:
                            for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+network_group+'$').Ipv4PrefixPools.find():
                                ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                                if ip in ipv4PrefixPoolList:
                                    destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                             "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                             "arg5": 1})
                    else:
                        for ipv4PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                            ipv4PrefixPoolList = ipv4PrefixPool.NetworkAddress.Values
                            if ip in ipv4PrefixPoolList:
                                destinationsList.append({"arg1": ipv4PrefixPool.href, "arg2": 1, "arg3": 1,
                                                         "arg4": ipv4PrefixPoolList.index(ip) + 1,
                                                         "arg5": 1})
                except:
                    pass

            elif ":" in ip:
                ip = self._ipv6_address_rfc5952(ip)
                for ipV6 in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                    ipv6List = ipV6.Address.Values
                    if ip in ipv6List:
                        destinationsList.append(
                            {"arg1": ipV6.href, "arg2": 1, "arg3": 1, "arg4": ipv6List.index(ip) + 1, "arg5": 1})
                try:
                    if destinations_route_name:
                        for network_group in destinations_route_name:
                            for ipv6PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+network_group+'$').Ipv6PrefixPools.find():
                                ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                                if ip in ipv6PrefixPoolList:
                                    destinationsList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                             "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                             "arg5": 1})
                    else:
                        for ipv6PrefixPool in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                            ipv6PrefixPoolList = ipv6PrefixPool.NetworkAddress.Values
                            if ip in ipv6PrefixPoolList:
                                destinationsList.append({"arg1": ipv6PrefixPool.href, "arg2": 1, "arg3": 1,
                                                         "arg4": ipv6PrefixPoolList.index(ip) + 1,
                                                         "arg5": 1})
                except:
                    pass
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + ip + '$').href
                    destinationsList.append(deviceGroupObj)
                elif self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$'):
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^'+ip+'$').href
                    destinationsList.append(networkGroupObj)
                else:
                    for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find():
                        for vlanObj in ethernetObj.Vlan.find():
                            vlanObjList = vlanObj.VlanId.Values
                            for value in vlanObjList:
                                if value == ip:
                                    destinationsList.append({"arg1": ethernetObj.href, "arg2": 1, "arg3": 1,
                                                             "arg4": vlanObjList.index(ip) + 1,
                                                             "arg5": 1})
        return destinationsList

    def _update_traffic_ipv4_data(self, configElement, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param configElement:  Traffic Item Config Element
        :param kwargs: Optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="IPv4")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "Source Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v4_src_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v4_src_value']
                        field.StepValue = kwargs.get('v4_src_step', "0.0.0.1")
                        field.CountValue = kwargs.get('v4_src_count', 1)
                    if isinstance(kwargs.get('v4_src_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v4_src_value']
            if fieldName == "Destination Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v4_dst_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v4_dst_value']
                        field.StepValue = kwargs.get('v4_dst_step', "0.0.0.1")
                        field.CountValue = kwargs.get('v4_dst_count', 1)
                    if isinstance(kwargs.get('v4_dst_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v4_dst_value']
            if fieldName == 'TTL (Time to live)':
                field_obj_list = stackObj.Field.find(Name='ttl')
                for field in field_obj_list:
                    if isinstance(kwargs.get('v4_ttl', None), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v4_ttl')
                        field.StepValue = kwargs.get('v4_ttl_step', 1)
                        field.CountValue = kwargs.get('v4_ttl_count', 1)
                    if isinstance(kwargs.get('v4_ttl', None), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v4_ttl')
            if fieldName == "Protocol":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v4_protocol', None), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v4_protocol', None)
                        field.StepValue = kwargs.get('v4_protocol_step', 1)
                        field.CountValue = kwargs.get('v4_protocol_count', 1)
                    if isinstance(kwargs.get('v4_protocol', None), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v4_protocol', None)
                    if isinstance(kwargs.get('v4_protocol', None), str):
                        field.Auto = False
                        field.ValueType = 'singleValue'
                        field.FieldValue = kwargs.get('v4_protocol', None)


    def _update_traffic_ipv6_data(self, configElement, **kwargs):
        """
        Function used internally by API add_traffic_stream

        :param configElement:  Traffic Item Config Element
        :param kwargs: Optional
        """

        stackObjList = [stackObj for stackObj in configElement.Stack.find(DisplayName="IPv6")]
        if kwargs.get('stack_id', None):
            stackObj = stackObjList[kwargs.get('stack_id', None)]
        else:
            stackObj = stackObjList[0]
        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
        for fieldName in fieldNames:
            if fieldName == "Source Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v6_src_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v6_src_value']
                        field.StepValue = kwargs.get('v6_src_step', "0::1")
                        field.CountValue = kwargs.get('v6_src_count', 1)
                    if isinstance(kwargs.get('v6_src_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_src_value']
            if fieldName == "Destination Address":
                fieldObjList = stackObj.Field.find(DisplayName=fieldName)
                for field in fieldObjList:
                    if isinstance(kwargs['v6_dst_value'], str):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs['v6_dst_value']
                        field.StepValue = kwargs.get('v6_dst_step', "::1")
                        field.CountValue = kwargs.get('v6_dst_count', 1)
                    if isinstance(kwargs.get('v6_dst_value'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_dst_value']
            if fieldName == "Flow Label":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v6_flow_label'), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v6_flow_label', None)
                        field.StepValue = kwargs.get('v6_label_step', 1)
                        field.CountValue = kwargs.get('v6_label_count', 1)
                    if isinstance(kwargs.get('v6_flow_label'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs.get('v6_flow_label', None)
            if fieldName == "Hop Limit":
                field_obj_list = stackObj.Field.find(DisplayName=fieldName)
                for field in field_obj_list:
                    if isinstance(kwargs.get('v6_ttl'), int):
                        field.Auto = False
                        field.ValueType = 'increment'
                        field.StartValue = kwargs.get('v6_ttl')
                        field.StepValue = kwargs.get('v6_ttl_step', 1)
                        field.CountValue = kwargs.get('v6_ttl_count', 1)
                    if isinstance(kwargs.get('v6_ttl'), list):
                        field.Auto = False
                        field.ValueType = 'valueList'
                        field.ValueList = kwargs['v6_ttl']

    def _expand_ipv6_address(self, ip):
        """
        Function used internally by API add_traffic_stream

        :param ip: ipv6 address
        :return: expanded ipv6 address
        """
        if "::" in ip:
            match = re.search("^([a-fA-F0-9]+):([a-fA-F0-9]+):([a-fA-F0-9]+)::([a-fA-F0-9]+)$", ip)
            ip = match.group(1) + ":" + match.group(2) + ":" + match.group(3) + ":0:0:0:0:" + match.group(4)
        if "::" in ip:
            match = re.search("^([a-fA-F0-9]+)::([a-fA-F0-9]+)$", ip)
            ip = match.group(1) + ":0:0:0:0:0:0:" + match.group(2)
        return ip

    def add_traffic_stream(self,
                           sources,
                           destinations,
                           mcast_destinations=None,
                           traffic_type='ipv4',
                           **kwargs):
        """
        API for adding a new L2/L3 traffic item in IXIA config
        :param sources: A list of sources
        :param destinations: A list of destinations
        :param mcast_destinations: A list of mcast destinations
        :param mcast_destinations_index : A list of mcast destinations index. Default is all
        :param traffic_type: The traffic type to use (ipv4/ipv6)
        Mandatory Args:
        :param sources (list): A list of address sources
            e.g. ['172.16.0.1', '172.16.50.1', '172.16.100.1']
        :param destinations (list): A list of addresses or route ranges
            e.g. ['225.0.0.1', '225.1.0.1', '225.1.0.21']
        Optional Args:
        :param traffic_type (str): The address family that you wish to use for
            this traffic item ['ipv4'|'ipv6']
        :param is_mcast_dest (bool): Designates if this
        Optional kwargs (for creating stream objects via zap):
        :param src_ports (list): Source ports. Ex: src_ports = ['2/9']
        :param dst_ports (list): Destionation ports. Ex: dst_ports = ['2/10']
        Traffic
        :param traffic_item_name (str): The traffic items name
        :param src_dest_mesh_type (str): Options are fullMesh,manyToMany,none,oneToOne
        :param route_mesh_type (str): Options are fullMesh,oneToOne
        :param bidirectional (bool): If true, enables bidirectional for a traffic item
        :param transmit_mode (str): Options are interleaved,sequential
        :param enabled (boo): If true, enable the traffic item
        Frame Payload
        :param payload_type (str): Options are CJPAT,CRPAT,custom,decrementByte,
                decrementWord,incrementByte,incrementWord,random
        :param payload_custom_pattern (str): The custom pattern in hex format
        :param payload_custom_repeat (bool): If true, repeat the custom pattern
        Frame Rate
        :param rate_type (str): Options are bitsPerSecond,framesPerSecond,
                interPacketGap,percentLineRate
        :param bit_rate_units (str): Options are bitsPerSec,bytesPerSec,kbitsPerSec,
                kbytesPerSec,mbitsPerSec,mbytesPerSec
        :param frame_rate (int): The frame transmission rate
        :param enforce_min_inter_packet_gap (int): Sets the minimum inter-packet gap
        :param inter_packet_gap_units_type (str): Options are bytes,nanoseconds
        Frame Rate Distribution
        :param port_distribution (str): applyRateToAll,splitRateEvenly
        :param stream_distribution (str): applyRateToAll,splitRateEvenly
        Frame Size
        :param frame_size_type (str): Options are auto,fixed,increment,presetDistribution,
                 quadGaussian,random,weightedPairs
        :param frame_size_fixed_size (int): Sets a fixed frame size
        :param frame_size_increment_start (int): Specifies the Start Value if the Frame
                Size is incremented
        :param frame_size_increment_stop (int): Specifies the Final Value if the Frame
                Size is Incremented
        :param frame_size_increment_step (int): Specifies the Step Value if the Frame
                Size is Incremented
        :param frame_size_preset_distribution (str): Options are cisco,imix,ipSecImix,ipV6Imix,
                prQuar,rprTri,standardImix,tcpImix,tolly
        :param frame_size_quad_gaussian (list): Please reference the below address for details
                <IXIA_API_SERVER>:25445/api/v1/meta/traffic/trafficItem/configElement/frameSize
        :param frame_size_random_min (int): Minimum frame size length (in bytes). Max is 64
        :param frame_size_random_max (int): Maximum frame size length (in bytes). Max is 1518
        :param frame_size_weighted_pairs (list): Defines the values for a list of weighted pairs
        :param frame_size_weighted_pairs_range (list): Defines the range for a list of weighted pairs
        :param sources_route_name (list): source network group name
        :param destinations_route_name (list): destination network group name
        :param stats_track_by (list): track the traffic item by  ['customOverride', 'sourceDestValuePair0',
                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',
                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',
                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',
                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',
                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',
                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',
                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']
        :return: (obj): The stream object
        :Example: add_traffic_stream(sources=['109.1.0.2'],destinations=['109.1.0.1'],mcast_destinations=['225.0.0.1'], rate_type='framesPerSecond', frame_rate=20, frame_size_fixed_size=128)
        """
        sources_route_name = kwargs.get('sources_route_name', None)
        destinations_route_name = kwargs.get('destinations_route_name', None)
        stats_track_by = kwargs.get('stats_track_by', None)
        mcast_destinations_index = kwargs.get('mcast_destinations_index', 'all')
        if 'port_name' in kwargs:
            if kwargs['port_name'].startswith("Port"):
                kwargs['port_name'] = kwargs['port_name'].split("Port //")[1]

        if 'src_ports' in kwargs:
            temp_src_ports = []
            for src_port in kwargs['src_ports']:
                if src_port.startswith("Port"):
                    temp_src_ports.append(src_port.split("Port //")[1])
            if temp_src_ports:
                kwargs['src_ports'] = temp_src_ports
            if sources:
                sources = None

        if 'dst_ports' in kwargs:
            temp_dst_ports = []
            for dst_port in kwargs['dst_ports']:
                if dst_port.startswith("Port"):
                    temp_dst_ports.append(dst_port.split("Port //")[1])
            if temp_dst_ports:
                kwargs['dst_ports'] = temp_dst_ports
            if destinations:
                destinations = None

        self.log.info("Adding New Traffic Stream")
        self.ixNetwork.Traffic.UseRfc5952 = True
        self.ixNetwork.Traffic.Statistics.PacketLossDuration.Enabled = True
        stream_obj = kwargs.get('stream_obj', {})
        if 'traffic' not in stream_obj and 'traffic_item' not in stream_obj:
            if traffic_type == 'eth' or traffic_type == 'ethernetVlan':
                traffic_type = 'ethernetVlan'
                if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None):
                    traffic_type = 'raw'
                if sources is None or destinations is None:
                    traffic_type = 'raw'
            elif traffic_type == "ipv4" and kwargs.get("v4_src_value", None) is None and kwargs.get("v4_src_count",
                                                                                                    None) is None:
                traffic_type = 'ipv4'
            elif traffic_type == "ipv6" and kwargs.get("v6_src_value", None) is None and kwargs.get("v6_src_count",
                                                                                                    None) is None:
                traffic_type = 'ipv6'
            else:
                traffic_type = 'raw'
            if traffic_type == 'ethernetVlan':
                if sources or destinations:
                    for source in sources:
                        if '.' in source or ':' in source:
                            raise IxiaConfigException(
                                "For Ethernet stream please pass deviceGroup name instead of Ip address")
                    for destination in destinations:
                        if '.' in destination or ':' in destination:
                            raise IxiaConfigException(
                                "For Ethernet stream please pass deviceGroup name instead of Ip address")
            trafficItem = self.ixNetwork.Traffic.TrafficItem.add(TrafficType=traffic_type,
                                                                 SrcDestMesh=kwargs.get('src_dest_mesh_type', None),
                                                                 RouteMesh=kwargs.get('route_mesh_type', None),
                                                                 BiDirectional=kwargs.get('bidirectional', None),
                                                                 TransmitMode=kwargs.get('transmit_mode', None),
                                                                 Enabled=kwargs.get('enabled', True))
            self.ixNetwork.Traffic.EnableMinFrameSize = 'True'
            if 'traffic_item_name' in kwargs:
                trafficItem.Name = kwargs['traffic_item_name']
            stream_obj['traffic'] = trafficItem
        # self.log.info("Adding Endpoints for Traffic stream %s" % stream_obj['traffic'])
        self.log.info("Added Traffic Stream %s" % stream_obj['traffic'])
        self.log.info("Adding Endpoints for Traffic stream - '%s'" % trafficItem.Name) # Change the log info to TI Name
        if 'endpoint_sets' not in stream_obj:
            sourcesList = []
            destinationsList = []
            multicastDestinations = []
            multicast_address = []
            if traffic_type == 'raw':
                if kwargs.get('src_ports', None):
                    portName = kwargs.get("port_name", None)
                    for srcPort in kwargs['src_ports']:
                        portNameList = self._get_port_name_list([srcPort])
                        for portName in portNameList:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            sourcesList.append(vportHref + '/protocols')
                else:
                    portName = kwargs.get("port_name", None)
                    vportHref = self.ixNetwork.Vport.find(Name=portName).href
                    sourcesList.append(vportHref + '/protocols')
            else:
                if kwargs.get('src_ports', None):
                    portNameList = self._get_port_name_list(kwargs['src_ports'])
                    portName = kwargs.get("port_name", None)
                    if portName in portNameList:
                        for topology in self.ixNetwork.Topology.find():
                            if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                if sources:
                                    for sourceIp in sources:
                                        self._endpoint_source_handles(sourceIp, sourcesList, topology)
                                else:
                                    for srcPort in kwargs['src_ports']:
                                        portNameList = self._get_port_name_list([srcPort])
                                        if portName in portNameList:
                                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                            sourcesList.append(vportHref + '/protocols')
                else:
                    if sources:
                        for sourceIp in sources:
                            self._endpoint_source_handles(sourceIp, sourcesList, topology=None, sources_route_name=sources_route_name)
                    if kwargs.get('src_ports', None):
                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                        portName = kwargs.get("port_name", None)
                        if portName in portNameList:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            sourcesList.append(vportHref + '/protocols')
                    if kwargs.get("v4_src_addr", None):
                        self._endpoint_source_handles(kwargs["v4_src_addr"], sourcesList, topology=None)
                    if kwargs.get("v6_src_addr", None):
                        self._endpoint_source_handles(kwargs["v6_src_addr"], sourcesList, topology=None)
            if traffic_type == 'raw':
                if kwargs.get('dst_ports', None):
                    portname = kwargs.get("port_name", None)
                    for dstPort in kwargs['dst_ports']:
                        portNameList = self._get_port_name_list([dstPort])
                        for portName in portNameList:
                            if portName != portname:
                                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                destinationsList.append(vportHref + '/protocols')
                else:
                    portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                    portname = kwargs.get("port_name", None)
                    for portName in portNameList:
                        if portName != portname:
                            vportHref = self.ixNetwork.Vport.find(Name=portName).href
                            destinationsList.append(vportHref + '/protocols')
            else:
                if kwargs.get('dst_ports', None):
                    portNameList = self._get_port_name_list(kwargs['dst_ports'])
                    portname = kwargs.get("port_name", None)
                    for portName in portNameList:
                        if portName != portname:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                    if destinations:
                                        for dstIp in destinations:
                                            self._endpoint_destination_handles(dstIp, destinationsList, topology)
                                    else:
                                        if kwargs.get('dst_ports', None):
                                            for dstPort in kwargs['dst_ports']:
                                                portNameList = self._get_port_name_list([dstPort])
                                                for portName in portNameList:
                                                    if portName != portname:
                                                        vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                                        destinationsList.append(vportHref + '/protocols')
                else:
                    if destinations:
                        for dstIp in destinations:
                            self._endpoint_destination_handles(dstIp, destinationsList, topology=None, destinations_route_name=destinations_route_name)
                    if kwargs.get('dst_ports', None):
                        portNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                        portname = kwargs.get("port_name", None)
                        for portName in portNameList:
                            if portName != portname:
                                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                                destinationsList.append(vportHref + '/protocols')
                    if kwargs.get("v4_dst_addr", None):
                        self._endpoint_destination_handles(kwargs["v4_dst_addr"], destinationsList, topology=None)
                    if kwargs.get("v6_dst_addr", None):
                        self._endpoint_destination_handles(kwargs["v6_dst_addr"], destinationsList, topology=None)

            if kwargs.get('src_ports', None) is None and sources is None:
                if traffic_type == 'raw':
                    if kwargs.get('v4_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    if '.' in kwargs['v4_src_addr']:
                                        nameList = [name.Name for name in
                                                    topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]
                                        for name in nameList:
                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(
                                                Name=name).Address
                                            if kwargs['v4_src_addr'] in address.Values:
                                                sourcesList.append(self.ixNetwork.Vport.find(
                                                    Name=kwargs.get('port_name', None)).href + '/protocols')
                    if kwargs.get('v6_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    if ':' in kwargs['v6_src_addr']:
                                        nameList = [name.Name for name in
                                                    topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]
                                        for name in nameList:
                                            address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(
                                                Name=name).Address
                                            if kwargs['v6_src_addr'] in address.Values:
                                                sourcesList.append(self.ixNetwork.Vport.find(
                                                    Name=kwargs.get('port_name', None)).href + '/protocols')
                else:
                    if kwargs.get('v4_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    self._endpoint_source_handles(kwargs['v4_src_addr'], sourcesList, topology)
                    if kwargs.get('v6_src_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        if kwargs.get('port_name', None) in portNameList:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == self.ixNetwork.Vport.find(
                                        Name=kwargs.get('port_name', None)).href:
                                    self._endpoint_source_handles(kwargs['v6_src_addr'], sourcesList, topology)
            if kwargs.get('dst_ports', None) is None and destinations is None:
                if traffic_type == 'raw':
                    if kwargs.get('v4_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        if '.' in kwargs['v4_dst_addr']:
                                            nameList = [name.Name for name in
                                                        topology.DeviceGroup.find().Ethernet.find().Ipv4.find() if name]
                                            for name in nameList:
                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv4.find(
                                                    Name=name).Address
                                                if kwargs['v4_dst_addr'] in address.Values:
                                                    destinationsList.append(self.ixNetwork.Vport.find(
                                                        Name=kwargs.get('port_name', None)).href + '/protocols')
                                                    break
                    if kwargs.get('v6_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        if ':' in kwargs['v6_dst_addr']:
                                            nameList = [name.Name for name in
                                                        topology.DeviceGroup.find().Ethernet.find().Ipv6.find() if name]
                                            for name in nameList:
                                                address = topology.DeviceGroup.find().Ethernet.find().Ipv6.find(
                                                    Name=name).Address
                                                if kwargs['v6_dst_addr'] in address.Values:
                                                    destinationsList.append(self.ixNetwork.Vport.find(
                                                        Name=kwargs.get('port_name', None)).href + '/protocols')
                                                    break
                else:
                    if kwargs.get('v4_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        self._endpoint_source_handles(kwargs['v4_dst_addr'], destinationsList, topology)
                    if kwargs.get('v6_dst_addr', None):
                        portNameList = [port.Name for port in self.ixNetwork.Vport.find()]
                        for portName in portNameList:
                            if kwargs.get('port_name', None) != portName:
                                for topology in self.ixNetwork.Topology.find():
                                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                                        self._endpoint_source_handles(kwargs['v6_dst_addr'], destinationsList, topology)
            if mcast_destinations:
                # search igmp/mld
                if traffic_type == 'ipv4':
                    try:
                        for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find():
                            igmpStartMcastAddressList = igmpMcastObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in igmpStartMcastAddressList:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_dest_ip, "arg4": str(
                                                igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrIncr),
                                                                 'arg5': str(
                                                                     igmpMcastObj.IgmpMcastIPv4GroupList.McastAddrCnt)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv4/\d+/igmpHost/\d+', '',
                                                                   igmpMcastObj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier

                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": igmpMcastObj.IgmpMcastIPv4GroupList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})

                        for pimv4_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find():
                            pimv4_group_address_list = pimv4_obj.PimV4JoinPruneList.GroupV4Address.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in pimv4_group_address_list:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_dest_ip, "arg4": "0.0.0.1", 'arg5': str(
                                                pimv4_obj.PimV4JoinPruneList.GroupAddressCount)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv4/\d+/pimV4Interface/\d+', '',
                                                                   pimv4_obj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier

                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": pimv4_obj.PimV4JoinPruneList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                    except:
                        pass
                if traffic_type == 'ipv6':
                    try:
                        for mldMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find():
                            mldStartMcastAddressList = mldMcastObj.MldMcastIPv6GroupList.StartMcastAddr.Values
                            for mcast_dest_ip in mcast_destinations:
                                mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)
                                if mcast_ip in mldStartMcastAddressList:
                                    if mcast_destinations_index == 'all':
                                        multicast_address.append({"arg1": False, "arg2": "none",
                                                                 "arg3": mcast_ip, "arg4": str(
                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrIncr), 'arg5': str(
                                                mldMcastObj.MldMcastIPv6GroupList.McastAddrCnt)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv6/\d+/mldHost/\d+', '',
                                                                   mldMcastObj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier
                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": mldMcastObj.MldMcastIPv6GroupList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                        for pimv6_obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find():
                            pimv6_group_address_list = pimv6_obj.PimV6JoinPruneList.GroupV6Address.Values
                            for mcast_dest_ip in mcast_destinations:
                                if mcast_dest_ip in pimv6_group_address_list:
                                    mcast_ip = self._ipv6_address_rfc5952(mcast_dest_ip)
                                    if mcast_destinations_index == 'all':
                                        if mcast_ip in pimv6_group_address_list:
                                            multicast_address.append({"arg1": False, "arg2": "none",
                                                                     "arg3": mcast_ip, "arg4": "::0.0.0.1", 'arg5': str(
                                                    pimv6_obj.PimV6JoinPruneList.GroupAddressCount)})
                                    else:
                                        device_group_href = re.sub(r'/ethernet/\d+/ipv6/\d+/pimV6Interface/\d+', '',
                                                                   pimv6_obj.href)
                                        device_multiplier = self.ixNetwork.Topology.find().DeviceGroup.read(
                                            device_group_href).Multiplier
                                        for index in mcast_destinations_index:
                                            multicastDestinations.append(
                                                {"arg1": pimv6_obj.PimV6JoinPruneList.href,
                                                 "arg2": ((index - 1) // device_multiplier),
                                                 "arg3": ((index - 1) % device_multiplier), "arg4": 0})
                    except:
                        pass
                if not kwargs.get('src_dest_mesh_type', '') == 'manyToMany':
                    for source in sourcesList:
                        for destination in multicastDestinations:
                            if source['arg1'] in destination['arg1']:
                                del multicastDestinations[multicastDestinations.index(destination)]
            if sourcesList == []:
                self.log.error('sourcesList are empty')
                raise IxiaConfigException('sourcesList are empty')

        if destinationsList:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if 'src_ports' in kwargs and 'dst_ports' in kwargs or \
                isinstance(sourcesList[0], str) and isinstance(destinations_list[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          Destinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            elif isinstance(destinations_list[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            elif isinstance(destinations_list[0], str) and isinstance(sourcesList[0], dict):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,
                                                                          Destinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
        if multicastDestinations:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if isinstance(multicastDestinations[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                          ScalableSources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
        if multicast_address:
            try:
                destinations_list = [dict(t) for t in {tuple(d.items()) for d in destinationsList}]
            except:
                destinations_list = destinationsList
            if isinstance(multicast_address[0], dict) and isinstance(sourcesList[0], str):
                stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None, Sources=sourcesList,
                                                                          ScalableDestinations=destinations_list,
                                                                          MulticastReceivers=multicastDestinations)
            else:
                if mcast_destinations_index == 'all':
                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                              ScalableSources=sourcesList,
                                                                              ScalableDestinations=destinations_list,
                                                                              MulticastDestinations=multicast_address)
                else:
                    stream_obj['endpoint_sets'] = trafficItem.EndpointSet.add(Name=None,
                                                                              ScalableSources=sourcesList,
                                                                              ScalableDestinations=destinations_list,
                                                                              MulticastReceivers=multicastDestinations)
        # self.log.info("Added Endpoints %s" % stream_obj['endpoint_sets'])
        self.log.info("Added Endpoints for Traffic stream - '%s'" % trafficItem.Name)
        configElement = trafficItem.ConfigElement.find()[0]

        if kwargs.get('vlan_id_start', None) or kwargs.get('vlan_id_count', None):
            ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
            vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
            if ethernetStack and not vlanStack:
                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                self._update_traffic_vlan_data(configElement, **kwargs)
            else:
                self._update_traffic_vlan_data(configElement, **kwargs)
        vlanEnable = True
        if kwargs.get('vlan_mod_dict', None):
            vlanList = kwargs.get('vlan_mod_dict', None)
            count = 0
            for key, value in vlanList.items():
                kwargs['vlan_id_start'] = key
                kwargs['stack_id'] = count
                for vlanParam, vlanValue in value.items():
                    kwargs[vlanParam] = vlanValue
                portName = kwargs.get('port_name', None)
                if self.ixNetwork.Topology.find():
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                            for ethernetObj in topology.DeviceGroup.find().Ethernet.find():
                                for value in ethernetObj.EnableVlans.Values:
                                    if value == "false":
                                        vlanEnable = False
                                if traffic_type == 'raw':
                                    vlanEnable = False
                            if count == 0:
                                if vlanEnable == False:
                                    ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                                    vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                                    configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                            else:
                                if vlanEnable == False:
                                    vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                                    vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                                    configElement.Stack.read(vlanStack.AppendProtocol(vlanTemplate))
                else:
                    if vlanEnable == True and count == 0:
                        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(vlanTemplate))
                    else:
                        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                        vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                        configElement.Stack.read(vlanStack.AppendProtocol(vlanTemplate))
                count = count + 1
                self._update_traffic_vlan_data(configElement, **kwargs)
            self.log.info("Added Ethernet/Vlan for Stream %s" % stream_obj['traffic'])

        if traffic_type == 'raw':
            if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',
                                                                                                None) is None or kwargs.get(
                'eth_dst_mac', None) is None:
                stream_obj['field'] = configElement.Stack.find().Field.find()
                if kwargs.get('eth_dst_mac_mode', None) == "INCR" or kwargs.get('eth_dst_mac_mode', None) is None:
                    kwargs['eth_dst_mac_mode'] = 'increment'
                field = configElement.Stack.find().Field.find(DisplayName="Destination MAC Address")
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'eth_dst_mac_mode', None), \
                                                                                                         kwargs.get(
                                                                                                             'eth_dst_mac',
                                                                                                             "00:00:00:00:01:01"), kwargs.get(
                    'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', "00:00:00:00:01:01"), kwargs.get(
                    'eth_dst_mac_step', "00:00:00:00:00:01")

                if kwargs.get('eth_src_mac_mode', None) == "INCR" or kwargs.get('eth_src_mac_mode', None) is None:
                    kwargs['eth_src_mac_mode'] = 'increment'
                field = configElement.Stack.find().Field.find(DisplayName="Source MAC Address")
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'eth_src_mac_mode', None), \
                                                                                                         kwargs.get(
                                                                                                             'eth_src_mac',
                                                                                                             "00:00:00:00:00:01"), kwargs.get(
                    'eth_src_mac_count', 1), kwargs.get('eth_src_mac', "00:00:00:00:00:01"), kwargs.get(
                    'eth_src_mac_step', "00:00:00:00:00:01")
            if kwargs.get('v4_src_addr', None):
                kwargs['v4_src_value'] = kwargs['v4_src_addr']
            if kwargs.get('v4_dst_addr', None):
                kwargs['v4_dst_value'] = kwargs['v4_dst_addr']
            if kwargs.get('v4_src_value', None) or kwargs.get('v4_src_count', None):
                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
                if ipv4Stack:
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv4_data(configElement, **kwargs)
                else:
                    if ethernetStack and vlanStack and not ipv4Stack:
                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                        configElement.Stack.read(vlanStack.AppendProtocol(ipv4Template))
                    if ethernetStack and not vlanStack and not ipv4Stack:
                        ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv4Template))
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv4_data(configElement, **kwargs)
            if kwargs.get('v6_src_addr', None):
                kwargs['v6_src_value'] = kwargs['v6_src_addr']
            if kwargs.get('v6_dst_addr', None):
                kwargs['v6_dst_value'] = kwargs['v6_dst_addr']
            if kwargs.get('v6_src_value', None) or kwargs.get('v6_src_count', None):
                ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
                vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
                ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
                if ipv6Stack:
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv6_data(configElement, **kwargs)
                else:
                    if ethernetStack and vlanStack and not ipv6Stack:
                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                        configElement.Stack.read(vlanStack.AppendProtocol(ipv6Template))
                    if ethernetStack and not vlanStack and not ipv6Stack:
                        ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                        configElement.Stack.read(ethernetStack.AppendProtocol(ipv6Template))
                    kwargs['stack_id'] = 0
                    self._update_traffic_ipv6_data(configElement, **kwargs)

            if kwargs.get('tcp_src_port', None) or kwargs.get('tcp_dst_port', None):
                ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
                tcpStack = configElement.Stack.find(StackTypeId='^tcp$')
                if tcpStack:
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Source-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', None), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_src_port',
                                                                                                                             None), kwargs.get(
                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', None), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_dst_port',
                                                                                                                             None), kwargs.get(
                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)

                else:
                    if ipv4Stack and not tcpStack:
                        tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^tcp$")
                        configElement.Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Source-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_src_auto', 'False'), kwargs.get('tcp_src_mode', None), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_src_port',
                                                                                                                             None), kwargs.get(
                        'tcp_src_count', 1), kwargs.get('tcp_src_port', None), kwargs.get('tcp_src_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'tcp_dst_auto', 'False'), kwargs.get('tcp_dst_mode', None), \
                                                                                                                         kwargs.get(
                                                                                                                             'tcp_dst_port',
                                                                                                                             None), kwargs.get(
                        'tcp_dst_count', 1), kwargs.get('tcp_dst_port', None), kwargs.get('tcp_dst_step', 1)
            if kwargs.get('mpls_label', None) or kwargs.get('mpls_exp', None) or kwargs.get('mpls_bos',None) or kwargs.get('mpls_ttl', None):
                ethernet_stack = configElement.Stack.find(StackTypeId='^ethernet$')
                ipv4_stack = configElement.Stack.find(StackTypeId='^ipv4$')
                mpls_stack = configElement.Stack.find(StackTypeId='^mpls$')
                if mpls_stack:
                    field = configElement.Stack.find().Field.find(DisplayName="Label Value")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'mpls_label_mode', None), kwargs.get('mpls_label', None), kwargs.get(
                    'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                    'mpls_exp_mode', None), kwargs.get('mpls_exp', None), kwargs.get(
                    'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Bottom of Stack Bit")[0]
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_bos_auto', True), kwargs.get(
                        'mpls_bos_mode', None), kwargs.get('mpls_bos', 1), kwargs.get(
                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Time To Live")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_ttl_mode', None), kwargs.get('mpls_ttl', None), kwargs.get(
                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)
                else:
                    mpls_template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^mpls$")
                    if ipv4_stack and not mpls_stack:
                        if kwargs.get('mpls_stack_top', True):
                            for _ in range(kwargs.get('mpls_count', 1)):
                                configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))
                        else:
                            for _ in range(kwargs.get('mpls_count', 1)):
                                configElement.Stack.read(ipv4_stack.AppendProtocol(mpls_template))
                    elif not ipv4_stack and not mpls_stack:
                        for _ in range(kwargs.get('mpls_count', 1)):
                            configElement.Stack.read(ethernet_stack.AppendProtocol(mpls_template))
                    field = configElement.Stack.find().Field.find(DisplayName="Label Value")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_label_mode', None), kwargs.get('mpls_label', None), kwargs.get(
                        'mpls_label_count', 1), kwargs.get('mpls_label', None), kwargs.get('mpls_label_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_exp_mode', None), kwargs.get('mpls_exp', None), kwargs.get(
                        'mpls_exp_count', 1), kwargs.get('mpls_exp', None), kwargs.get('mpls_exp_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Bottom of Stack Bit")[0]
                    field.Auto, field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_bos_auto', True), kwargs.get(
                        'mpls_bos_mode', None), kwargs.get('mpls_bos', 1), kwargs.get(
                        'mpls_bos_count', 1), kwargs.get('mpls_bos', 1), kwargs.get('mpls_bos_step', 1)
                    field = configElement.Stack.find().Field.find(DisplayName="Time To Live")[0]
                    field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                        'mpls_ttl_mode', None), kwargs.get('mpls_ttl', None), kwargs.get(
                        'mpls_ttl_count', 1), kwargs.get('mpls_ttl', None), kwargs.get('mpls_ttl_step', 1)

        frameRateDict = {'rate_type': 'Type', 'frame_rate': 'Rate', 'bit_rate_units': 'BitRateUnitsType',
                         'enforce_min_inter_packet_gap': 'InterPacketGapUnitsType'}
        frameRateOptions = list(set(frameRateDict.keys()).intersection(kwargs.keys()))
        if frameRateOptions:
            for key in kwargs:
                if key in frameRateDict:
                    setattr(configElement.FrameRate, frameRateDict[key], kwargs[key])

        frameSizeDict = {'frame_size_type': 'Type', 'frame_size_fixed_size': 'FixedSize',
                         'frame_size_increment_start': 'IncrementFrom', 'frame_size_increment_stop': 'IncrementTo',
                         'frame_size_increment_step': 'IncrementStep',
                         'frame_size_preset_distribution': 'PresetDistribution',
                         'frame_size_quad_gaussian': 'QuadGaussian',
                         'frame_size_random_min': 'RandomMin', 'frame_size_random_max': 'RandomMax',
                         'frame_size_weighted_pairs': 'WeightedPairs',
                         'frame_size_weighted_pairs_range': 'WeightedRangePairs'}
        frameSizeOptions = list(set(frameSizeDict.keys()).intersection(kwargs.keys()))
        if frameSizeOptions:
            for key in kwargs:
                if key in frameSizeDict:
                    setattr(configElement.FrameSize, frameSizeDict[key], kwargs[key])

        payLoadDict = {'payload_type': 'Type', 'payload_custom_pattern': 'CustomPattern',
                       'payload_custom_repeat': 'CustomRepeat'}
        payLoadOptions = list(set(payLoadDict.keys()).intersection(kwargs.keys()))
        if payLoadOptions:
            for key in kwargs:
                if key in payLoadDict:
                    setattr(configElement.FramePayload, payLoadDict[key], kwargs[key])

        rateDistributionDict = {'port_distribution': 'PortDistribution', 'stream_distribution': 'StreamDistribution'}
        rateDistributionOptions = list(set(rateDistributionDict.keys()).intersection(kwargs.keys()))
        if rateDistributionOptions:
            for key in kwargs:
                if key in rateDistributionDict:
                    setattr(configElement.FrameRateDistribution, rateDistributionDict[key], kwargs[key])

        if stats_track_by:
            stats_track_by.append('trackingenabled0')
        else:
            stats_track_by = ['trackingenabled0']
        self.change_traffic_flow_tracking(traffic_item_list=[trafficItem.Name], cfg_dict={'trackBy': stats_track_by})

        if 'ip_priority' in kwargs:
            ip_priority = kwargs['ip_priority']
            protocol = ip_priority["priority"]["protocol"]
            if protocol == "ipv4":
                del ip_priority["priority"]["protocol"]
                self.change_ipv4_tos(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority["priority"])
            if protocol == "ipv6":
                del ip_priority["priority"]["protocol"]
                self.change_ipv6_traffic_class(traffic_item_list=[trafficItem.Name], cfg_dict=ip_priority["priority"])
        if kwargs.get("v4_ttl", None):
            self.set_ipv4_traffic_ttl(traffic_item=trafficItem.Name, ttl=kwargs['v4_ttl'])
        if kwargs.get("v6_ttl", None):
            self.set_ipv6_traffic_hop_limit(traffic_item=trafficItem.Name, hop_limit=kwargs['v6_ttl'])

        return stream_obj

    def _set_route_count(self, pool_handle, routecount, prefix_ip=None, prefix_step_value=None):
        """
        Set Route count based on Protocol handle.

        :param pool_handle: PrefixPool Handle
        :param routecount: routecount to be updated
        :param prefix_ip: prefix_ip as reference
        :param prefix_step_value: prefix step to be updated
        :return:
        """
        if prefix_ip:
            if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:
                # This block for 9.0 version
                ip_prefix_index = (pool_handle.NetworkAddress.Values).index(prefix_ip)
                value_list = pool_handle.NumberOfAddressesAsy.Values
                value_list[ip_prefix_index] = routecount
                pool_handle.NumberOfAddressesAsy.ValueList(values=value_list)
            if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
                pool_handle.NumberOfAddresses = routecount
        else:
            if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:
                # This block for 9.0 version
                pool_handle.NumberOfAddressesAsy.Single(routecount)
            if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
                # This block for 8.50 version
                pool_handle.NumberOfAddresses = routecount
        if prefix_step_value:
            self._update_prefix_step(prefix_step_value, pool_handle)

    def _modify_route_count(self, network_group, route_count, ports, ip_type, start_ip_prefix, protocol, prefix,
                            router_id,prefix_step, **kwargs):
        """
        Modifying address count for protocols. Internal API to support setting route count APIs

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param protocol: protocol
        :param prefix: prefix
        :param router_id: router ID
        :param prefix_step: prefix step
        :return: result
        """
        protocol_status = False
        deviceGroupName = None
        if (network_group and start_ip_prefix and prefix and router_id) or (
                network_group and start_ip_prefix and router_id) or (
                network_group is None and start_ip_prefix and router_id):
            networkGroupNameList = []
            if "." in router_id and protocol.lower() != 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if "." not in router_id and protocol.lower() == 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.Name == router_id:
                        deviceGroupName = router_id
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            else:
                try:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group:
                            if network_group in networkGroup.Name:
                                networkGroupNameList.append(networkGroup.Name)
                                break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    if prefix:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values and prefix in networkGroupObj.PrefixLength.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    else:
                                        if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                            protocol_status = True
                                            self._set_route_count(networkGroupObj, route_count,
                                                                  prefix_ip=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if (network_group and start_ip_prefix is None and ports is None and prefix is None and router_id) or (
                network_group is None and start_ip_prefix is None and prefix is None and router_id):
            if "." in router_id:
                if protocol == "ISIS":
                    raise IxiaConfigException(
                        "ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')")
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + deviceGroupName + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]
            else:
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + router_id + '$').NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    networkObj.Enabled.Single(True)
                                    protocol_status = True
                                    self._set_route_count(networkGroupObj, route_count)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if network_group and ports is None and start_ip_prefix is None and router_id is None:
            networkGroupNameList = []
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                for networkGroupObj in deviceGroupObj.NetworkGroup.find():
                    if network_group in networkGroupObj.Name:
                        networkGroupNameList.append(networkGroupObj.Name)
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + networkGroupName + '$'):
                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv4PoolObj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv4PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                if protocol == "OSPF":
                                    if ipv4PoolObj.OspfRouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv4PoolObj, route_count)
                    else:
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + networkGroupName + '$'):
                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv6PoolObj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv6PoolObj, route_count, prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                if protocol == "OSPF":
                                    if ipv6PoolObj.Ospfv3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        self._set_route_count(ipv6PoolObj, route_count)
            else:
                raise IxiaConfigException(
                    "Network group name '%s' not found for Ip version '%s'" % (network_group, ip_type))
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            for port in ports:
                if port in vportNameList:
                    for topologyObj in self.ixNetwork.Topology.find():
                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                            if ip_type.lower() == "ipv4":
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv4PoolObj.IsisL3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv4PoolObj, route_count,
                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if protocol == "OSPF":
                                            if ipv4PoolObj.OspfRouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv4PoolObj, route_count)
                            else:
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv6PoolObj.IsisL3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv6PoolObj, route_count,
                                                                      prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if protocol == "OSPF":
                                            if ipv6PoolObj.Ospfv3RouteProperty.find():
                                                networkObj.Enabled.Single(True)
                                                protocol_status = True
                                                self._set_route_count(ipv6PoolObj, route_count)
        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (
                start_ip_prefix and network_group and ports is None and router_id is None):
            networkGroupNameList = []
            if network_group and start_ip_prefix:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if
                                        network_group in networkObj.Name]
                # This condition for compact version
                if networkGroupNameList == []:
                    networkGroupNameList = [networkObj.Name for networkObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if start_ip_prefix and network_group is None:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.OspfRouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
                    else:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count,
                                                                  prefix_ip=start_ip_prefix, prefix_step_value=prefix_step)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.Ospfv3RouteProperty.find():
                                        networkObj.Enabled.Single(True)
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            self._set_route_count(network_group_obj, route_count, prefix_ip=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)
        if protocol_status:
            return protocol_status
        else:
            raise IxiaConfigException("%s protocol not configured or Configuration issue." % protocol)

    def _ospf_routes_control(self, ports, ip_type, address_list, action, active, devices):
        """
        Function used internally by API ospf_routes_start & ospf_routes_stop

        :param ports: ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: Start/Stop
        :param active: Active/ Deactive
        :param devices: Name of the devices in the config

        :return: True on success and raise exception if any failures
        """
        self.log.info('OSPF Routes Control:%s' % (action) )
        if ports==None and address_list==None and devices==None:
            if ip_type.lower() == "ipv4":
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find(Name=name).Active.Single(active)
            else:
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find(Name=name).Active.Single(active)
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for ospfRoute in ipv4Pools.OspfRouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):
                                        eval('ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')
                                        ipv4Pools.OspfRouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)
                        else:
                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                for ospfRoute in ipv6Pools.Ospfv3RouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ospfRoute.href):
                                        eval('ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).'+action+'(None)')
                                        ipv6Pools.Ospfv3RouteProperty.find(DescriptiveName=ospfRoute.DescriptiveName).Active.Single(active)
        if address_list:
            for lastaddress in address_list:
                if ':' not in lastaddress:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).OspfRouteProperty.find().Active.Single(active)
                else:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).Ospfv3RouteProperty.find().Active.Single(active)
        if devices:
            for eachDevice in devices:
                eachDevice = '^' + eachDevice.replace('+', '\+').replace('*', '\*') + '$'
                if ip_type.lower() == "ipv4":
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().Active.Single(
                        active)
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").NetworkGroup.find().Ipv4PrefixPools.find().OspfRouteProperty.find().' + action + '(None)')
                else:
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().Active.Single(
                        active)
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").NetworkGroup.find().Ipv6PrefixPools.find().Ospfv3RouteProperty.find().' + action + '(None)')
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def ospf_routes_start(self, ports=None, ip_type="ipv4", address_list=None, devices=None):
        """
        Start OSPF route ranges

        :param ports: list of port names e.g. ["Ethernet - 001"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for OSPF in TGN
        :param devices: Name of the devices in the config
        :return: True on success else raises exception

        :Example: ospf_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
                  ospf_routes_start(devices=["Device1"], ip_type="ipv6")
        """
        return self._ospf_routes_control(ports, ip_type, address_list, "Start", "true", devices)

    def ospf_routes_stop(self, ports=None, ip_type="ipv4", address_list=None, devices=None):
        """
        Stopping OSPF route ranges

        :param ports: list of port names e.g. ["Ethernet - 001"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: The list of network addresses in the route range defined for OSPF in TGN. In Spirent, the first address should be included per network range.
                In IXIA, the last address should be included.
        :param devices: Name of the devices in the config
        :return: True on success else raises exception

        :Example: ospf_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
                  ospf_routes_stop(devices=["Device1"], ip_type="ipv6")
        """
        return self._ospf_routes_control(ports, ip_type, address_list, "Stop", "false", devices)

    def set_ospf_route_count(self, route_count,router_id, ip_type="ipv4", lsa_id=None, start_ip_prefix=None, **kwargs):
        """
        Modifying address count for OSPF protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param router_id: Represents the Router ID of the router.
        :param lsa_id: NA for IXIA
        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional
        :return: True if the operation is successful, False otherwise

        :Example: set_ospf_route_count(route_count=300, network_group='Network Group 2', ports=["Ethernet - 001"])
        """
        self.log.info("Setting OSPF Route Count")
        network_group = kwargs.get('network_group')
        ports = kwargs.get('ports')
        prefix_step = kwargs.get('prefix_step')
        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix, protocol="OSPF",
                                        prefix=None, router_id=router_id, prefix_step=prefix_step)

    def _ldp_routes_control(self, ports, ip_type, address_list, action, active):
        """
        Function used internally by API ldp_routes_start & ldp_routes_stop

        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param address_list: address_list: list of last network address in the route range defined for LDP in TGN
        :param action: start/stop
        :param active: active/deactive
        :return: True/Exception
        """
        self.log.info('LDP Route Control:%s' % (action))
        if ports == None and  address_list== None:
            if ip_type.lower() == "ipv4":
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find().LdpFECProperty.find(Name=name).Active.Single(active)
            else:
                nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find() if name]
                for name in nameList:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).'+action+'(None)')
                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find().LdpIpv6FECProperty.find(Name=name).Active.Single(active)

        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                             for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for ldpRoute in ipv4Pools.LdpFECProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):
                                        eval('ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')
                                        ipv4Pools.LdpFECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)
                        else:
                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                for ldpRoute in ipv6Pools.LdpIpv6FECProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', ldpRoute.href):
                                        eval('ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).'+action+'(None)')
                                        ipv6Pools.LdpIpv6FECProperty.find(DescriptiveName=ldpRoute.DescriptiveName).Active.Single(active)
        if address_list:
            for lastaddress in address_list:
                if ':' not in lastaddress:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).LdpFECProperty.find().Active.Single(active)
                else:
                    nameList = [name.Name for name in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find() if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LastNetworkAddress
                        if lastaddress in address:
                            ipIndex = address.index(lastaddress) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().'+action+'(ipIndex)')
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).LdpIpv6FECProperty.find().Active.Single(active)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True


    def ldp_routes_start(self, ports=None, ip_type="ipv4", address_list=None):
        """
        Starting LDP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for LDP in TGN
        :return: True on success else raises exception

        :Example: ldp_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
        """

        return self._ldp_routes_control(ports, ip_type, address_list, "Start", "true")

    def ldp_routes_stop(self, ports=None, ip_type="ipv4", address_list=None):
        """
        Starting LDP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of last network address in the route range defined for LDP in TGN
        :return: True on success else raises exception

        :Example: ldp_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
        """

        return self._ldp_routes_control(ports, ip_type, address_list, "Stop", "false")

    def _bgp_routes_control(self, ports, ip_type, address_list, action, active, devices, nested_nework_group):
        """
        Function used internally by API bgp_routes_start & bgp_routes_stop

        :param ports: list of ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: Start/Stop
        :param active: Active/ Deactive
        :param devices: list of Names of the devices in the config
        :param nested_nework_group: Nested network group name
        """
        self.log.info('BGP Routes Control:%s' % (action))
        if ports == None and address_list == None and devices == None:
            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    try:
                        group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
                else:
                    try:
                        group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
                    try:
                        group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                    except:
                        pass
        if (ports and devices == None and address_list == None):
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in ports if portName in vportNameList]
            for portName in portNameList:
                portName = '^' + portName.replace('/', '\/').replace('(', '\(').replace(')', '\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        if ip_type.lower() == "ipv4":
                            if nested_nework_group:
                                try:
                                    for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                        for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                                eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')
                                                ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)
                                except:
                                    pass
                            for ipv4Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for bgpRoute in ipv4Pools.BgpIPRouteProperty.find():
                                    if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                        eval( 'ipv4Pools.BgpIPRouteProperty.find(DescriptiveName=bgpRoute.DescriptiveName).' + action + '(None)')
                                        ipv4Pools.BgpIPRouteProperty.find( DescriptiveName=bgpRoute.DescriptiveName).Active.Single(active)
                        else:
                            if nested_nework_group:
                                try:
                                    for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                        for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():
                                            if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                                Name = '^' + bgpRoute.DescriptiveName.replace('+', '\+').replace('*', '\*') + '$'
                                                eval( 'ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')
                                                ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).Active.Single(active)
                                except:
                                    pass
                            for ipv6Pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                try:
                                    for bgpRoute in ipv6Pools.BgpV6IPRouteProperty.find():
                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', '\+').replace('*','\*') + '$'
                                            eval('ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')
                                            ipv6Pools.BgpV6IPRouteProperty.find(DescriptiveName=Name).Active.Single(active)
                                except:
                                    pass
                                try:
                                    for bgpRoute in ipv6Pools.BgpIPRouteProperty.find():
                                        if re.match(topologyObj + '/deviceGroup', bgpRoute.href):
                                            Name = '^' + bgpRoute.DescriptiveName.replace('+', '\+').replace('*','\*') + '$'
                                            eval( 'ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).' + action + '(None)')
                                            ipv6Pools.BgpIPRouteProperty.find(DescriptiveName=Name).Active.Single(active)
                                except:
                                    pass
        if (devices and ports and address_list) or (devices == None and ports and address_list) or (
                devices and ports == None and address_list) or (devices == None and ports == None and address_list):
            for startaddress in address_list:
                if ':' not in startaddress:
                    nameList = [name.Name for name in
                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()
                                if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(
                            Name='^' + name + '$').NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass
                else:
                    nameList = [name.Name for name in
                                self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()
                                if name]
                    for name in nameList:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpIPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpIPRouteProperty.find().Active
                                bgpIpv6Obj.ClearOverlays()
                                bgpIpv6Obj.ValueList(values=valuesList)
                            except:
                                pass

                            try:
                                eval( 'self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name=name).BgpV6IPRouteProperty.find().' + action + '(ipIndex)')
                                valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find( Name='^' + name + '$').BgpV6IPRouteProperty.find().Active.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpv6Obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find(Name='^' + name + '$').BgpV6IPRouteProperty.find().Active
                                bgpIpv6Obj.ClearOverlays()
                                bgpIpv6Obj.ValueList(values=valuesList)

                            except:
                                pass
        if (devices and ports == None and address_list == None) or (devices and ports and address_list == None):
            for eachDevice in devices:
                eachDevice = '^' + eachDevice.replace('+', '\+').replace('*', '\*') + '$'
                for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice).NetworkGroup.find():
                    if ip_type.lower() == "ipv4":
                        try:
                            group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        # for nested network groups
                        try:
                            group.DeviceGroup.find( Name=eachDevice).NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv4PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                    else:
                        try:
                            group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        # for nested network groups
                        try:
                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            group.DeviceGroup.find(Name=eachDevice).NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv6PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv6PrefixPools.find().BgpIPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
                        try:
                            device_obj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=eachDevice)
                            device_obj.DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(Name='^' + nested_nework_group + '$').\
                                Ipv6PrefixPools.find().BgpV6IPRouteProperty.find().Active.Single(active)
                            eval('group.Ipv4PrefixPools.find().BgpIPRouteProperty.find().' + action + '(None)')
                        except:
                            pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def bgp_routes_start(self, ports=None, ip_type="ipv4", address_list=None, devices=None, **kwargs):
        """
        Start BGP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of start network address of network group
        :param devices: list of Names of the devices in the config
        :param nested_nework_group : True if nested network group
        :return: True on success else raises exception

        :Example: bgp_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
                  bgp_routes_start(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])
                  bgp_routes_start(devices=['Device 1'],ip_type='ipv6',address_list = ['1000::1','2000::1'])
        """
        nested_nework_group = kwargs.get('nested_nework_group',None)
        action = kwargs.get("action", "Start")
        return self._bgp_routes_control(ports, ip_type, address_list, action, "true", devices, nested_nework_group)

    def bgp_routes_stop(self, ports=None, ip_type="ipv4", address_list=None, devices=None, **kwargs):
        """
        Stop BGP route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param address_list: list of start network addresses of network group
        :param devices: list of Names of the devices in the config
        :param nested_nework_group : True if nested network group
        :return: True on success else raises exception

        :Example: bgp_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
                  bgp_routes_stop(ports=['Ethernet - 001'],address_list = ['10.1.1.1','20.1.1.1'])
                  bgp_routes_stop(devices=['Device 1'],ip_type='ipv6',address_list = ['1000::1','2000::1'])
        """
        nested_nework_group = kwargs.get('nested_nework_group')
        return self._bgp_routes_control(ports, ip_type, address_list, "Stop", "false", devices, nested_nework_group)

    def _isis_routes_control(self, ports: List[str], ip_type: str, address_list: List[str], devices: List[str], network_group: str,
                             action: str = 'Start', active: str = 'true'):
        """
        Function used internally by API isis_routes_start & isis_routes_stop

        :param ports: list of ports
        :param ip_type: ipv4 or ipv6
        :param address_list: Address list for action start/stop
        :param action: takes 'true' to start or 'false' to stop
        :param active: takes 'Start' or 'Stop'
        :param devices: list of Names of the devices in the config
        :param network_group: ISIS network group name
        """
        self.log.info(f"ISIS Routes Control {action}")
        result = False
        if ports is None and address_list is None and devices is None and network_group is None:
            for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    try:
                        group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                        eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        result = True
                    except:
                        pass
                elif ip_type.lower() == "ipv6":
                    try:
                        group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                        eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        result = True
                    except:
                        pass
            if not result:
                raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')

        if (ports and devices is None and address_list is None and network_group is None):
            vport_name_list = [vport.Name for vport in self.ixNetwork.Vport.find()]
            port_name_list = [port_name for port_name in ports if port_name in vport_name_list]
            for port_name in port_name_list:
                port_name = '^' + port_name.replace('/', '\/').replace('(', '\(').replace(')', '\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port_name).href:
                        topology_obj = topology.href
                        if ip_type.lower() == "ipv4":
                            for ipv4_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find():
                                for isis_route in ipv4_pools.IsisL3RouteProperty.find():
                                    try:
                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):
                                            name = '^' + isis_route.DescriptiveName.replace('+', '\+').replace('*','\*') + '$'
                                            eval('ipv4_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')
                                            ipv4_pools.IsisL3RouteProperty.find( DescriptiveName=isis_route.DescriptiveName).Active.Single(active)
                                    except:
                                        raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')
                        else:
                            for ipv6_pools in topology.DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find():
                                try:
                                    for isis_route in ipv6_pools.IsisL3RouteProperty.find():
                                        if re.match(topology_obj + '/deviceGroup', isis_route.href):
                                            name = '^' + isis_route.DescriptiveName.replace('+', '\+').replace('*','\*') + '$'
                                            eval('ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).' + action + '(None)')
                                            ipv6_pools.IsisL3RouteProperty.find(DescriptiveName=name).Active.Single(active)
                                except:
                                    raise CafyException.TgenInvalidInputError('invalid ip type. Allowed values are ipv4/ipv6')

        if address_list and (devices or ports or network_group):
            for lastaddress in address_list:
                namelist = list()
                if ':' not in lastaddress:
                    if devices:
                        for device in devices:
                            if network_group:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()
                                                 if name])
                            else:
                                namelist.extend([name.Name for name in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').
                                                NetworkGroup.find().Ipv4PrefixPools.find()
                                            if name])

                    elif devices is None and network_group:
                        namelist.extend([name.Name for name in
                                    self.ixNetwork.Topology.find().DeviceGroup.find().
                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv4PrefixPools.find()
                                    if name])
                    else:
                        namelist.extend([name.Name for name in
                                    self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv4PrefixPools.find()
                                    if name])

                    for name in namelist:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find(). \
                            NetworkGroup.find().Ipv4PrefixPools.find(
                            Name='^' + name + '$').LastNetworkAddress
                        if lastaddress in address:
                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]
                            for index in ip_index_list:
                                try:
                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'
                                         'Ipv4PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')
                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv4PrefixPools.find(
                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values
                                    valueslist[index] = active.lower()
                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv4PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active
                                    isis_obj.ClearOverlays()
                                    isis_obj.ValueList(values=valueslist)
                                except:
                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv4')

                else:
                    if devices:
                        for device in devices:
                            if network_group:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()
                                                 if name])
                            else:
                                namelist.extend([name.Name for name in
                                                 self.ixNetwork.Topology.find().DeviceGroup.find(
                                                     Name='^' + device + '$').
                                                NetworkGroup.find().Ipv6PrefixPools.find()
                                                 if name])

                    elif devices is None and network_group:
                        namelist.extend([name.Name for name in
                                         self.ixNetwork.Topology.find().DeviceGroup.find().
                                        NetworkGroup.find(Name='^' + network_group + '$').Ipv6PrefixPools.find()
                                         if name])
                    else:
                        namelist.extend([name.Name for name in
                                         self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().Ipv6PrefixPools.find()
                                         if name])
                    for name in namelist:
                        address = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                            Ipv6PrefixPools.find(Name='^' + name + '$').LastNetworkAddress
                        if lastaddress in address:
                            ip_index_list = [i for i, val in enumerate(address) if val in address_list]
                            for index in ip_index_list:
                                try:
                                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().'
                                         'Ipv6PrefixPools.find(Name=name).IsisL3RouteProperty.find().' + action + '(index)')
                                    valueslist = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv6PrefixPools.find(
                                        Name='^' + name + '$').IsisL3RouteProperty.find().Active.Values
                                    valueslist[index] = active.lower()
                                    isis_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                                        Ipv6PrefixPools.find(Name='^' + name + '$').IsisL3RouteProperty.find().Active
                                    isis_obj.ClearOverlays()
                                    isis_obj.ValueList(values=valueslist)
                                except:
                                    raise IxiaConfigException('exiting due to failure in isis configuration for ipv6')

        if devices and address_list is None and (ports or network_group):
            for each_device in devices:
                each_device = '^' + each_device.replace('+', '\+').replace('*', '\*') + '$'
                if network_group:
                    for group in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$'):
                        try:
                            if ip_type.lower() == "ipv4":
                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                            else:
                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        except Exception as err_msg:
                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)
                else:
                    for group in self.ixNetwork.Topology.find().DeviceGroup.find(Name=each_device).NetworkGroup.find():
                        try:
                            if ip_type.lower() == "ipv4":
                                group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                            else:
                                group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                                eval('group.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                        except Exception as err_msg:
                            raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)

        if devices is None and ports is None and address_list is None and network_group:
            try:
                network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name = '^' + network_group + '$')
                if ip_type.lower() == "ipv4":
                    network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                    eval('network_group_obj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
                else:
                    network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().Active.Single(active)
                    eval('network_group_obj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().' + action + '(None)')
            except Exception as err_msg:
                raise CafyException.TgenInvalidInputError('exiting due to error', err_msg)

        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def isis_routes_start(self, ports: Optional[List[str]] = None,  address_list: Optional[List[str]] = None,
                          devices: Optional[List[str]] = None, ip_type: str = 'ipv4',**kwargs):
        """
        Starting ISIS route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.
        :param devices: list of Names of the devices in the config
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param kwargs :
            network_group : ISIS network group name
        :return: True on success else raises exception

        :Example: isis_routes_start(ports=["Ethernet - 001"], ip_type="ipv6")
        """
        network_group = kwargs.get('network_group',None)
        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, "Start", "true")

    def isis_routes_stop(self, ports: Optional[List[str]] = None, address_list: Optional[List[str]] = None,
                         devices: Optional[List[str]] = None, ip_type: str = 'ipv4', **kwargs):
        """
        Stopping ISIS route ranges

        :param ports: list of port names e.g. ["egress1"]
        :param address_list: The list of network addresses in the route range defined for ISIS in TGN. In Spirent, the first address should be included per network range. In IXIA, the last address should be included.
        :param devices: list of Names of the devices in the config
        :param ip_type: IP version. The value defaults to ipv4 if the parameter is not present
        :param kwargs :
            network_group : ISIS network group name
        :return: True on success else raises exception

        :Example: isis_routes_stop(ports=["Ethernet - 001"], ip_type="ipv6")
        """
        network_group = kwargs.get('network_group',None)
        return self._isis_routes_control(ports, ip_type, address_list, devices, network_group, "Stop", "false")

    def set_isis_route_count(self, route_count, router_id=None, ip_type="ipv4", lsp_id=None, start_ip_prefix=None, **kwargs):
        """
        Modifying address count for ISIS protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param router_id: NA for IXIA
        :param lsp_id: NA for IXIA
        :param start_ip_prefix: It's optional value represents the start_ip_prefix of the route.
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, network_group has to be included in the kwargs as a
                       mandatory parameter and ports is optional
                       network_group: ISIS network group name
                       ports:  port name
                       prefix_step:  prefix step to be updated
        :return: True if the operation is successful, False otherwise

        :Example: set_isis_route_count(route_count=300,router_id=None, network_group='Network Group 8')
        """
        self.log.info("Setting ISIS route count")
        network_group = kwargs.get('network_group')
        ports = kwargs.get('ports')
        prefix_step = kwargs.get('prefix_step')
        if router_id:
            if "." in router_id:
                router_id = None
        if not network_group and start_ip_prefix is None and router_id is None and ports is None:
            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')
        return self._modify_route_count(network_group, route_count, ports, ip_type, start_ip_prefix,
                                        prefix_step=prefix_step,protocol="ISIS", prefix=None, router_id=router_id)

    def get_port_mtu(self, port):
        """
        Get MTU value for Ether PORT

        :param port: portName, Location or Interface of PORT\n
            Example: portName: (str): The virtual port name. Ex: '1/2/9'\n
            Example: port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)] , Ex: ['10.34.57.60', '2', '9']\n
            Example: location (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'
        :return: A list of one or more (if sub-interface exists) MTU values for a given port

        :Example: get_port_mtu("10.39.60.120/2/9")
        """
        self.log.info("Getting MTU on the port:%s" % (port))
        if type(port) == list:
            port = ':'.join(port)
        elif type(port) == str and re.search('\d+.\d+.\d+.\d+/\\d+/\\d+', port):
            port = port.replace('/', ':')
        else:
            port = self.ixNetwork.Vport.find(Name=port).AssignedTo

        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
            for vport in vportList:
                assignedVport = self.ixNetwork.Vport.find(Name=vport)
                if assignedVport.AssignedTo == port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == assignedVport.href:
                            topologyObj = topology.href
                            for deviceGroup in topology.DeviceGroup.find():
                                mtuValues = []
                                for ethernet in deviceGroup.Ethernet.find():
                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                        mtuValues.append(ethernet.Mtu.Values)
                                return [mtu for mtuSubList in mtuValues for mtu in mtuSubList]
        else:
            raise IxiaConfigException("Port %s is invalid or not configured" % port)

    def set_port_mtu(self, port, mtu, **kwargs):
        """
        Change MTU value in port Ethernet configuration

        :param port: portName, Location or Interface of PORT\n
            Example:
               portName: (str): The virtual port name. Ex: '1/2/9' \n
               port: (list): Format: [ixChassisIp, str(cardNumber), str(portNumber)], Ex: ['10.34.57.60', '2', '9']\n
               location: (str): Format: 'ixChassisIp/cardNumber/portNumber', Ex: '10.34.57.60/2/9'
        :param mtu: (int): User preferred MTU value for Ethernet PORT. (RANGE 68 - 9216)
        :kwargs_param direction: (str): increment|decrement MTU value.
        :kwargs_param step: (int): Number of steps to increment/decrement MTU value, default is 0
        :return: True on success

        :Example: set_port_mtu(portList[0],1300,direction='increment',step=2)
        """
        self.log.info("Setting MTU on the port:%s" % (port))
        step = kwargs.get('step', 0)
        if type(port) == list:
            port = ':'.join(port)
        elif type(port) == str and re.search('\d+.\d+.\d+.\d+/\\d+/\\d+', port):
            port = port.replace('/', ':')
        else:
            port = self.ixNetwork.Vport.find(Name=port).AssignedTo

        vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
        if port in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
            for vport in vportList:
                vports = self.ixNetwork.Vport.find(Name=vport)
                if vports.AssignedTo == port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == vports.href:
                            topologyObj = topology.href
                            for deviceGroup in topology.DeviceGroup.find():
                                for ethernet in deviceGroup.Ethernet.find():
                                    if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                        if kwargs:
                                            if kwargs['direction'].lower() == 'increment':
                                                ethernet.Mtu.Increment(start_value=mtu, step_value=step)
                                            if kwargs['direction'].lower() == 'decrement':
                                                ethernet.Mtu.Decrement(start_value=mtu, step_value=step)
                                        else:
                                            ethernet.Mtu.Single(mtu)
            time.sleep(2)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("Port %s is invalid or not configured" % port)
        return True

    def get_all_traffic_streams(self, getEnabledTrafficItemsOnly=True):
        """
        Retrieves all traffic items for a given session

        :param getEnabledTrafficItemsOnly: (bool): Retrieve the traffic items which are enabled|disabled.
                                                    Valid values True or False, default is False.
        :return: List of one or more traffic item objects in configuration

        :Example: get_all_traffic_streams(getEnabledTrafficItemsOnly=True)
        """
        self.log.info("Available traffic streams")
        trafficStreams = [trafficItem for trafficItem in self.ixNetwork.Traffic.TrafficItem.find() if trafficItem.Enabled == getEnabledTrafficItemsOnly]
        return trafficStreams
    


    def _modify_ipv4_ipv6_address(self,ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed):
        """
        This function is used internally

        :param ip_config: (str|list): Config IP address value(single/list).
        :param pattern:(str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter
        :param ipObj: IP Object to modify the parameters
        :param gateway_config: (str): Config with gateway address, count, step, seed
        :param maximum: Maximum IPv4/IPv6 addresses
        :param step: (str): Increment step value if needed
        :param gw_step: (str): Increment gateway step value if needed
        :param direction: (str): Counter direction increment|decrement.
        :param ngpfEndpoint: IXIA NGPF Endpoints
        :param mask: IPv4/IPv6 address Mask
        :param count: IPv4/IPv6 address count
        :param seed: IPv4/IPv6 seed values
        """
        if ngpfEndpoint == "ipv4":
            if type(ip_config) == list:
                ipObj.Address.ValueList(values=ip_config)
            elif pattern == 'random':
                ipObj.Address.Random()
                if gateway_config:
                    ipObj.GatewayIp.Random()
            elif pattern == 'repeatableRandomRange':
                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)
                if gateway_config:
                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)
            elif pattern == 'repeatableRandom':
                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)
                if gateway_config:
                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)
            elif pattern == 'custom':
                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)
                if gateway_config:
                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)
            else:
                
                if direction.lower() == "increment":
                    ipObj.Address.Increment(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)
                else:
                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            self.log.info("Device IP Address configured successfully")
            return True
        if ngpfEndpoint == "ipv6":
            if type(ip_config) == list:
                ipObj.Address.ValueList(values=ip_config)
            elif pattern == 'random':
                ipObj.Address.Random()
                if gateway_config:
                    ipObj.GatewayIp.Random()
            elif pattern == 'repeatableRandomRange':
                ipObj.Address.RandomRange(min_value=ip_config, max_value=maximum, step_value=step, seed=seed)
                if gateway_config:
                    ipObj.GatewayIp.RandomRange(min_value=gateway_config, max_value=maximum, step_value=gw_step, seed=seed)
            elif pattern == 'repeatableRandom':
                ipObj.Address.RandomMask(fixed_value=ip_config, mask_value=mask, seed=seed, count=count)
                if gateway_config:
                    ipObj.GatewayIp.RandomMask(fixed_value=gateway_config, mask_value=mask, seed=seed, count=count)
            elif pattern == 'custom':
                ipObj.Address.Custom(start_value=ip_config, step_value=step, increments=None)
                if gateway_config:
                    ipObj.GatewayIp.Custom(start_value=gateway_config, step_value=gw_step, increments=None)
            else:
                if direction.lower() == "increment":
                    ipObj.Address.Increment(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Increment(start_value=gateway_config, step_value=gw_step)
                else:
                    ipObj.Address.Decrement(start_value=ip_config, step_value=step)
                    if gateway_config:
                        ipObj.GatewayIp.Decrement(start_value=gateway_config, step_value=gw_step)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            self.log.info("Device IP Address configured successfully")
            return True

    def set_device_ip_address(self, router_id, address_family, ip_config, gateway_config=None, advanced_config=None, **kwargs):
        """
        Modifies IP address configuration for requested routerId and address family if provided

        :param router_id: (str): The router ID IP address.
        :param address_family: (str) The IP address belongs to IPv4|IPv6
        :param ip_config: (str|list): Config IP address value(single/list).
        :param gateway_config: (str): Config with gateway address, count, step, seed
        :param advanced_config: stack count, repeat, recycle count in Modifier
        :param kwargs:
               pattern: (str): IP address pattern ('counter|random|repeatableRandom|repeatableRandomRange|custom'), default is counter \n
               direction: (str): Counter direction increment|decrement. \n
               step: (str): Increment step value if needed \n
               gw_step: (str): Increment gateway step value if needed \n
               prefix: (int): Prefix for IPv4|IPv6 (24 or 64) \n
               resolveGateway: (bool): Resolve gateway True|False, default is True. \n
               multiplier: (int): Increment Multiplier value if needed
        :return: True on success

        :Example: set_device_ip_address(router_id ='192.0.0.1', address_family='IPv4', ip_config='120.1.1.1', gateway_config='120.1.1.2', name="ipv4", step='0.0.1.0')
        """
        self.log.info("Setting Device IP Address")
        pattern = kwargs.get('pattern','counter')
        if address_family.lower() == 'ipv4':
            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')
            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)
            gw_step = kwargs.get('gw_step', None)
            count, seed = kwargs.get('count', None), kwargs.get('seed', None)
            ngpfEndpoint = 'ipv4'

        if address_family.lower() == 'ipv6':
            step, direction = kwargs.get('step', None), kwargs.get('direction','increment')
            maximum, mask = kwargs.get('maximum', None), kwargs.get('mask', None)
            gw_step = kwargs.get('gw_step', None)
            count, seed = kwargs.get('count', None), kwargs.get('seed', None)
            ngpfEndpoint = 'ipv6'
        protocols = ['Ospfv3', 'BgpIpv4Peer', 'LdpConnectedInterface', 'Ospfv2', 'BgpIpv6Peer','Ldpv6ConnectedInterface']
        if ngpfEndpoint == 'ipv4':
            for protocol in protocols:
                try:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().'+ protocol +'.find()'):
                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction,ngpfEndpoint, mask, count, seed)
                except:
                    pass
        if ngpfEndpoint == 'ipv6':
            for protocol in protocols:
                try:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().'+ protocol +'.find()'):
                        for ipObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                            if router_id in eval('ipObj.'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ipv4_ipv6_address(ip_config, pattern, ipObj, gateway_config, maximum, step, gw_step, direction, ngpfEndpoint, mask, count, seed)
                except:
                    pass

        return True


    def _modify_ethernet_address(self, value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj):
        """
        Modify Ethernet mac address

        :param router_id: (str): The router ID IP address.
        :param value: (str): Mac address for requested router ID.
        :param value_mode: (str): Mac address pattern.
        :param step: (str): Increment step value if needed
        :param repeat_count: (int): Number of times to be repeated
        :param seed: (int): Random see value for Source MAC address
        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier
        :param direction: (str): Counter direction increment|decrement.
        :param maximum: (str): Max value for repeatableRandomRange
        :param mask: (str): Mask for repeatableRandom
        :param ethernetObj: Ethernet Object on which address to be modified
        :return:True
        """
        if type(value) == list:
            ethernetObj.Mac.ValueList(values=value)
        elif value_mode == 'random':
            ethernetObj.Mac.Random()
        elif value_mode == 'repeatableRandomRange':
            ethernetObj.Mac.RandomRange(min_value=value, max_value=maximum, step_value=step, seed=seed)
        elif value_mode == 'repeatableRandom':
            ethernetObj.Mac.RandomMask(fixed_value=value, mask_value=mask, seed=seed, count=repeat_count)
        elif value_mode == 'custom':
            ethernetObj.Mac.Custom(start_value=value, step_value=step, increments=None)
        else:
            if direction.lower() == "increment":
                ethernetObj.Mac.Increment(start_value=value, step_value=step)
            else:
                ethernetObj.Mac.Decrement(start_value=value, step_value=step)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Device MAC Address set successfully")
        return True

    def set_device_mac_address(self, router_id, value_mode='counter', value='', step='00:00:00:00:00:01',repeat_count='0', seed=1, advanced_config=None, **kwargs):
        """
        Modifies mac address configuration for requested routerId if provided

        :param router_id: (str): The router ID IP address.
        :param value: (str): Mac address for requested router ID.
        :param value_mode: (str): Mac address pattern.
        :param step: (str): Increment step value if needed
        :param repeat_count: (int): Number of times to be repeated
        :param seed: (int): Random see value for Source MAC address
        :param advanced_config: Advance config(stack count, repeat, recycle count) in Modifier
        :param kwargs:
               direction: (str): Counter direction increment|decrement. \n
               maximum: (str): Max value for repeatableRandomRange \n
               mask: (str): Mask for repeatableRandom
        :return: True on Success

        :Example: set_device_mac_address(router_id='194.0.0.1', value='00:16:01:00:00:20')
        """
        self.log.info("Setting Device MAC Address")
        direction, maximum = kwargs.get('direction','increment'), kwargs.get('maximum', None)
        mask = kwargs.get('mask', None)
        ethernetNameList = [ethernetObj.Name for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find()]
        protocols = ['Ospfv2','BgpIpv4Peer','LdpConnectedInterface','Ospfv3','BgpIpv6Peer','Ldpv6ConnectedInterface']
        for protocol in protocols:
            try:
                for ethernetName in ethernetNameList:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv4.find().'+ protocol +'.find()'):
                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):
                            if router_id in eval('ethernetObj.Ipv4.find().'+protocol+'.find().LocalRouterID'):
                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)
            except:
                pass
            try:
                for ethernetName in ethernetNameList:
                    if eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName).Ipv6.find().'+ protocol +'.find()'):
                        for ethernetObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find(Name=ethernetName):
                            if router_id in eval('ethernetObj.Ipv6.find().'+ protocol +'.find().LocalRouterID'):
                                return self._modify_ethernet_address(value_mode, value, step, seed, repeat_count, direction, maximum, mask, ethernetObj)
            except:
                pass
        return True

    def _start_stop_protocols(self, protocols, port_list, host_ip_list, action, active, devices, nested_device):
        """
        Function used internally by start_protocol/stop_protocol API'S

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp'])
                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.

        :param port_list: one or more portNames in list on which device can be started.
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']
                            port: The virtual port name.

        :param host_ip_list: one or more hostip in list of type ipv4 or ipv6.
                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']
                               host_ip: The source IP address to query for the object.
        :param action: 'start' or 'stop'
        :param active: 'True' or 'False'
        :param devices: Name of the devices in the config
        :param nested_device: Nested device name to set action
        """
        classicprotocol = False
        if isinstance(protocols, str):
            protocols = protocols.split(",")
        for each_protocol in protocols:
            if each_protocol in ('lacp', 'lldp', 'dcbx'):
                classicprotocol = True
        if action == 'start':
            self.start_arp()
        if type(protocols) is dict:
            protocols = set(protocols)
        protocolsList = {'isis': 'IsisL3', 'dhcpv4client': 'Dhcpv4client', 'dhcpv6client': 'Dhcpv6client',
                         'pppoxclient': 'Pppoxclient', 'pppoxserver': 'Pppoxserver', 'mpls': 'Mpls',
                         'dotonex': 'DotOneX', 'bfdv4interface': 'Bfdv4Interface', 'bgp': 'BgpIpv4Peer',
                         'dhcpv4server': 'Dhcpv4server', 'igmp': 'IgmpHost', 'rsvp': 'RsvpteLsps',
                         'rsvptelf': 'Rsvptelf',
                         'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',
                         'ldpconnectedinterface': 'LdpConnectedInterface', 'ospfv2': 'Ospfv2',
                         'bfdv6interface': 'Bfdv6Interface', 'bgpv6': 'BgpIpv6Peer', 'dhcpv6server': 'Dhcpv6server',
                         'ldpbasicrouterv6': 'LdpBasicRouterV6', 'ldpv6connectedinterface': 'Ldpv6ConnectedInterface',
                         'mld': 'MldHost', 'mldquerier': 'MldQuerier', 'pimv6interface': 'PimV6Interface',
                         'ospfv3': 'Ospfv3'}
        protocolsListV6 = ['mld', 'ospfv3', 'bfdv6interface', 'ldpbasicrouterv6', 'pimv6interface''dhcpv6client',
                           'bgpipv6peer', 'dhcpv6server', 'bgpv6']
        for protocol in protocols:
            if port_list:
                if isinstance(port_list, str):
                    port_list = port_list.split(",")
                port_name_dict = {}
                for vport in self.ixNetwork.Vport.find():
                    if vport.AssignedTo.replace(":", "/") in port_list or vport.Name in port_list:
                        port_name_dict.update({vport.Name: vport.href})
                for port_name in port_name_dict.keys():
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == port_name_dict[port_name]:
                            topologyObj = topology.href
                            for ethernet in topology.DeviceGroup.find().Ethernet.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocolObj in eval('ethernet.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):
                                                eval('ethernet.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(None)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

                            for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocolObj in eval('ipv4.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):
                                                eval('ipv4.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(None)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

                            for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                if protocol.lower() in protocolsList:
                                    try:
                                        for protocolObj in eval('ipv6.' + protocolsList[protocol.lower()] + '.find()'):
                                            if re.match(topologyObj + '/deviceGroup', protocolObj.href):
                                                eval('ipv6.' + protocolsList[
                                                    protocol.lower()] + '.find().' + action + '(None)')
                                    except AttributeError:
                                        pass
                                    except:
                                        raise IxiaConfigException("Failed to start protocol %s" % protocol)

            if host_ip_list:
                protocol = protocol.lower()
                ipv4_host_ips = [hostIp for hostIp in host_ip_list if ":" not in hostIp]
                ipv6_host_ips = [hostIp for hostIp in host_ip_list if ":" in hostIp]
                if protocol in protocolsList and protocol not in protocolsListV6:
                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                        ipindices = []
                        for ipaddress in ipv4_host_ips:
                            if ipaddress in ipv4Obj.Address.Values:
                                ipindices.append((ipv4Obj.Address.Values).index(ipaddress) + 1)
                        try:
                            eval('ipv4Obj.' + protocolsList[protocol] + '.find().' + action + '(ipindices)')
                        except:
                            pass
                else:
                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                        ipv6indices = []
                        for ipv6address in ipv6_host_ips:
                            if ipv6address in ipv6Obj.Address.Values:
                                ipv6indices.append((ipv6Obj.Address.Values).index(ipv6address) + 1)
                        try:
                            eval('ipv6Obj.' + protocolsList[protocol] + '.find().' + action + '(ipv6indices)')
                        except:
                            pass

            if devices and nested_device is None:
                deviceNameList = [deviceGroupObj.Name for deviceGroupObj in
                                  self.ixNetwork.Topology.find().DeviceGroup.find()]
                for eachDevice in devices:
                    if eachDevice in deviceNameList:
                        eachDevice = '^' + eachDevice.replace('+', '\+').replace('*', '\*') + '$'
                        if protocol.lower() in protocolsList:
                            try:
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                    protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass

                        if protocol.lower() in protocolsList:
                            try:
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().\
                                    Ipv4.find().' + protocolsList[
                                    protocol.lower()] + '.find().Active.Single' + '(active)')
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                    protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass

                        if protocol.lower() in protocolsList:
                            try:
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().\
                                     Ipv6.find().' + protocolsList[
                                    protocol.lower()] + '.find().Active.Single' + '(active)')
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                    protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass
                    else:
                        self.log.warning("Device - '%s', not found in the Ixia config" % eachDevice)

            if devices and nested_device:
                device_name_list = [deviceGroupObj.Name for deviceGroupObj in
                                  self.ixNetwork.Topology.find().DeviceGroup.find()]
                for each_device in devices:
                    if each_device in device_name_list:
                        device = '^' + each_device.replace('+', '\+').replace('*', '\*') + '$'
                        if protocol.lower() in protocolsList:
                            try:
                                eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="'+device+'").DeviceGroup.find(Name="'+nested_device+'").\
                                    Ipv4Loopback.find().' + protocolsList[protocol.lower()] + '.find().Active.Single' + '(active)')

                                eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="'+device+'").DeviceGroup.find(Name="'+nested_device+'").\
                                    Ipv4Loopback.find().' + protocolsList[protocol.lower()] + '.find().' + action + '(None)')

                            except:
                                pass

                            try:
                                eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="'+device+'").DeviceGroup.find(Name="'+nested_device+'").\
                                       Ipv6Loopback.find().' + protocolsList[protocol.lower()] + '.find().Active.Single' + '(active)')

                                eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="'+device+'").DeviceGroup.find(Name="'+nested_device+'").\
                                       Ipv6Loopback.find().' + protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass

                        if protocol.lower() in protocolsList:
                            try:
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + device + '").DeviceGroup.find().DeviceGroup.\
                                find( Name="' + nested_device + '").Ethernet.find().Ipv4.find().' + protocolsList[
                                    protocol.lower()] + '.find().Active.Single' + '(active)')
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + device + '").DeviceGroup.find().DeviceGroup.\
                                find( Name="' + nested_device + '").Ethernet.find().Ipv4.find().' +
                                     protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass

                        if protocol.lower() in protocolsList:
                            try:
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + device + '").DeviceGroup.find().DeviceGroup.\
                                find( Name="' + nested_device + '").Ethernet.find().Ipv6.find().' + protocolsList[
                                    protocol.lower()] + '.find().Active.Single' + '(active)')
                                eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + device + '").DeviceGroup.find().DeviceGroup.\
                                find( Name="' + nested_device + '").Ethernet.find().Ipv6.find().' +
                                     protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                            except:
                                pass

                    else:
                        self.log.warning(f"Device - {each_device}, not found in the Ixia config")

            if port_list is None and host_ip_list is None and devices is None and classicprotocol is False:
                if protocol.lower() in protocolsList:
                    try:
                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + protocolsList[
                            protocol.lower()] + '.find().' + action + '(None)')
                    except:
                        pass

                if protocol.lower() in protocolsList:
                    try:
                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().' +
                             protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                    except:
                        pass

                if protocol.lower() in protocolsList:
                    try:
                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().' +
                             protocolsList[protocol.lower()] + '.find().' + action + '(None)')
                    except:
                        pass

            if classicprotocol:
                if protocol.lower() == 'lacp':
                    try:
                        eval('self.ixNetwork.Vport.find().Protocols.find().Lacp.' + action + '()')
                    except:
                        pass
                if protocol.lower() == 'lldp' or protocol.lower() == 'dcbx':
                    try:
                        eval('self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().DcbxEndpoint.find().' + action + '()')
                    except:
                        pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def start_protocols(self, protocols, port=None, host_ip=None, protocol_only=False, devices=None, **kwargs):
        """
        To start devices configured with a protocol or a list of protocols

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']). \n
                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.
        :param port: one or more portNames in list on which device can be started. \n
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10'].
                            port: The virtual port name.
        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \n
                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2'].
                               host_ip: The source IP address to query for the object.
        :param protocol_only: NA for Ixia. Added to follow Tgn Vendor Agnostic.
        :param devices: Name of the devices in the config
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA nested Device name if nested DG to be started
        :return: True on success

        :Example: start_protocols(['ospfv2', 'ospfv3'])
                  start_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])
                  start_protocols(protocols=["rsvp"],devices=["D8_5"],nested_device="D8_5_RSVP")
        """
        self.log.info(f"Starting protocols: {protocols}")
        port_list = port
        host_ip_list = host_ip
        nested_device = kwargs.get('nested_device', None)
        return self._start_stop_protocols(protocols, port_list, host_ip_list, "Start", "True", devices, nested_device)

    def stop_protocols(self, protocols, port=None, host_ip=None, devices=None, **kwargs):
        """
        To stop devices configured with a protocol or a list of protocols

        :param protocols: one or more protocols in list(Ex: ['ospfv3'] or ['ospfv3','bgp']) \n
                                 Choices: bgpIpv4Peer, bgpIpv6Peer, ospfv2, ospfv3, isisL3, etc.
        :param port: one or more portNames in list on which device can be started. \n
                            Ex: ['1/2/9'] or ['1/2/9','1/2/10']
                            port: The virtual port name.
        :param host_ip: one or more hostip in list of type ipv4 or ipv6. \n
                               Ex: ['100.1.1.1'] or ['100.1.1.1','100.1.1.2']
                               host_ip: The source IP address to query for the object.
        :param devices: Name of the devices in the config
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: nested_device: For IXIA nested Device name if nested DG to be stopped

        :Example: stop_protocols(protocols=['ospfv2', 'ospfv3'], devices=['DG1'])
                  stop_protocols(protocols=['bgpv6'], devices=['EBGPV6 1'])
                  stop_protocols(protocols=["rsvp"],devices=["D8_5"],nested_device="D8_5_RSVP")

        :return: True on Success,else raises exception
        """
        self.log.info(f"Stopping protocols: {protocols}")
        port_list = port
        host_ip_list = host_ip
        nested_device = kwargs.get('nested_device', None)
        return self._start_stop_protocols(protocols, port_list, host_ip_list, "Stop", "False", devices, nested_device)

    def connect_to_session(self, sid=None, **kwargs):
        """
        Connect to an existing session on the TGN.

        :param sid: The session ID on the Linux API server or Windows Connection Mgr to connect to.
        :param kwargs: optional
        :return: True if successful else raises exception

        :Example: connect_to_session(sId=1)
        """
        kill_existing = kwargs.get('kill_existing', False)
        self._new_session(session_name=sid, kill_existing=kill_existing)
        return True

    def delete_session(self):
        """
        Deletes the TGN session

        :return: True on success, exception on failure

        :Example: delete_session()
        """
        if self.tgn_server_type == "linux":
            try:
                sId = self.session.Id
                self.session.remove()
                self.log.info("Deleted Session %s" %sId)
                return True
            except:
                self.log.error("Failed to delete the Session")

    def tgn_disconnect(self, port_list=None):
        """
        Release the ports and delete the session.

        :param port_list: (list): format = [[(str(chassisIp), str(slotNumber), str(portNumber)]] \n
                Example: [ ['192.168.70.10', '1', '1'] ] \n
                Example: [ ['192.168.70.10', '1', '1'], ['192.168.70.10', '2', '1'] ]
        :return: True on success, exception on failure

        :Example: tgn_disconnect(port_list=['Ethernet - 001','Ethernet - 002'])
        """
        self.log.info("Disconnecting TGN Session")
        if port_list:
            self.release_ports(port_list)
            results = True
        else:
            self.release_ports()
            results = True

        # If OS is linux, delete the session
        if self.tgn_server_type == 'linux':
            self.session.remove()
            results = True
        return results

    def _ldp_start_stop(self, port, hostip, action):
        """
        Function used internally by APIS ldp_start and ldp_stop

        :param port: one or more port names in a list. If 'None', all the ports.
                Ex: port = ['1/1/2']
                     port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address
                    Ex : hostip = ['1.1.1.1']
                        hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :param action: 'start' or 'stop'
        """
        self.log.info('LDP action %s' % (action))
        if (port and hostip):
            if type(port) is str:
                port = port.split(",")
            for portName in port:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href

                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            ipv4_temp = []
                            ipv6_temp = []
                            ipv4Address = []
                            ipv6Address = []
                            [ipv4_temp.append(ipv4.Address.Values) for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find()]

                            for ip in ipv4_temp:
                                for eachIp in ip:
                                    ipv4Address.append(eachIp)

                            if len(hostip) == len(ipv4Address):
                                if action == "Start":
                                    for ldp in ipv4.LdpConnectedInterface.find():
                                        if re.match(topologyObj + '/deviceGroup', ldp.href):
                                            Name = ldp.DescriptiveName.replace('+', '\+').replace('*','\*').replace('(', '\(').replace(')', '\)')
                                            eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                                else:
                                    for ldp in ipv4.LdpBasicRouter.find():
                                        if re.match(topologyObj + '/deviceGroup', ldp.href):
                                            Name= ldp.DescriptiveName.replace('+', '\+').replace('*', '\*').replace('(', '\(').replace(')', '\)')
                                            eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            [ipv6_temp.append(ipv6.Address.Values) for ipv6 in
                             topology.DeviceGroup.find().Ethernet.find().Ipv6.find()]

                            for ip in ipv6_temp:
                                for eachIp in ip:
                                    ipv6Address.append(eachIp)
                            if len(hostip) == len(ipv6Address):
                                for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                    if action == "Start":
                                        for ldp in ipv6.Ldpv6ConnectedInterface.find():
                                            if re.match(topologyObj + '/deviceGroup', ldp.href):
                                                Name = ldp.DescriptiveName.replace('+', '\+').replace('*','\*').replace('(', '\(').replace(')', '\)')
                                                eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                                    else:
                                        for ldp in ipv6.LdpBasicRouterV6.find():
                                            if re.match(topologyObj + '/deviceGroup', ldp.href):
                                                Name = ldp.DescriptiveName.replace('+', '\+').replace('*','\*').replace('(', '\(').replace(')', '\)')
                                                eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')

        if (port and hostip is None):
            if type(port) is str:
                port = port.split(",")
            for portName in port:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            if action == "Start":
                                for ldp in ipv4.LdpConnectedInterface.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', '\+').replace('*','\*').replace('(', '\(').replace(')', '\)')
                                        eval('ipv4.LdpConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                            else:
                                for ldp in ipv4.LdpBasicRouter.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name= ldp.DescriptiveName.replace('+', '\+').replace('*', '\*').replace('(', '\(').replace(')', '\)')
                                        eval('ipv4.LdpBasicRouter.find(DescriptiveName=Name).'+action+'(None)')
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            if action == "Start":
                                for ldp in ipv6.Ldpv6ConnectedInterface.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', '\+').replace('*', '\*').replace('(',')', '\)')
                                        eval('ipv6.Ldpv6ConnectedInterface.find(DescriptiveName=Name).'+action+'(None)')
                            else:
                                for ldp in ipv6.LdpBasicRouterV6.find():
                                    if re.match(topologyObj + '/deviceGroup', ldp.href):
                                        Name = ldp.DescriptiveName.replace('+', '\+').replace('*', '\*').replace('(',')','\)')
                                        eval('ipv6.LdpBasicRouterV6.find(DescriptiveName=Name).' + action + '(None)')

        if hostip and port is None:
            for ipAddress in hostip:
                if ':' not in ipAddress:
                    for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                       if ipAddress in ipv4Obj.Address.Values:
                            ipIndex = (ipv4Obj.Address.Values).index(ipAddress)+1
                            if action == "Start":
                                eval('ipv4Obj.LdpConnectedInterface.find().'+action+'(ipIndex)')
                            else:
                                eval('ipv4Obj.LdpBasicRouter.find().'+action+'(ipIndex)')
                            break
                else:
                    for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                        if ipAddress in ipv6Obj.Address.Values:
                            ipIndex = (ipv6Obj.Address.Values).index(ipAddress) + 1
                            if action == "Start":
                                eval('ipv6Obj.Ldpv6ConnectedInterface.find().'+action+'(ipIndex)')
                            else:
                                eval('ipv6Obj.LdpBasicRouterV6.find().'+action+'(ipIndex)')
                            break
        if port is None and hostip is None:
            if action == "Start":
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpConnectedInterface.find().'+action+'(None)')
                except:pass
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ldpv6ConnectedInterface.find().'+action+'(None)')
                except:pass
            else:
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().LdpBasicRouter.find().'+action+'(None)')
                except:pass
                try:
                    eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().LdpBasicRouterV6.find().'+action+'(None)')
                except:pass

        return True

    def ldp_start(self, port=None, hostip=None):
        """
        Starts LDP emulation

        :param port: one or more port names in a list. If 'None', all the ports. \n
                    Ex : port = ['1/1/2']
                    Ex : port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \n
                    Ex : hostip = ['1.1.1.1']
                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :return: True. raise exception if False/error

        :Example: ldp_start(hostip=['100.1.0.1','100.1.0.2'])
        """

        return self._ldp_start_stop(port, hostip, "Start")

    def ldp_stop(self, port=None, hostip=None):
        """
        Stops LDP emulation

        :param port: one or more port names in a list. If 'None', all the ports. \n
                    Ex : port = ['1/1/2']
                    Ex : port = ['1/1/1', '1/1/2']
        :param hostip: one or more hostips in a list. If 'None' all the LDP hosts. Supports IPv4/IPv6 address \n
                    Ex : hostip = ['1.1.1.1']
                    Ex : hostip = ['1.1.1.1', '2000:0:0:1::1', ...]
        :return: True. raise exception if False/error

        :Example: ldp_stop(hostip=['100.1.0.1','100.1.0.2'])
        """

        return self._ldp_start_stop(port, hostip, "Stop")

    def clear_traffic_stats(self):
        """
        Clears the traffic statistics on the chassis

        :return: True if success, false if error

        :Example: clear_traffic_stats()
        """
        self.log.info("Clearing Stats")
        try:
            self.ixNetwork.ClearStats(Arg1=["waitForTrafficStatsRefresh"])
        except:
            pass
        self.log.info("Traffic Stats Cleared")
        return True

    def _change_mac_format(self,inputMac):
        """
        Internal function to change MAC address format

        :param inputMac: MAC Address in any format
                        EX:'008a.9695.748c'
        :return: MAC Address in actual format
                OutputMac: '00:8a:96:95:74:8c'
        """
        outputMac = netaddr.EUI(inputMac)
        outputMac.dialect = netaddr.mac_unix_expanded
        return str(outputMac)

    def change_traffic_mac(self,
                           traffic_item_name=None,
                           endpoint_name='EndpointSet-1',
                           mac_dst_mode=None,
                           mac_dst='00:00:00:00:00:01',
                           mac_dst_count=1,
                           mac_dst_step='00:00:00:00:00:01',
                           mac_dst_mask='FF:FF:FF:FF:FF:FF',
                           mac_dst_seed=1,
                           mac_src_mode=None,
                           mac_src='00:00:00:00:00:01',
                           mac_src_count=1,
                           mac_src_step='00:00:00:00:00:01',
                           mac_src_mask='FF:FF:FF:FF:FF:FF',
                           mac_src_seed=1):
        """
        API used to change MAC Address on Traffic Item/Stream

        :param traffic_item_name: The traffic item name
        :param endpoint_name: The endpoint name
        :param mac_dst_mode: The mac destination mode
        :param mac_dst: The mac destination address
        :param mac_dst_count: The mac destination count
        :param mac_dst_step: The mac destination step
        :param mac_dst_mask: The mac destination mask
        :param mac_dst_seed: The mac destination seed
        :param mac_src_mode: The mac source mode
        :param mac_src: The mac source address
        :param mac_src_count: The mac source count
        :param mac_src_step: The mac source step
        :param mac_src_mask: The mask source mask
        :param mac_src_seed: The mask source seed
        :return: True on success else raises exception

        :Example: change_traffic_mac(traffic_item_name="Traffic Item 4")
        """
        self.log.info("Changing Mac Parameters for Traffic Item/Items")
        mac_mode_dict = {None: 'singleValue', 'fixed': 'singleValue', 'discovery': 'singleValue', 'increment': 'increment', 'list': 'valueList',
                         'decrement': 'decrement', 'random': 'nonRepeatableRandom', 'repeatable_random': 'repeatableRandomRange'}

        mac_src_list = []
        mac_dst_list = []

        if isinstance(mac_dst, list):
            for mac_dst_value in mac_dst:
                mac_dst_list.append(self._change_mac_format(mac_dst_value))
            mac_dst = mac_dst_list[0]
        else:
            mac_dst = self._change_mac_format(mac_dst)
            mac_dst_list = [mac_dst]
        mac_dst_step = self._change_mac_format(mac_dst_step)
        mac_dst_mask = self._change_mac_format(mac_dst_mask)

        if isinstance(mac_src, list):
            for mac_src_value in mac_src:
                mac_src_list.append(self._change_mac_format(mac_src_value))
            mac_src = mac_src_list[0]
        else:
            mac_src = self._change_mac_format(mac_src)
            mac_src_list = [mac_src]
        mac_src_step = self._change_mac_format(mac_src_step)
        mac_src_mask = self._change_mac_format(mac_src_mask)
        if isinstance(traffic_item_name, str):
            trafficItemNameList = [traffic_item_name]
        elif isinstance(traffic_item_name, list):
            trafficItemNameList = traffic_item_name
        else:
            trafficItemNameList = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]

        for trafficItemName in trafficItemNameList:
            trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
            for stack in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find().Stack.find():
                fieldNames = [fieldObj.DisplayName for fieldObj in stack[0].Field.find()]
                for fieldName in fieldNames:
                    if fieldName == "Destination MAC Address":
                        field = stack[0].Field.find(DisplayName=fieldName)
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.RandomMask, \
                        field.Seed, field.ValueList = mac_mode_dict[mac_dst_mode], mac_dst, mac_dst_count, mac_dst, mac_dst_step, \
                                                      mac_dst_mask, mac_dst_seed, mac_dst_list

                    if fieldName == "Source MAC Address":
                        field = stack[0].Field.find(DisplayName=fieldName)
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue, field.RandomMask, \
                        field.Seed, field.ValueList = mac_mode_dict[mac_src_mode], mac_src, mac_src_count, mac_src, mac_src_step, \
                                                      mac_src_mask, mac_src_seed, mac_src_list
        self.log.info("Mac updated in Traffic Items")
        return True

    def change_traffic_transmission_mode(self, config, traffic_item_list='all', port='all'):
        """
        Changes the transmission control mode for a given set of traffic items.

        :param config: Dict including the transmission control data to be modified. \n
            valid Options:\n
            type: auto,continuous,custom,fixedDuration, fixedFrameCount,fixedIterationCount \n
            duration: The duration of time (in seconds) for traffic to run for applicable transmission control types \n
            extra options (case-sensitive): iterationCount,frameCount,startDelay,startDelayUnits,minGapBytes, burstPacketCount,repeatBurst,interBurstGap,interStreamGap,interBurstGapUnits \n
        :param traffic_item_list: List of traffic Items name.
        :param port: NA for IXIA
        :return: True on success, else reverts the config

        :Example: change_traffic_transmission_mode(config={'type': 'custom', 'interBurstGap': 25, 'burstPacketCount': 25}, traffic_item_list=["Traffic Item 3"])
        """

        self.log.info("Changing Traffic Transmission Mode")
        if traffic_item_list and traffic_item_list != 'all':
            for trafficItem in traffic_item_list:
                trafficItem = trafficItem.replace('+', '\+').replace('*', '\*')
                for transmissionControl in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItem + '$').ConfigElement.find().TransmissionControl:
                    for key in config:
                        if 'interBurstGap' in key:
                            setattr(transmissionControl, 'EnableInterBurstGap', True)
                        try:
                            setattr(transmissionControl, key[0].upper() + key[1:], config[key])
                        except:
                            pass
        else:
            for transmissionControl in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().TransmissionControl:
                for key in config:
                    if 'interBurstGap' in key:
                        setattr(transmissionControl, 'EnableInterBurstGap', True)
                    try:
                        setattr(transmissionControl, key[0].upper() + key[1:], config[key])
                    except:
                        pass
        self.log.info("Traffic Transmission mode updated in Traffic Items")

    def _igmp_mld_multicast(self, vportList, ipVersion, HostObj,srcObj, groupObj, proto, action, state,
                             igmp_mld_mcastList, hostIpList=None, versionType=None, groupDict=None, protocolType='mld'):
        """
        Function used internally by APIs igmp_join_leave,mld_join_leave

        :param vportList: List of Vports
        :param ipVersion: IP version , Ex:IPv4/IPv6
        :param HostObj: Host Object
        :param srcObj: Source Object
        :param groupObj: Group Object
        :param proto: Protocol
        :param action: Action
        :param state: State
        :param igmp_mld_mcastList: IGMP MLD Multicast
        :param hostIpList: Host IP List
        :param versionType: IGMP Version type.
        :param groupDict: IGMP Group value
        :param protocolType: Protocol Type
        """

        for vport in vportList:
            vport = vport.replace("(", "\(").replace(")", "\)")
            if self.ixNetwork.Vport.find(Name=vport + '\s'):
                vports = self.ixNetwork.Vport.find(Name=vport + '\s')
            else:
                vports = self.ixNetwork.Vport.find(Name=vport)
            for topology in self.ixNetwork.Topology.find():
                if vports.href in topology.Vports:
                    portIndex = topology.Vports.index(vports.href)
                    for deviceGroup in topology.DeviceGroup.find():
                        multiplier = deviceGroup.Multiplier
                        mcastList = {'igmp_mld_host_obj': '', 'action_list': '', 'new_active_state': '', 'port_ips': '', 'selected_index': '', 'selected_info': ''}
                        
                        if eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()'):
                            groupList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find()')
                            if groupList.Status == "notStarted":
                                eval('groupList.' + proto +'StartHost()')
                                time.sleep(10)
                                eval('groupList.' + groupObj + '.' + proto + 'Leave' + 'Group(None)')
                                time.sleep(10)
                            else:
                                pass

                            groupRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges
                            groupRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges

                            sourceRangeStartIndex = portIndex * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')
                            sourceRangeEndIndex   = (portIndex+1) * multiplier * groupList.NoOfGrpRanges * eval('groupList.'+ groupObj + '.NoOfSrcRanges')

                            if hostIpList:
                                ipAddressList = eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().Address.Values')
                                for ip in hostIpList:
                                    if ip in ipAddressList:
                                        ipIndex = ipAddressList.index(ip)
                                        ipGroupRangeStartIndex = ipIndex * groupList.NoOfGrpRanges + 1
                                        ipGroupRangeEndIndex = (ipIndex + 1) * groupList.NoOfGrpRanges
                                        if ipGroupRangeStartIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1):
                                            groupRange = str(ipGroupRangeStartIndex)+"-"+str(ipGroupRangeEndIndex)
                                            eval('deviceGroup.Ethernet.find().' + ipVersion + '.find().' + HostObj + '.find().' + groupObj
                                                 + '.' + proto + action + 'Group(SessionIndices=groupRange)')

                            elif groupDict:
                                for group in groupDict:
                                    mcastGroupsList = eval('groupList.' + groupObj + '.StartMcastAddr.Values')
                                    if ipVersion.lower() == "ipv4":
                                        sourcesList = eval('groupList.' + groupObj +'.IgmpUcastIPv4SourceList.StartUcastAddr.Values')
                                    else:
                                        sourcesList = eval('groupList.' + groupObj +'.MldUcastIPv6SourceList.StartUcastAddr.Values')

                                    mcastGroupsIndices = [index + 1 for index in range(len(mcastGroupsList)) if group ==
                                                          mcastGroupsList[index] and index in range(groupRangeStartIndex, groupRangeEndIndex)]

                                    #version and group combination
                                    versionTypeValues = groupList.VersionType.Values
                                    indices = [index + 1 for index, version in enumerate(versionTypeValues) if version == versionType]
                                    groupRanges = eval('groupList.NoOfGrpRanges')
                                    joinLeaveList = []
                                    for index in indices:
                                        endIndex = index * groupRanges
                                        startIndex = endIndex - groupRanges
                                        GroupIndexList = [index for index in range(endIndex, startIndex, -1)]
                                        GroupIndexList = GroupIndexList[::-1]
                                        joinLeaveList.append(GroupIndexList)
                                    joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index
                                                     if joinIndex in range(groupRangeStartIndex + 1, groupRangeEndIndex + 1)]

                                    mcastGroupSourceIndices = list(set(joinLeaveList).intersection(mcastGroupsIndices))

                                    if mcastGroupSourceIndices != []:
                                        if '*' in groupDict[group]:
                                            eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')
                                        else:
                                            sourcesListindices = []
                                            for source in groupDict[group]:
                                                sourcesListindices.append([index + 1 for index in range(len(sourcesList)) if source ==
                                                                           sourcesList[index] and index in range(sourceRangeStartIndex, sourceRangeEndIndex)])

                                            sourcesListindices = [ele for subele in sourcesListindices for ele in subele]

                                            sources = eval('groupList.' + groupObj + '.NoOfSrcRanges')
                                            mcastGroupIndex = mcastGroupsIndices[0]
                                            srcRangeStartIndex = (mcastGroupIndex - 1) * sources + 1
                                            srcRangeEndIndex = (mcastGroupIndex) * sources + 1
                                            sourcesListindices = [sourceIndex for sourceIndex in sourcesListindices
                                                                  if sourceIndex in range(srcRangeStartIndex, srcRangeEndIndex)]

                                            if action == "Join":
                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')
                                                sourceRange = str(srcRangeStartIndex) + "-" + str(srcRangeEndIndex-1)
                                                eval('groupList.' + groupObj + '.' + srcObj + '.' + proto + 'LeaveSource(SessionIndices=sourceRange)')

                                            eval('groupList.' + groupObj + '.' + srcObj + '.'+ proto + action + 'Source(SessionIndices=sourcesListindices)')

                                            time.sleep(2)
                                            if ipVersion.lower() == "ipv4":
                                                stateList = eval('groupList.' + groupObj + '.IgmpUcastIPv4SourceList.State')
                                            else:
                                                stateList = eval('groupList.' + groupObj + '.MldUcastIPv6SourceList.State')

                                            stateList = stateList[(mcastGroupIndex - 1)*sources:(mcastGroupIndex)*sources]
                                            if len(set(stateList)) == 1:
                                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(SessionIndices=mcastGroupSourceIndices)')

                            elif versionType:
                                versionTypeValues = groupList.VersionType.Values
                                indices = [index+1 for index, version in enumerate(versionTypeValues) if version == versionType]
                                groupRanges = eval('groupList.NoOfGrpRanges')
                                joinLeaveList = []
                                for index in indices:
                                    endIndex = index * groupRanges
                                    startIndex = endIndex - groupRanges
                                    GroupIndexList = [index for index in range(endIndex, startIndex, -1)]
                                    GroupIndexList = GroupIndexList[::-1]
                                    joinLeaveList.append(GroupIndexList)
                                joinLeaveList = [joinIndex for index in joinLeaveList for joinIndex in index
                                                 if joinIndex in range(groupRangeStartIndex+1,groupRangeEndIndex+1)]
                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(joinLeaveList)')
                            else:
                                eval('groupList.' + groupObj + '.' + proto + action + 'Group(None)')

                        igmp_mld_mcastList.append(mcastList)

    def _igmp_mld_join_leave(self, protocol, port, action, version, hostIp, groups):
        """
        Function used internally by APIs igmp_join_leave,mld_join_leave

        :param protocol: Protocol Type
        :param port: IXIA Port
        :param action: Action , Ex: Join/Leave
        :param version: IGMP version
        :param hostIp: Host IP
        :param groups: IGMP Groups
        """

        if protocol.lower() == 'mld':
            HostObj = "MldHost"
            ipVersion = "Ipv6"
            groupObj = "MldMcastIPv6GroupList"
            proto = "Mld"
            srcObj = "MldUcastIPv6SourceList"
        else :
            HostObj = "IgmpHost"
            ipVersion ="Ipv4"
            groupObj = "IgmpMcastIPv4GroupList"
            proto = "Igmp"
            srcObj = "IgmpUcastIPv4SourceList"
        if action.lower() == "leave":
            action = "Leave"
            state = "notJoined"
        else:
            action = "Join"
            state = "joined"
        igmp_mld_mcastList = []

        if version == 'v1':
            version = "version1"
        elif version == 'v2':
            version = "version2"
        elif version == 'v3':
            version = "version3"
        else:
            if protocol.lower() == 'mld':
                version = "version1"
            else:
                version = "version2"

        if port == None and hostIp == None and groups == None and version == None:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList)

        elif port:
            if type(port) is str:
                port = port.split(",")
            vportNameList = [vport.Name.split("//")[0].rstrip() for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in port if portName in vportNameList]
            if groups:
                groupsOnly = list(set([group[1] for group in groups]))
                groupDict = {}
                for groupOnly in groupsOnly:
                    groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]
                self._igmp_mld_multicast(portNameList, ipVersion, HostObj,srcObj, groupObj, proto,
                                         action, state, igmp_mld_mcastList,hostIpList=hostIp,
                                         versionType=version,groupDict=groupDict, protocolType=protocol)
            else:
                self._igmp_mld_multicast(portNameList, ipVersion, HostObj, srcObj, groupObj, proto,
                                         action, state, igmp_mld_mcastList, hostIpList=hostIp,
                                         versionType=version)

        elif hostIp:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList, hostIpList=hostIp)

        elif groups:
            groupsOnly = list(set([group[1] for group in groups]))
            groupDict = {}
            for groupOnly in groupsOnly:
                groupDict[groupOnly] = [group[0] for group in groups if group[1] == groupOnly]
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj, srcObj, groupObj, proto,
                                     action, state, igmp_mld_mcastList, groupDict=groupDict, protocolType=protocol, versionType=version)

        elif version:
            vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            self._igmp_mld_multicast(vportList, ipVersion, HostObj,srcObj, groupObj, proto,
                                                        action, state, igmp_mld_mcastList, versionType=version)

        return igmp_mld_mcastList

    def igmp_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):
        """
        Igmp join or leave for multicast groups

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param action: "join" or "leave". Default value is "join"
        :param version: CHOICES 'v1', 'v2', 'v3'
        :param hostIp: list of host ip. E.g. ['1.1.1.1', '1.2.1.1']
        :param groups: list of ipv4 multicast groups.

        :Example: igmp_join_leave(port=["Ethernet - 001", "Ethernet - 002"], hostIp=["105.1.1.2","105.1.2.2"],action='join')
        """
        self.log.info('igmp %s' % action)
        return self._igmp_mld_join_leave('igmp', port, action, version, hostIp, groups)


    def _igmp_mld_control(self, port, hostip, protocol, action):
        """
        Function used internally by APIS igmp_stop,igmp_start,mld_start,mld_stop

        :param port: Port
        :param hostip: Host IP
        :param protocol: Protocol
        :param action: Action , Ex : start/stop
        """
        if protocol.lower() == 'mld':
            HostObj = "MldHost"
            ipVersion = "Ipv6"
        else :
            HostObj = "IgmpHost"
            ipVersion ="Ipv4"
        if port == None and hostip == None:
            for host in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find().'+HostObj+'.find()'):
                eval('host.' + action + '(None)')
        if port:
            for eachPort in port:
                assignedPort = eachPort.replace('/', ':')
                vportList = [vport.Name for vport in self.ixNetwork.Vport.find()]
                if assignedPort in [self.ixNetwork.Vport.find(Name=vport).AssignedTo for vport in vportList]:
                    for vport in vportList:
                        assignedVport = self.ixNetwork.Vport.find(Name=vport)
                        if assignedVport.AssignedTo == assignedPort:
                            for topology in self.ixNetwork.Topology.find():
                                if topology.Vports[0] == assignedVport.href:
                                    topologyObj = topology.href
                                    for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()'):
                                        for hostObj in eval('ipObj.'+HostObj+'.find()'):
                                            if re.match(topologyObj + '/deviceGroup', hostObj.href):
                                                eval('ipObj.'+HostObj+'.find(DescriptiveName=hostObj.DescriptiveName).'+action +'(None)')
                else:
                    raise IxiaConfigException("Port %s is invalid or not configured"%assignedPort)

        if hostip:
            for ip in hostip:
                ipNameList = [address.Name for address in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find()') if address]
                for ipName in ipNameList:
                    address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ ipVersion +'.find(Name=ipName).Address')
                    if ip in address.Values:
                        ipIndex = address.Values.index(ip) + 1
                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+ipVersion+'.find(Name=ipName).'+HostObj+'.find().'+action+'(ipIndex)')
        return True

    def igmp_start(self,port=None,hostip=None):
        """
        To  start igmp emulation

        :param port: List of ports. If 'None', all the ports
        :param hostip: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: igmp_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Starting IGMP")
        return self._igmp_mld_control(port, hostip, 'igmp', 'Start')

    def igmp_stop(self,port=None,hostip=None):
        """
        To  stop igmp emulation

        :param port: List of ports. If 'None', all the ports
        :param hostip: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: igmp_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Stopping IGMP")
        return self._igmp_mld_control(port, hostip, 'igmp', 'Stop')

    def mld_start(self,port=None,hostIp=None):
        """
        To  start mld emulation

        :param port: List of ports. If 'None', all the ports
        :param hostIp: List of hostip. If 'None' all the mld hosts
        :return: raise exception if False/error

        :Example: mld_start(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Starting MLD")
        return self._igmp_mld_control(port, hostIp, 'mld', 'Start')

    def mld_stop(self,port=None,hostIp=None):
        """
        To  stop mld emulation

        :param port: List of ports. If 'None', all the ports
        :param hostIp: List of hostip. If 'None' all the igmp hosts
        :return: raise exception if False/error

        :Example: mld_stop(port=['10.39.64.132/2/11', '10.39.64.132/2/12'])
        """
        self.log.info("Stopping MLD")
        return self._igmp_mld_control(port, hostIp, 'mld', 'Stop')

    def mld_join_leave(self,port=None,action='join',version=None,hostIp=None,groups=None):
        """
        Mld join or leave for multicast groups

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param action: "join" or "leave". Default value is "join"
        :param version: CHOICES 'v1', 'v2'
        :param hostIp: list of host ip. E.g. ['1001::1', '1002:2']
        :param groups: list of ipv6 multicast groups.

        :Example: mld_join_leave(action='join') \n
                  mld_join_leave(action='leave')
        """
        self.log.info('mld %s' % action)
        return self._igmp_mld_join_leave('mld', port, action, version, hostIp, groups)

    def _pim_stop_start_control(self, port, mode, af, neighbor_ip, groups, action):
        """
        Function used internally by APIs pim_start,pim_stop

        :param port: list of port name. E.g. ['egress1', 'egress2']
        :param mode: PIM Mode , Ex: sm/ssm
        :param af: ipv4,ipv6
        :param neighbor_ip: PIM neighbor ip
        :param groups: list of ipv6 multicast groups.
        :param action: "start" or "stop". Default value is "start"
        """
        self.log.info('PIM {}'.format(action))

        if action.lower() == "start":
            action = 'Start'
        elif action.lower() == "stop":
            action = "Stop"

        if af.lower() == "ipv4":
            af = "Ipv4"
            pimObj = "PimV4Interface"
            joinPruneObj = "PimV4JoinPruneList"
            groupAddress = "GroupV4Address"
        elif af.lower() == "ipv6":
            af = "Ipv6"
            pimObj = "PimV6Interface"
            joinPruneObj = "PimV6JoinPruneList"
            groupAddress = "GroupV6Address"
        try:
            if port == None and neighbor_ip == None and groups == None and mode == None:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().'+action+'(None)')

            if port:
                for portName in port:
                    for topology in self.ixNetwork.Topology.find():
                        if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                            eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + pimObj + '.find().' + action + '(None)')

            if neighbor_ip:
                for ip in neighbor_ip:
                    ipNameList = [address.Name for address in
                                        eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find()') if address]
                    for ipName in ipNameList:
                        address = eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).Address')
                        if ip in address.Values:
                            ipIndex = address.Values.index(ip) + 1
                            eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipName).'+pimObj+'.find().'+action+'(ipIndex)')

            if mode:
                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+pimObj+'.find()'):
                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')
                    if mode.lower() == "sm":
                        mode ="startogroup"
                    elif mode.lower() == "ssm":
                        mode = "sourcetogroup"
                    indices = [index for index in range(0,len(rangeTypeList)) if rangeTypeList[index] == mode]
                    for index in indices:
                        indexVal = index + 1
                        eval('pimInterface.' + action + '(indexVal)')
            if groups:
                for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().'+af+'.find().'+ pimObj + '.find()'):
                    rangeTypeList = eval('pimInterface.'+joinPruneObj+'.RangeType.Values')
                    mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')
                    for rangeType in rangeTypeList:
                        for group in groups:
                            if "*" in group:
                                if rangeType == "startogroup":
                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]
                                    for index in indices:
                                        indexVal = index + 1
                                        eval('pimInterface.'+action+'(indexVal)')
                            else:
                                if rangeType == "sourcetogroup":
                                    indices = [index for index in range(0, len(mcastIpList)) if mcastIpList[index] == group[1]]
                                    for index in indices:
                                        indexVal = index + 1
                                        eval('pimInterface.'+ action + '(indexVal)')
            self.log.info('PIM {} action Success'.format(action))
        except:
            msg = 'PIM {} failed: no entry is matched'.format(action)
            self.log.error(msg)
            raise CafyException.TgenConfigMissingError(msg)
        return True

    def pim_start(self, port=None, mode=None, af="ipv4", neighbor_ip=None, groups=None):
        """
        To start the PIM

        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports
        :param mode: List/String sm or ssm. If None, both modes
        :param af: String ipv4 or ipv6
        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.
            If None, all the neighbors
        :param groups: List of groups. Apply the action to these groups only. If None, all the groups
            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])
        :return: raise exception if there is an error

        :Example: pim_start(port="Ethernet - 001", mode="sm")
        """
        self.log.info("Starting PIM")
        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='start')

    def pim_stop(self, port=None, mode=None, af="ipv4", neighbor_ip=None, groups=None):
        """
        To stop the PIM

        :param port: The name or the string/list of the ports (e.g. 'MyPort1'). If None, all the ports
        :param mode: List/String sm or ssm. If None, both modes
        :param af: String ipv4 or ipv6
        :param neighbor_ip: List/String for neighbor address. Apply the action to the device with this address only.
            If None, all the neighbors
        :param groups: List of groups. Apply the action to these groups only. If None, all the groups
            (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])
        :return: raise exception if there is an error

        :Example: pim_stop(port="Ethernet - 001", mode="sm")
        """
        self.log.info("Stopping PIM")
        return self._pim_stop_start_control(port, mode, af, neighbor_ip, groups, action='stop')

    def pim_join_prune(
            self,
            port=None,
            action='join',
            mode=None,
            af='ipv4',
            neighborIp=None,
            groups=None):
        """
        Send Join/Prune for the specified sparse mode groups.

        :param port: The name string/list of the port (e.g 'MyPort1')
            port handle (e.g <slotID>/<portID>
            interface name from topologyfile
            (e.g <chassisIP>/<slotID>/<portID>)
        :param action:  Join or Prune
        :param mode: PIM Mode , Ex : 'sm','ssm'
        :param af: ipv4 or ipv6
        :param neighborIp: Apply the action to device with this neighbor address only.
        :param groups: Apply the action to these groups only. (e.g [['200.1.1.2','225.0.0.1'], ['*','225.0.1.1'])

        :Example:
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1")
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1",groups=[["*","232.0.0.1"]])
            pim_join_prune("pim_port_1","prune","ssm","ipv4","10.1.1.1",groups=[["*","232.0.0.1"]])
            pim_join_prune("pim_port_1","join","ssm","ipv4","10.1.1.1",groups=[["200.200.200.200","232.0.0.1"]])
            pim_join_prune("pim_port_1","prune","sm","ipv6")
            pim_join_prune("pim_port_1","join","sm","ipv6","10::1",groups=[["*","ff1e::1"]])
            pim_join_prune("pim_port_1","join","sm","ipv6","10::2",groups=[["*","ff1e::1"]])
        """
        self.log.info('PIM action: %s' % (action))
        if action.lower() == "leave" or action.lower() == 'prune':
            action = 'Leave'
        elif action.lower() == "join":
            action = "Join"

        if af.lower() == "ipv4":
            af = "Ipv4"
            HostObj = "PimV4Interface"
            joinPruneObj="PimV4JoinPruneList"
            groupAddress = "GroupV4Address"
            sourceAddress = "SourceV4Address"
        elif af.lower() == "ipv6":
            af = "Ipv6"
            HostObj = "PimV6Interface"
            joinPruneObj = "PimV6JoinPruneList"
            groupAddress = "GroupV6Address"
            sourceAddress = "SourceV6Address"

        if port:
            if isinstance(port, str):
                ports = [port]
            else:
                ports = port
        else:
            ports = [vport.Name for vport in self.ixNetwork.Vport.find()]

        for port in ports:
            port = port.replace("(", "\(").replace(")", "\)")
            vports = self.ixNetwork.Vport.find(Name=port)
            for topology in self.ixNetwork.Topology.find():
                if topology.Vports[0] == vports.href:
                    if groups:
                        for pimInterface in eval('topology.DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):
                            mcastIpList =eval('pimInterface.'+joinPruneObj+'.'+groupAddress+'.Values')
                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')
                            for group in groups:
                                if mode == 'ssm':
                                    sourceList = eval('pimInterface.' + joinPruneObj + '.' + sourceAddress + '.Values')
                                    indices = [index + 1 for index in range(0, len(mcastIpList)) and
                                               range(0,len(sourceList)) if mcastIpList[index] == group[1] and
                                               sourceList[index] == group[0] and rangeTypeList[index] == "sourcetogroup"]
                                else:
                                    indices = [index + 1 for index in range(0, len(mcastIpList)) if
                                               mcastIpList[index] == group[1] and rangeTypeList[index] == "startogroup"]
                                eval('pimInterface.' + joinPruneObj + '.' + action + '(indices)')
                    elif neighborIp:
                        if isinstance(neighborIp, str):
                            neighborIpList = [neighborIp]
                        else:
                            neighborIpList = neighborIp
                        for neighborIp in neighborIpList:
                            for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find()'):
                                addressValues = ipObj.Address.Values
                                if neighborIp in addressValues:
                                    ipIndex = addressValues.index(neighborIp) + 1
                                    eval('topology.DeviceGroup.find().Ethernet.find().'+af+'.find(Name=ipObj.Name).'+HostObj+'.find().'+joinPruneObj+'.'+action+'([ipIndex] )')
                    else:
                        for pimInterface in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + af + '.find().' + HostObj + '.find()'):
                            indexcount = pimInterface.Count
                            rangeTypeList = eval('pimInterface.' + joinPruneObj + '.RangeType.Values')
                            if mode == 'ssm':
                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == "sourcetogroup"]
                            else:
                                indexList = [index+1 for index in range(indexcount) if rangeTypeList[index] == "startogroup"]
                            eval('pimInterface.' + joinPruneObj + '.' + action + '(indexList)')
        return True

    def _get_port_name_list(self, ports):
        """
        Function used internally by APIs

        :param ports: List of ports
        :return: port list
        """
        portList = []
        for port in ports:
            if '.' in port and '/' in port:
                vportObj = self.ixNetwork.Vport.find(AssignedTo='^' + port.replace('/', ':') + '$')
                portList.append(vportObj.Name)
            elif '/' in port:
                assignedList = [vport.AssignedTo for vport in self.ixNetwork.Vport.find()]
                for assigned in assignedList:
                    if re.search(':' + port.replace('/', ':') + '$', assigned):
                        portList.append(self.ixNetwork.Vport.find(AssignedTo='^' + assigned + '$').Name)
            else:
                portList.append(port)
        return portList

    def start_arp(self, ports=None, **kwargs):
        """
        Send arp based on port list, In NGPF ARP is default once IPV4 stack is up, so no need to start_arp again

        :param ports: list of port name or port handle or interface name from Json file.Default is None for all ports
        :return: True

        :Example: start_arp()
                  start_arp(ports = ['10.85.99.38/7/17', '10.85.99.38/7/19'])
                  start_arp(ports = '10.85.99.38/7/17')
        """
        if ports:
            if type(ports) == str:
                ports = [ports]
            for portname in ports:
                if (re.search('\d+.\d+.\d+.\d+/\d+/\d+', portname)):
                    portname = portname.replace("/", ":")
                    vport = self.ixNetwork.Vport.find(AssignedTo='^' + portname + '$')
                else:
                    vport = self.ixNetwork.Vport.find(Name='^'+portname+'$')
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == vport.href:
                        try:
                            for ipv4Obj in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                                objCount = ipv4Obj.Count
                                objCountList = [device for device in range(1, objCount + 1)]
                                ipv4Obj.SendArp(SessionIndices=objCountList)
                        except: pass
                        try:
                            for ipv6Obj in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                                objCount = ipv6Obj.Count
                                objCountList = [device for device in range(1, objCount + 1)]
                                ipv6Obj.SendNs(SessionIndices=objCountList)
                        except: pass
        else:
            try:
                for ipv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find():
                    objCount = ipv4Obj.Count
                    objCountList = [device for device in range(1, objCount + 1)]
                    try:
                        ipv4Obj.SendArp(SessionIndices=objCountList)
                    except:
                        pass
            except: pass
            try:
                for ipv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find():
                    objCount = ipv6Obj.Count
                    objCountList = [device for device in range(1, objCount + 1)]
                    try:
                        ipv6Obj.SendNs(SessionIndices=objCountList)
                    except:
                        pass
            except:pass
        return True

    def send_ping(self, src_ip_address, dest_ip_address, port=None, ip_version="ipv4"):
        """
        Send ping from src_ip_address to dest_ip_address

        :param src_ip_address: string demonstrating the source IP address for ping
        :param dest_ip_address: string demonstrating the destination IP address for ping
        :param port: String showing the port through which the port is sent out in IXIA, if None, the port corresponding to the source IP address is extracted dynamically
        :param ip_version: String representing the IP version, default will be IPv4
        :return: True if the ping is successful, False otherwise

        :Example: send_ping(src_ip_address='103.1.2.2',dest_ip_address='103.1.2.1')
        """
        self.log.info("Sending ping for ip: %s" % dest_ip_address)
        pingStatus = False
        if ip_version.lower() == 'ipv4':
            ipVersion = "Ipv4"
        elif ip_version.lower() == 'ipv6':
            ipVersion = "Ipv6"

        if port:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            if port in vportNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                        for ipObj in eval('topology.DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):
                            ipAddressList = ipObj.Address.Values
                            if src_ip_address in ipAddressList:
                                index = ipAddressList.index(src_ip_address) + 1
                                pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')
                                if pingStatus ==[]:
                                    raise IxiaOperationException("Not able to ping, DeviceGroup not started")
                                else:
                                    pingStatus = pingStatus[0]['arg2']
        else:
            for ipObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().' + ipVersion + '.find()'):
                ipAddressList = ipObj.Address.Values
                if src_ip_address in ipAddressList:
                    index = ipAddressList.index(src_ip_address) + 1
                    pingStatus = eval('ipObj.SendPing(DestIP=dest_ip_address, SessionIndices=index)')
                    if pingStatus == []:
                        raise IxiaOperationException("Not able to ping, DeviceGroup not started")
                    else:
                        pingStatus = pingStatus[0]['arg2']
        if (pingStatus==True):
            self.log.info("Ping success for:%s"  % dest_ip_address)
        else:
            self.log.info("Ping fail for:%s" % dest_ip_address)
        return pingStatus

    def _verifyDhcpClientBind(self, deviceGroupName=None, protocol=None, **kwargs):
        """
        Function used internally by API verify_dhcp_client_bind, get_dhcp_client_bound_count

        :param deviceGroupName: Device Group Name
        :param protocol: Protocol , Ex: IPv4/IPv6
        :param kwargs: optional arguments
        """
        portName = kwargs.get('portName', None)
        if protocol == None:
            protocols = ['ipv4', 'ipv6']
        else:
            protocols = [protocol]
        boundCount = 0
        idleBoundDict = {}
        ibList = []
        for protocol in protocols:
            if portName and deviceGroupName is None:
                # Get all deviceGroups configured with Port
                vportHref = self.ixNetwork.Vport.find(Name=portName).href
                for topology in self.ixNetwork.Topology.find():
                    if topology.Ports[0] == vportHref:
                        deviceList = [deviceGroupName.Name for deviceGroupName in topology.DeviceGroup.find() if deviceGroupName]
            elif deviceGroupName == None:
                # Get all deviceGroups in all topology lists
                deviceList = [deviceGroupName.Name for deviceGroupName in self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
            else:
                deviceList = [deviceGroupName]
            for eachDevice in deviceList:
                ethObjList = self.ixNetwork.Topology.find().DeviceGroup.find(DescriptiveName=eachDevice).Ethernet.find()
                for ethObj in ethObjList:
                    idleDhcpDict = {}
                    boundDhcpDict = {}
                    if protocol == 'ipv6':
                        # raise an exception if no DHCPv6 client
                        try:
                            for dhcpObjName in ethObj.Dhcpv6client.find():
                                dhcpName = dhcpObjName.Name
                                dhcpClientObjDeviceCount = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).Count
                                discoveredAddressList = ethObj.Dhcpv6client.find(DescriptiveName=dhcpName).DiscoveredAddresses
                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]
                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]
                                boundCount += len(boundList)
                                if idleList:
                                    idleDhcpDict[dhcpName] = idleList
                                    ibList.append(["Idle", eachDevice, idleDhcpDict])
                                if boundList:
                                    boundDhcpDict[dhcpName] = boundList
                                    ibList.append(["Bound", eachDevice, boundDhcpDict])
                        except:
                            raise IxiaConfigException("no dhcpv6 client found")
                    else:
                        try:
                            for dhcpObjName in ethObj.Dhcpv4client.find():
                                dhcpName =  dhcpObjName.Name
                                dhcpClientObjDeviceCount = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).Count
                                discoveredAddressList = ethObj.Dhcpv4client.find(DescriptiveName=dhcpName).DiscoveredAddresses
                                idleList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' in discoveredAddressList[count])]
                                boundList = [count + 1 for count in range(dhcpClientObjDeviceCount) if('[Unresolved]' not in discoveredAddressList[count])]
                                if idleList:
                                    idleDhcpDict[dhcpName] = idleList
                                    ibList.append(["Idle", eachDevice, idleDhcpDict])
                                if boundList:
                                    boundDhcpDict[dhcpName] = boundList
                                    ibList.append(["Bound", eachDevice, boundDhcpDict])
                                boundCount += len(boundList)
                        except:
                            raise IxiaConfigException("ERROR: No DHCP V4 Client Found")
        self.log.info(boundCount)
        idleBoundDict['Idle'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Idle', ibList)}
        idleBoundDict['Bound'] = {str(ele[1]): ele[2] for ele in filter(lambda x: x[0] == 'Bound', ibList)}
        idleBoundDict['boundCount'] = boundCount
        return idleBoundDict

    def verify_dhcp_client_bind(self, device, protocol, **kwargs):
        """
        DHCP client bind verifier - check if client received IP from the server.
        :param device: (str): Device Group name, If none passed check for all device group names
        :param protocol: (str): ipv4/ipv6, If none passed check for both ipv4 and ipv6
        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')
        :param expected_blockstate: 'IDLE'/'BOUND'
        :return: Idle and Bound items of deviceGroup in dictionary format. Return Exception when device is not present in config

        :Example: verify_dhcp_client_bind(device="Device Group 23")
        """
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        if protocol.lower() == "ipv4":
            discoveredAddressList = deviceObj.Dhcpv4client.find().DiscoveredAddresses
        elif protocol.lower() == "ipv6":
            discoveredAddressList = deviceObj.Dhcpv6client.find().DiscoveredAddresses
        idleList = [client for client in discoveredAddressList if '[Unresolved]' in client]
        if idleList:
            actual_blockstate = "IDLE"
        else:
            actual_blockstate = "BOUND"
        expected_blockstate = kwargs.get('expected_blockstate', None)
        if expected_blockstate:
            if expected_blockstate.upper() == actual_blockstate:
                log.info('Blockstate of client %s is %s as expected (%s)' \
                         % (device, actual_blockstate, expected_blockstate))
            else:
                err_msg = "Blockstate of client %s is %s. NOT as expected (%s)" \
                          % (device, actual_blockstate, expected_blockstate)
                raise CafyException.VerificationError(err_msg)
        return actual_blockstate

    def get_dhcp_client_bound_count(self, device=None, protocol=None, **kwargs):
        """"
        To retrieve number of DHCP sessions currently bound to the interface/device

        :param device: Device Group name, If none passed check for all device group names
        :param protocol: ipv4/ipv6, If none passed check for both ipv4 and ipv6
        :param kwargs: port_name (str): IXIA-name of port to which device is affiliated(Ex: '1/2/9')
        :return: Number of sessions Bound. Return Exception when device is not present in config

        :Example: get_dhcp_client_bound_count()
        """
        self.log.info("Getting DHCP Client Bound Count")
        if 'port_name' in kwargs:
            kwargs['portName'] = kwargs['port_name']
        boundDict = self._verifyDhcpClientBind(deviceGroupName=device, protocol=protocol, **kwargs)
        return boundDict['boundCount'],boundDict['boundCount']

    def verify_arp(self,ports=(), ip_type='ipv4'):
        """
        This method requires:  _device_group_protocolstack_ngpf()
        It will verify for ARP session resolvement on
        every Device Group including inner Device Groups.

        How it works?
        Each device group has a list of $sessionStatus: up, down or notStarted.
        If the deviceGroup has sessionStatus as "up", then ARP will be verified.
        It also has a list of $resolved_gateway_mac: MacAddress or removePacket
        [Unresolved]
        These two $sessionStatus and $resolved_gateway_mac lists are aligned.
        If lindex 0 on $sessionSatus is up, then $resolved_gateway_mac on index 0 expects
        to have a mac address.  Not removePacket[Unresolved].
        If not, then arp is not resolved.

        :param ports: port or list of ports
        :param ip_type: default is ipv4
        :return: 0 if ARP passes, 1 if device group is not started
                Returns a list of unresolved ARPs (src ip)

        :Example: verify_arp()
        """

        self.log.info("Arp Verification on All interfaces")
        unresolvedArpList = []
        gatewayIpList = []
        timeout = 25
        start_flag = 0
        for deviceGroupObj in (self.ixNetwork.Topology.find().DeviceGroup.find()):
            for counter in range(1, 30):
                if deviceGroupObj.Status in ['started', 'mixed']:
                    start_flag = 1
                    break
                elif (counter >= timeout and deviceGroupObj.Status not in ['started', 'mixed']):
                    raise IxiaConfigException('\nDevice Group failed to come up: {0}.'.format(deviceGroupObj.href))
        if (ip_type.lower() == 'ipv6'):
            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find()):
                for index, eachState in enumerate(ipObj.SessionStatus):
                    if eachState != "up":
                        unresolvedArpList.append(ipObj.Address.Values[index])
                        gatewayIpList.append(ipObj.GatewayIp.Values[index])
            try:
                for ipObj in ([x for x in self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv6.find() if x]):
                    for index, eachState in enumerate(ipObj.SessionStatus):
                        if eachState != "up":
                            unresolvedArpList.append(ipObj.Address.Values[index])
                            gatewayIpList.append(ipObj.GatewayIp.Values[index])
            except:
                pass
        else:
            for ipObj in (self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):
                for index, eachState in enumerate(ipObj.SessionStatus):
                    if eachState != "up":
                        unresolvedArpList.append(ipObj.Address.Values[index])
                        gatewayIpList.append(ipObj.GatewayIp.Values[index])
            try:
                for ipObj in (
                        self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().Ethernet.find().Ipv4.find()):
                    for index, eachState in enumerate(ipObj.SessionStatus):
                        if eachState != "up":
                            unresolvedArpList.append(ipObj.Address.Values[index])
                            gatewayIpList.append(ipObj.GatewayIp.Values[index])
            except:
                pass
        if unresolvedArpList == [] and start_flag == 1:
            self.log.info('\tARP is resolved')
            return 0
        if unresolvedArpList != [] and start_flag == 0:
            self.log.info('Device Group not started')
            return 1
        if unresolvedArpList != [] and start_flag == 1:
            raise IxiaConfigException("\nFailed to resolve ARP: srcIp: {0} gateway: {1}".format(unresolvedArpList, gatewayIpList))
        return unresolvedArpList

    def neighbor_discovery(self, *args):
        """
        neighbor discovery for IPv6

        :Example: neighbor_discovery()
        """
        if len(args):
            self.log.debug("unused options %s" % args)
        self.verify_arp(ip_type='ipv6')

    def change_traffic_frame_size(self, cfg_dict, traffic_item_list=None, **kwargs):
        """
        This API is used for changing traffic item frame size.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                type: auto, fixed, increment, random, weightedPairs, presetDistribution,
                quadGaussian\n
                fixedSize: frame size for type of fixed\n
                more options see: <IP of IxNetwork>:25445/api/v1/meta
        :param kwargs :
                dynamic_frame_size : True/False dynamic frame size , Frame size to be set on the fly
                                    supported frame type is "fixed" and "random
        :return: True or Exception

        :Example: change_traffic_frame_size(cfg_dict={'type': 'presetDistribution', 'presetDistribution': 'cisco'})
                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'random','fixedSize': '10'})
                  change_traffic_frame_size(dynamic_frame_size=True,cfg_dict={'type': 'fixed', 'fixedSize': '100'},traffic_item_list=['Traffic ipv4'])
        """
        self.log.info("Changing Traffic Frame Size")
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        frame_size_dict = {'type': 'Type', 'fixedSize': 'FixedSize', 'incrementFrom': 'IncrementFrom',
                         'incrementTo': 'IncrementTo', 'incrementStep': 'IncrementStep',
                         'presetDistribution': 'PresetDistribution', 'weightedPairs': 'WeightedPairs',
                         'randomMax': 'RandomMax', 'randomMin': 'RandomMin',
                         'weightedRangePairs': 'WeightedRangePairs'}

        for traffic_name in traffic_item_list:
            traffic_name = '^' + traffic_name.replace('+', '\+').replace('*', '\*') + '$'
            if kwargs.get('dynamic_frame_size'):
                for trafficitemname in self.ixNetwork.Traffic.DynamicFrameSize.find(TrafficItemName=traffic_name):
                    for key in cfg_dict:
                        setattr(trafficitemname, frame_size_dict[key], cfg_dict[key])
            else:
                if 'weightedPairs' in cfg_dict.keys():
                    if ':' in str(cfg_dict['weightedPairs'][0]):
                        wp_tmp = []
                        for i in cfg_dict['weightedPairs']:
                            wp_tmp.append(int(i.split(':')[0]))
                            wp_tmp.append(int(i.split(':')[1]))
                        cfg_dict['weightedPairs'] = wp_tmp

                for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_name):
                    Streams = traffic.ConfigElement.find()
                    for Stream in Streams:
                        for frameSize in Stream.FrameSize:
                            for key in cfg_dict:
                                setattr(frameSize, frame_size_dict[key], cfg_dict[key])
        self.log.info("Frame Size in Traffic Items Updated")
        return True

    def change_traffic_rate(self, cfg_dict, traffic_item_list=None, **kwargs):
        """
        Changes the rate of traffic.

        :param cfg_dict: Dict including the data need to be modified
                   type: 'bitsPerSecond','kilobitsPerSecond','megabitsPerSecond','framesPerSecond','percentLineRate'
                   rate: The rate at which packet is transmitted.
                Example: percent Line Rate: cfg_dict = {'type':'percentLineRate','rate':25.0}
                         frame Per Second: cfg_dict = {'type':'framesPerSecond','rate':200000.0}
        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param kwargs :
                dynamic_traffic_rate : True/False dynamic traffic rate to be set on the fly
        :return: True on success else raises exception.

        :Example:
            change_traffic_rate(cfg_dict={'type': 'megabitsPerSecond', 'rate': 20}, traffic_item_list=['Traffic Item 1'])\n
            change_traffic_rate(cfg_dict = {'type':'framesPerSecond','rate':200.0})
            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type':'percentLineRate','rate':10},
            change_traffic_rate(dynamic_traffic_rate=True, cfg_dict={'type': 'megabitsPerSecond', 'rate': 20})
        """
        self.log.info("Changing Traffic Rate")

        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        rateTypeDict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',
                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',
                        'percentLineRate': 'lineRate'}

        for traffic_name in traffic_item_list:
            traffic_name = '^' + traffic_name.replace('+', '\+').replace('*', '\*') + '$'

            if cfg_dict.get('type') in rateTypeDict.keys():
                
                if kwargs.get('dynamic_traffic_rate'):
                    for trafficitemname in self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name):
                        if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:
                            trafficitemname.RateType = 'bitsPerSecond'
                            trafficitemname.BitRateUnitsType = rateTypeDict[cfg_dict['type']]
                        else:
                            trafficitemname.RateType = cfg_dict['type']
                        trafficitemname.Rate = cfg_dict.get('rate', None)
                else:
                    for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_name + '$'):
                        Streams = traffic.ConfigElement.find()
                        for Stream in Streams:
                            for frameRate in Stream.FrameRate:
                                if cfg_dict['type'] in ['bitsPerSecond', 'megabitsPerSecond', 'kilobitsPerSecond']:
                                    frameRate.Type = 'bitsPerSecond'
                                    frameRate.BitRateUnitsType = rateTypeDict[cfg_dict['type']]
                                else:
                                    frameRate.Type = cfg_dict['type']
                                frameRate.Rate = cfg_dict.get('rate', None)
                self.log.info("Traffic Rate For Traffic Items Updated")
            else:
                log.error('Unknown/Unsupported rate type.')
                raise CafyException.InvalidValueError('Unknown/Unsupported rate type provided in change_traffic_rate')
        return True

    def set_traffic_mpls_exp_bits(self, exp_value, traffic_item_list=None):
        """
        Sets the MPLS headers Experimental Bits (bits) field to the specified value

        :param exp_value: The exp bit field value to be used. Accepted values are 0-7
            e.g. exp_bit_value=4 or [1,4,6]
        :param traffic_item_list: A list of streamblocks to be modified. If None,
            set exp_bit_value for all streamblocks.
        :return: True if no exceptions were thrown

        :Example: set_traffic_mpls_exp_bits(exp_value = 1, traffic_item_list=["Traffic Item 2"])
                  set_traffic_mpls_exp_bits(exp_value = [1,2,3], traffic_item_list=["Traffic Item 2"])
        """
        self.log.info("Setting MPLS EXP Bits in Traffic Item/Items")
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                    try:
                        if type(exp_value) is not list:
                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                            fieldValue.ValueType = 'singleValue'
                            fieldValue.SingleValue = exp_value
                        if type(exp_value) is list:
                            fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                            fieldValue.ValueType = 'valueList'
                            fieldValue.ValueList = exp_value
                    except:
                        pass
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if type(exp_value) is not list:
                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                        fieldValue.ValueType = 'singleValue'
                        fieldValue.SingleValue = exp_value
                    if type(exp_value) is list:
                        fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='mpls_exp')
                        fieldValue.ValueType = 'valueList'
                        fieldValue.ValueList = exp_value
                except:
                    pass
        return True

    def get_traffic_mpls_exp_bits(self, traffic_item_list=None):
        """
        Gets the value of the MPLS headers exp field for the specified traffic items

        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.
        :return: A list of results containing the exp field value for the specified streams

        :Example: get_traffic_mpls_exp_bits(traffic_item_list=["Traffic Item 2"])
        """

        self.log.info("Getting MPLS EXP Bits For Traffic Items")
        results = []
        if traffic_item_list:
            for trafficName in traffic_item_list:
                try:
                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(
                        StackTypeId='mpls').Field.find(Name='mpls_exp'):
                        results.append(fieldValue.SingleValue)
                except:
                    self.log.info("MPLS Stack Not Available in %s" % trafficName)
                    raise IxiaOperationException("MPLS Stack Not Available in %s" % trafficName)
        else:
            try:
                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(
                            StackTypeId='mpls').Field.find(Name='mpls_exp'):
                    results.append(fieldValue.SingleValue)
            except:pass
        return results

    def change_vlan_priority(self, device_name, vlan_number, priority=7):
        """
        Change VLAN priority on a device group

        :param device_name: Name of device group on which VLAN Priority need to be changed
        :param vlan_number:  VLAN Number on which priority needs to be changed.
        :param priority: Range 0 to 7. Default is 7

        :Example: change_vlan_priority(device_name='Device Group 13' , vlan_number=10, priority=4)
        """
        self.log.info("Changing VLAN Priority for Vlan {0} in {1}".format(vlan_number,device_name))
        try:
            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values
        except:
            raise IxiaOperationException("Device Group not Found")
        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().Priority.Values
        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
        if indexList:
            for index in indexList:
                priorityList.pop(index)
                priorityList.insert(index, str(priority))

            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():
                vlan.Priority.ValueList(values=priorityList)
            self.log.info("VLAN Priority Changed for Vlan {0} in {1}".format(vlan_number,device_name))
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("VLAN Number not Found")

    def change_traffic_flow_tracking(self, cfg_dict, traffic_item_list=None):
        """
        This API is used for changing traffic item flow tracking.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                trackBy: []\n
                availableTrackBy: ['customOverride', 'sourceDestValuePair0',
                'ethernetIiSourceaddress0', 'sourcePort0', 'sourceDestPortPair0',
                'intendedRxPorts0', 'sourceDestEndpointPair0', 'flowGroup0',
                'mplsFlowDescriptor0', 'ethernetIiEtherType0', 'trackingenabled0',
                'trafficGroupId0', 'ipv4Precedence0', 'smFlowDescriptor0',
                'sourceEndpoint0', 'destEndpoint0', 'ethernetIiPfcQueue0',
                'avbStreamName0', 'ipv4DestIp0', 'frameSize0', 'destSessionDescription0',
                'ipv4SourceIp0', 'ethernetIiDestinationaddress0']\n
                more options see: <IP of IxNetwork>:25445/api/v1/meta

        :Example: change_traffic_flow_tracking(cfg_dict = {'trackBy':['ipv4SourceIp0','sourcePort0']},traffic_item_list =['Traffic Item 2'])
        """

        self.log.info("Changing Traffic Flow Tracking")
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():
                    tracking.TrackBy = cfg_dict['trackBy']
        else:
            for traffic in self.ixNetwork.Traffic.TrafficItem.find():
                for tracking in traffic.Tracking.find():
                    tracking.TrackBy = cfg_dict['trackBy']

        self.log.info("Flow Tracking Updated for Traffic Items")

    def change_traffic_egress_tracking(self, cfg_dict, traffic_item_list=None):
        """
        This API is used for changing traffic item egress tracking.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :param cfg_dict: Dict including the data need to be modified\n
                enabled: True or False

                availableEncapsulations: ['Any: Use Custom Settings', 'Ethernet',
                'LLC/Snap Routed Protocol', 'LLC Encapsulated PPP',
                'LLC Bridged Ethernet/802.3', 'LLC Bridged Ethernet/802.3 no FCS',
                'VC Multiplexed PPP', 'VC Mux Routed Protocol',
                'VC Mux Bridged Ethernet/802.3', 'VC Mux Bridged Ethernet/802.3 no FCS',
                'PPP', 'CISCO HDLC', 'Frame Relay', 'Cisco Frame Relay']

                availableOffsets: ['Outer VLAN Priority (3 bits)', 'Outer VLAN ID (4 bits)',
                'Outer VLAN ID (6 bits)', 'Outer VLAN ID (8 bits)',
                'Outer VLAN ID (10 bits)', 'Outer VLAN ID (12 bits)',
                'Inner VLAN Priority (3 bits)', 'Inner VLAN ID (4 bits)',
                'Inner VLAN ID (6 bits)', 'Inner VLAN ID (8 bits)',
                'Inner VLAN ID (10 bits)', 'Inner VLAN ID (12 bits)',
                'VNTag Direction Bit (1 bit)', 'VNTag Pointer Bit (1 bit)',
                'VNTag Looped Bit (1 bit)', 'MPLS Exp (3 bits)',
                'IPv4 TOS Precedence (3 bits)', 'IPv4 DSCP (6 bits)',
                'IPv6 Traffic Class (8 bits)', 'IPv6 Traffic Class Bits 0-2 (3 bits)',
                'IPv6 Traffic Class Bits 0-5 (6 bits) ']

        :Example: change_traffic_egress_tracking(cfg_dict={'enabled': True, 'encapsulation': 'Ethernet'})
        """
        self.log.info("Changing Traffic Egress Tracking")
        if traffic_item_list:
            for trafficName in traffic_item_list:
                for tracking in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).Tracking.find():
                    tracking.Egress.Enabled = cfg_dict.get('enabled', True)
                    tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)
                    tracking.Egress.Offset = cfg_dict.get('offset', None)
        else:
            for tracking in self.ixNetwork.Traffic.TrafficItem.find().Tracking.find():
                tracking.Egress.Enabled = cfg_dict.get('enabled', True)
                tracking.Egress.Encapsulation = cfg_dict.get('encapsulation', None)
                tracking.Egress.Offset = cfg_dict.get('offset', None)
        self.log.info("Egress Tracking Updated for Traffic Items")

    def get_port_name_from_location(self, location):
        """
        Get name of port in config based on location

        :param location: port (str) location in chassis/card/port format.
         Ex: location="172.29.126.16/5/7"
        :return: Name of the port

        :Example: get_port_name_from_location(location = "172.29.126.16/5/7")
        """
        self.log.info("Getting Port Name from Location")
        for vport in self.ixNetwork.Vport.find():
            locationUpdated = location.replace("/", ":")
            if vport.AssignedTo == locationUpdated:
                return vport.Name

        raise IxiaConfigException("No Port found for location : '%s' " % location)

    def set_chassis_mode(self):
        """
        Designates a chassis with a given IP as either the master or a slave
        for a given IXIA config
        :return: True if successful

        :Example: set_chassis_mode()
        """
        self.log.info("Setting Chassis Mode")
        for chassis in self.ixNetwork.AvailableHardware.Chassis.find():
            if chassis.Ip == self.chassis_ip:
                chassis.IsMaster = True
            else:
                chassis.IsMaster = False
                chassis.MasterChassis = self.chassis_ip
        return True

    def _bgp_neighbor_control(self, bgp_peer_name_list, local_ip_list, ip_type, action):
        """
        Function used internally by APIs bgp_start and bgp_stop

        :param bgp_peer_name_list: BGP Peer Name list
        :param local_ip_list: BGP Local IP list
        :param ip_type: IP type , IPv4/IPv6
        :param action: Action, "start/stop"
        """
        self.log.info("BGP action {}".format(action))
        if ip_type not in ['ipv4', 'v4', 'ipv6', 'v6']:
            msg = 'ip_type %s can only be ipv4 or ipv6' % ip_type
            raise IxiaOperationException(msg)
        for bgpPeerName in bgp_peer_name_list:
            bgpPeerName = '^' + bgpPeerName.replace('+', '\+').replace('*', '\*') + '$'
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(Name="' + bgpPeerName + '").' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(Name="' + bgpPeerName + '").' + action + '(None)')
            except:
                pass
        for localIp in local_ip_list:
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find(LocalIpv4Ver2="' + localIp + '").' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find(LocalIpv6Ver2="' + localIp + '").' + action + '(None)')
            except:
                pass
        if bgp_peer_name_list == [] and local_ip_list == []:
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().BgpIpv6Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv4Loopback.find().BgpIpv4Peer.find().' + action + '(None)')
            except:
                pass
            try:
                eval('self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().Ipv6Loopback.find().BgpIpv6Peer.find().' + action + '(None)')
            except:
                pass
        return True

    def bgp_start(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):
        """
        Start bgp emulation

        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type
        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.
        :param ip_type: ipv4 or ipv6, default set to ipv4
        :return: raise exception if False/error

        :Example: bgp_start(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"], local_ip_list=["103.1.1.2","103.1.1.1"])
        """
        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action="Start")

    def bgp_stop(self, bgp_peer_name_list=[], local_ip_list=[], ip_type='v4'):
        """
        Stop bgp emulation

        :param bgp_peer_name_list: List of bgp peer. If 'None', all the peer of certain ip type
        :param local_ip_list: List of ip intf has bgp configured. If 'None', take action on all the intf in the peer. If mismatch between IP and peer, the IP_list will be ignored, take action on the given peer only.
        :param ip_type: ipv4 or ipv6, default set to ipv4
        :return: raise exception if False/error

        :Example: bgp_stop(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"], local_ip_list=["103.1.1.2","103.1.1.1"])
        """
        return self._bgp_neighbor_control(bgp_peer_name_list, local_ip_list, ip_type, action="Stop")

    def link_up_down(self, port, action='up'):
        """
        Flap a port Up and Down

        :param port: list of port names\n
                Example : port = ['10.30.20.140/1/5','10.30.20.140/1/6']\n
                Example : port = ['Ethernet 01' , Ethernet 02']
        :param action: CHOICES up, down
        :return: True

        :Example: link_up_down(port=["Ethernet - 001", "Ethernet - 002"], action='down')
        """
        self.log.info("Simulation Link :%s" % (action))
        action = action.lower()
        for eachPort in port:
            if (re.search('\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                eachPort = eachPort.replace("/", ":")
                for vport in self.ixNetwork.Vport.find(AssignedTo = eachPort):
                    vport.LinkUpDn(action)
                    time.sleep(30)
                for vport in self.ixNetwork.Vport.find(AssignedTo=eachPort):
                    if vport.State != action:
                        msg = 'Port "%s" Link "%s" Simulatin not Successful' % (eachPort, action)
                        self.log.info(msg)

            else:
                for vport in self.ixNetwork.Vport.find(Name=eachPort):
                    vport.LinkUpDn(action)
                    time.sleep(30)
                for vport in self.ixNetwork.Vport.find(Name=eachPort):
                    if vport.State != action:
                        msg = 'Port "%s" Link "%s" Simulation Failed' % (eachPort,action)
                        self.log.info(msg)
        return True

    def release_ports(self, port_list=None):
        """
        Release ports

        :param port_list: list of port names\n
               port_list can be port_list = ['10.30.20.140/1/5','10.30.20.140/1/6']
               port_list = ['Ethernet 01' , Ethernet 02']\n
               port_list = [[ixChassisIp, 1, 2], [ixChassisIp, 1, 3], ...]
        :return: True

        :Example: release_ports(port_list=['10.30.20.140/1/5','10.30.20.140/1/6'])
        """
        self.log.info("Releasing Ports")
        if port_list is None:
            try:
                ports = self.ixNetwork.Vport.find()
                ports.ResetPortCpuAndFactoryDefault()
                time.sleep(5)
                ports.ReleasePort()
            except:
                pass
        else:
            vportNames = []
            for port in port_list:
                regexString = ''
                if isinstance(port, list):
                    # Construct the regex string format = '(1.1.1.1:2:3)'
                    regexString = regexString + '(' + str(port[0]) + ':' + str(port[1]) + ':' + str(port[2]) + ')'
                elif isinstance(port, str):
                    if '.' in port:
                        regexString = port.replace('/',':')
                    else:
                        try:
                            regexString = self.ixNetwork.Vport.find(Name=port).AssignedTo
                        except:
                            raise IxiaConfigException("Port not configured or Failed to release")
                vport = self.ixNetwork.Vport.find(AssignedTo=regexString)
                if vport:
                    vportNames.append(vport.Name)
                    self.log.info('\nReleasing port: {0}:{1}'.format(port, vport.href))
                    vport.ResetPortCpuAndFactoryDefault()
                    time.sleep(5)
                    vport.ReleasePort()
                    time.sleep(5)
            for vport in self.ixNetwork.Vport.find():
                if vport.ConnectionStatus != 'Port Released':
                    msg = 'Release Port "%s" not Successful' % (vport.Name)
                    raise IxiaOperationException(msg)
        return True

    def verify_arp_status(self, ipType='ipv4', device=None):
        """
        verifies the ARP status of all device groups on the TGN session

        :param ipType: IP type , ipv4/ipv6
        :param device: Device Group name
        :return: True or Exception

        :Example: verify_arp_status(ipType='ipv6', device='Device Group 3')
        """
        self.log.info("Verification of Arp Started")
        if isinstance(device, str):
            device = [device]
        unresolvedArpList = []
        gatewayIpList = []
        timeout = 20
        if device:
            device_obj_list = list(map(lambda device_obj: device_obj if device_obj.Name in device else None,
                                    self.ixNetwork.Topology.find().DeviceGroup.find()))
            device_obj_list = list(filter(None, device_obj_list))
        else:
            topology = self.ixNetwork.Topology.find()
            with BatchFind(topology) as device_group:
                self.ixNetwork.Topology.find().DeviceGroup.find()
            device_obj_list = getattr(device_group.results, 'deviceGroup')

        if device_obj_list:
            for device_obj in device_obj_list:
                for counter in range(0, timeout, 2):
                    if device_obj.Status == 'notStarted':
                        msg = f'\n Device Group {device_obj.Name} is not started'
                        raise IxiaOperationException(msg)
                    if counter < timeout and device_obj.Status == 'starting':
                        time.sleep(2)
                        continue
                    if counter < timeout and device_obj.Status in ['started', 'mixed']:
                        break
                    if counter == timeout and device_obj.Status not in ['started', 'mixed']:
                        msg = f'\n Device Group failed to come up: {device_obj.href}'
                        raise IxiaOperationException(msg)

            for device_obj in device_obj_list:
                with BatchFind(device_obj) as ip_obj_list:
                    eval('device_obj.Ethernet.find().' + ipType[0].upper()+ipType[1:] + '.' + 'find()')
                try:
                    ip_obj_list = getattr(ip_obj_list.results, ipType)
                except:
                    ip_obj_list = []
                    self.log.info(f'{ipType} block is not configured in device {device_obj.Name}')

                for ip_obj in ip_obj_list:
                    for index, each_state in enumerate(ip_obj.SessionStatus):
                        if each_state != "up":
                            unresolvedArpList.append(ip_obj.Address.Values[index])
                            gatewayIpList.append(ip_obj.GatewayIp.Values[index])
        else:
            msg = f'\n Device Group "{device}" not found'
            raise IxiaOperationException(msg)

        if unresolvedArpList:
            self.log.info(f"\n Failed to Resolve ARP: srcIp: {unresolvedArpList} gateway: {gatewayIpList}")
            return False
        self.log.info("Arp Verification Successful")
        return True

    def start_arp_and_verify(self):
        """
        starts the ARP and verifies the ARP status

        :return: true if successful else false if verify fails or exception in case error occurs

        :Example: start_arp_and_verify()
        """
        result_list = []
        topology = self.ixNetwork.Topology.find()
        with BatchFind(topology) as device_group:
            topology.DeviceGroup.find()

        device_obj_list = getattr(device_group.results, "deviceGroup")
        try:
            for device_obj in device_obj_list:
                self.log.info(f'Starting Arp on: {device_obj.Name}')
                if device_obj.Ethernet.find().Ipv4.find():
                    for ipv4_obj in device_obj.Ethernet.find().Ipv4.find():
                        obj_count_list = list(range(1, ipv4_obj.Count + 1, 1))
                        ipv4_obj.SendArp(SessionIndices=obj_count_list)
                        result_list.append(self.verify_arp_status(device=device_obj.Name))
                else:
                    self.log.info(f'IPv4 block not found in {device_obj.Name}')
        except:
            self.log.error(f'Device Group {device_obj.Name} is not started')

        if not False in result_list:
            result = True
        else:
            result = False
        return result

    def bgp_ngp_flap(self, bgp_peer_name_list, action='True', up_time_in_sec=0, down_time_in_sec=0):
        """
        Enable/disable flapping on all the BGP interfaces.

        :param bgp_peer_name_list: BGP peer name List
        :param action: string format. Not boolean
               'True' = enable BGP flap
               'False' = disable BGP flap
        :param up_time_in_sec: Up Time In Seconds.
        :param down_time_in_sec: Down Time In Seconds.
        :return: True on success else raise exception.

        :Example: bgp_ngp_flap(bgp_peer_name_list=["BGP Peer 1","BGP Peer 2"])
        """

        self.log.info('BGP Neighbor Flapping for %s' % bgp_peer_name_list)
        if not type(bgp_peer_name_list) == list:
            msg = 'bgp_peer_name_list type can not be %s. It should be a list' \
                        % type(bgp_peer_name_list)
            raise IxiaConfigException(msg)
        for bgpPeerName in bgp_peer_name_list:
            for version in ['v4', 'v6']:
                try:
                    peerNameList = [bgpObj.Name for bgpObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find()')]
                except:
                    pass
                for peerName in peerNameList:
                    if peerName == bgpPeerName:
                        peerName = '^' + bgpPeerName + '$'
                        if '+' or '*' in peerName:
                            peerName = peerName.replace('+', '\+').replace('*', '\*')
                        try:
                            for bgpPeerObj in eval('self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ip'+version+'.find().BgpIp'+version+'Peer.find(DescriptiveName=peerName)'):
                                bgpPeerObj.Flap.Single(action)
                                bgpPeerObj.UptimeInSec.Single(up_time_in_sec)
                                bgpPeerObj.DowntimeInSec.Single(down_time_in_sec)
                        except:
                            pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def igmp_active_deactive(self, **kwargs):
        """
        Igmp active or deactive for multicast groups

        :param kwargs: optional arguments

        :Example: igmp_active_deactive(port=["Ethernet - 001", "Ethernet - 002"], hostIp=["105.1.1.2","105.1.2.2"],action=False)
        """
        kwargs['ports'] = kwargs.get('ports', None)
        kwargs['hostIp'] = kwargs.get('hostIp', None)
        kwargs['groups'] = kwargs.get('groups', None)
        kwargs['action'] = kwargs.get('action', True)

        if ('ports' in kwargs and kwargs['ports'] == None) and ('hostIp' in kwargs and kwargs['hostIp'] == None ) \
                and ('groups' in kwargs and kwargs['groups'] == None):
           for igmpMcastObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.\
                   find().IgmpMcastIPv4GroupList:
               igmpMcastObj.Active.Single(str(kwargs['action']).lower())

        if 'ports' in kwargs and kwargs['ports'] is not None:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in kwargs['ports'] if portName in vportNameList]
            for portName in portNameList:
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for ipv4 in topologyObj.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            for igmpHost in ipv4.IgmpHost.find():
                                if re.match(topologyObj + '/deviceGroup', igmpHost.href):
                                    for igmpObj in ipv4.IgmpHost.find(DescriptiveName=igmpHost.DescriptiveName).IgmpMcastIPv4GroupList:
                                        igmpObj.Active.Single(str(kwargs['action']).lower())

        if 'hostIp' in kwargs and kwargs['hostIp'] is not None:
            for ip in kwargs['hostIp']:
                ipNameList = [address.Name for address in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find() if address]
                for ipName in ipNameList:
                    address = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).Address
                    if ip in address.Values:
                        ipIndex = address.Values.index(ip)
                        valuesList = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active.Values
                        valuesList[ipIndex] = str(kwargs['action']).lower()
                        igmpMcastObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find(Name=ipName).IgmpHost.find().IgmpMcastIPv4GroupList.Active
                        igmpMcastObj.ValueList(values=valuesList)

        if 'groups' in kwargs and kwargs['groups'] is not None:
            for igmpMcast in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList:
                multicastIpList = igmpMcast.StartMcastAddr.Values
                for group in kwargs['groups']:
                    if group[1] in multicastIpList:
                        indices = [index for index in range(0, len(multicastIpList)) if multicastIpList[index] == group[1]]
                        for index in indices:
                            valuesList = igmpMcast.Active.Values
                            valuesList[index] = str(kwargs['action']).lower()
                            igmpMcastObj = igmpMcast.Active
                            igmpUcastObj = igmpMcast.IgmpUcastIPv4SourceList.Active
                            if "*" in group:
                                igmpMcastObj.ValueList(values=valuesList)
                            else:
                                igmpMcastObj.ValueList(values=valuesList)
                                igmpUcastObj.ValueList(values=valuesList)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _update_bgp_flap_values(self,bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime):
        """
        Internal API used by bgp_routes_flap

        :param bgpRoutePropertyObj: bgpRoutePropertyObj
        :param ipv4PrefixPoolObj: ipv4PrefixPoolObj
        :param address: address
        :param action: action
        :param uptime: uptime
        :param downtime: downtime
        :return:
        """
        if address in ipv4PrefixPoolObj.NetworkAddress.Values:
            addressIndex = (ipv4PrefixPoolObj.NetworkAddress.Values).index(address)
            enableFlappingValues = bgpRoutePropertyObj.EnableFlapping.Values
            enableFlappingValues[addressIndex] = str(action).lower()
            bgpRoutePropertyObj.EnableFlapping.ValueList(enableFlappingValues)
            UptimeValues = bgpRoutePropertyObj.Uptime.Values
            UptimeValues[addressIndex] = uptime
            bgpRoutePropertyObj.Uptime.ValueList(UptimeValues)
            DowntimeValues = bgpRoutePropertyObj.Downtime.Values
            DowntimeValues[addressIndex] = downtime
            bgpRoutePropertyObj.Downtime.ValueList(DowntimeValues)

    def bgp_routes_flap(self, port_list=None, IP_type='ipv4', action='False', uptime=0, downtime=0, address_list=None, **kwargs):
        """
        Enable/disable BGP routes flapping based on port_list and last_address_list

        :param port_list: list of port name. Default is None
        :param IP_type: 'ipv4' or 'ipv6'
        :param action: 'true' or 'false'
        :param uptime: uptime in seconds. Default is 0
        :param downtime: downtime in seconds. Default is 0
        :param address_list: list for start network address. Default is None
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                       For IXIA, device_list list of devices
        :return: True on success else raises exception

        :Example: bgp_routes_flap(port_list=['Ethernet - 001'],action='true',uptime=0,downtime=0)
                  bgp_routes_flap(port_list=["Ethernet - 002"], IP_type='ipv6', action='True', address_list=["1001::1"])
                  bgp_routes_flap(device_list=["Device 1"],address_list=["10.1.1.1"], IP_type='ipv4', action='True', uptime=5, downtime=5)
        """
        self.log.info('BGP Route Flapping')
        device_list = kwargs.get('device_list',None)
        if (device_list and address_list and port_list == None) or (device_list and port_list and address_list):
            for device in device_list:
                for address in address_list:
                    if IP_type.lower() == "ipv4":
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():
                            for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                                if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv4PrefixPoolObj,address,action,uptime,downtime)
                    if IP_type.lower() == "ipv6":
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find( Name='^' + device + '$').NetworkGroup.find():
                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj,ipv6PrefixPoolObj,address,action,uptime,downtime)
                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                    self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
        if (device_list and address_list == None and port_list == None):
            for device in device_list:
                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$').NetworkGroup.find():
                        if IP_type.lower() == "ipv4":
                            for bgpIpRoute in networkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        if IP_type.lower() == "ipv6":
                            for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                    bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                bgpRoutePropertyObj.Uptime.Single(uptime)
                                bgpRoutePropertyObj.Downtime.Single(downtime)
        if (device_list == None and port_list and address_list) or (device_list == None and port_list == None and address_list):
            for address in address_list:
                if IP_type.lower() == "ipv4":
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                        for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                            if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv4PrefixPoolObj, address, action, uptime, downtime)
                if IP_type.lower() == "ipv6":
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                        for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                            if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
                            if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                self._update_bgp_flap_values(bgpRoutePropertyObj, ipv6PrefixPoolObj, address, action, uptime, downtime)
        if (port_list and device_list == None and address_list == None):
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            portNameList = [portName for portName in port_list if portName in vportNameList]
            for portName in portNameList:
                portName = '^' + portName.replace('/', '\/').replace('(', '\(').replace(')', '\)') + '$'
                for topology in self.ixNetwork.Topology.find():
                    if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                        topologyObj = topology.href
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                            if IP_type.lower() == "ipv4":
                                for ipv4PrefixPoolObj in networkGroup.Ipv4PrefixPools.find():
                                    if ipv4PrefixPoolObj.BgpIPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv4PrefixPoolObj.BgpIPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
                            else:
                                for ipv6PrefixPoolObj in networkGroup.Ipv6PrefixPools.find():
                                    if ipv6PrefixPoolObj.BgpV6IPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpV6IPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
                                    if ipv6PrefixPoolObj.BgpIPRouteProperty.find():
                                        bgpRoutePropertyObj = ipv6PrefixPoolObj.BgpIPRouteProperty.find()
                                        if re.match(topologyObj + '/deviceGroup', bgpRoutePropertyObj.href):
                                            bgpRoutePropertyObj.EnableFlapping.Single(str(action).lower())
                                            bgpRoutePropertyObj.Uptime.Single(uptime)
                                            bgpRoutePropertyObj.Downtime.Single(downtime)
        if (port_list == None and address_list== None and device_list ==None):
            for device in self.ixNetwork.Topology.find().DeviceGroup.find():
                for group in device.find().NetworkGroup.find():
                    if IP_type.lower() == 'ipv4':
                        try:
                            for bgpIpRoute in group.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
                    if IP_type.lower() == "ipv6":
                        try:
                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
                        try:
                            for bgpIpRoute in group.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute.EnableFlapping.Single(str(action).lower())
                                bgpIpRoute.Uptime.Single(uptime)
                                bgpIpRoute.Downtime.Single(downtime)
                        except:
                            pass
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def _get_dict_traffic_streams(self):
        """
        Get traffic streams mapped to streamblock

        :return: Dictionary of traffic streams
        """
        dictTrafficStreams = {}
        streamblockList = self.get_all_traffic_streams()
        for stream in streamblockList:
            streamblockName = stream.Name
            dictTrafficStreams[streamblockName] = stream
        return dictTrafficStreams

    def set_stream_mpls_label(self, cfg_dict, traffic_item_list=None):
        """
        Sets the MPLS label field to the specified value

        :param cfg_dict: The exp bit field value to be used.
        :param mpls_label_index: Mpls label index , default value is 0.
        :param traffic_item_list: A list of streamblocks to be modified. If None,
                set mplsbit for all streamblocks.
        :return: True if no exceptions were thrown

        :Example: set_stream_mpls_label(cfg_dict = {'valueType':'singleValue', 'value' : 20})
                  set_stream_mpls_label1(cfg_dict = {'valueType':'singleValue', 'value' : 20, 'mpls_label_index': 0 }, traffic_item_list= ['Traffic Item 1'])
        """
        self.log.info("Setting MPLS label for Traffic Items")
        if not 'mpls_label_index' in cfg_dict is None:
            cfg_dict['mpls_label_index'] = 0
        if traffic_item_list is None:
            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]
        for trafficName in traffic_item_list:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                try:
                    fieldValue = configElement.Stack.find(StackTypeId='mpls').Field.find(Name='label_value')
                    for index in range(len(fieldValue)):
                        if index == cfg_dict['mpls_label_index']:
                            try:
                                if cfg_dict['valueType'].lower() in ['increment', 'decrement']:
                                    fieldValue[index].ValueType = cfg_dict['valueType'].lower()
                                    fieldValue[index].StepValue = 1
                                    fieldValue[index].StartValue = cfg_dict['value']
                                else:
                                    fieldValue[index].ValueType = cfg_dict['valueType']
                                    fieldValue[index].SingleValue = cfg_dict['value']
                                result = True

                            except:
                                result = False
                except:
                    result = False
        return result

    def get_stream_mpls_label(self, traffic_item_list=None):
        """
        Gets the value of the MPLS headers exp field for the specified traffic items

        :param traffic_item_list: A list of streamblocks to get the MPLS EXP values from.
        :return: A list of results containing the exp field value for the specified streams

        :Example: get_stream_mpls_label()
        """
        self.log.info("Getting MPLS EXP Bits For Traffic Items")
        results = []
        if traffic_item_list:
            for trafficName in traffic_item_list:
                try:
                    for fieldValue in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find().Stack.find(
                        StackTypeId='mpls').Field.find(Name='mpls_exp'):
                        results.append(fieldValue.SingleValue)
                except:
                    self.log.info("MPLS Stack Not Available in %s" % trafficName)
                    raise IxiaOperationException("MPLS Stack Not Available in %s" % trafficName)
        else:
            try:
                for fieldValue in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find().Stack.find(
                            StackTypeId='mpls').Field.find(Name='mpls_exp'):
                    results.append(fieldValue.SingleValue)
            except:pass
        return results

    def get_traffic_transmission_mode(self, traffic_item_list=None, port='all'):
        """
        Returns the traffic transmission mode with respective values configured

        :param traffic_item_list: List of traffic items
        :param port: port on which traffic is generated
        :return: Dictionary of the traffic transmission mode configured

        :Example: get_traffic_transmission_mode()
        """
        self.log.info("Getting Traffic Transmission Mode")
        result = {}
        if traffic_item_list:
            for trafficName in traffic_item_list:
                result[trafficName] = self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).TransmitMode
        else:
            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                result[trafficItem.Name] = trafficItem.TransmitMode
        return result

    def _get_route_count(self, poolHandle, routeCount, prefixIp=None):
        """
        Get Route count based on Protocol handle.

        :param poolHandle: network pool handle
        :param routeCount: routecount
        :param prefixIp: Ip prefix value as reference
        :return:
        """
        if prefixIp:
            try:
                # This block for 9.0 version
                ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)
                routeCount = (poolHandle.NumberOfAddressesAsy.Values)[ipPrefixIndex]
            except:
                # This block for 8.50 version
                routeCount = poolHandle.NumberOfAddresses
                pass
        else:
            try:
                # This block for 9.0 version
                addressCountList = poolHandle.NumberOfAddressesAsy.Values
                routeCount = int(addressCountList[0]) + routeCount
            except:
                # This block for 8.50 version
                addressCount = poolHandle.NumberOfAddresses
                routeCount = routeCount + addressCount
                pass
        return routeCount

    def _get_isis_ospf_route_count(self, network_group, ports, ip_type, start_ip_prefix, protocol, router_id):
        """
        getting address count for protocols.
        :param network_group: Network Group for which Route Count should be modified
        :param ports: Ports
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: ipv4/ipv6 perfix ip
        :param protocol: ISIS/OSPF
        :param router_id: router ID
        :return: result
        """
        
        route_count = 0
        protocol_status = False
        deviceGroupName = None
        if (network_group and start_ip_prefix and router_id) or (
                network_group is None and start_ip_prefix and router_id):
            networkGroupNameList = []
            if "." in router_id and protocol.lower() != 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if "." not in router_id and protocol.lower() == 'isis':
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.Name == router_id:
                        deviceGroupName = router_id
                try:
                    if deviceGroupName:
                        for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                            if network_group:
                                if network_group in networkGroup.Name:
                                    networkGroupNameList.append(networkGroup.Name)
                                    break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            else:
                try:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group:
                            if network_group in networkGroup.Name:
                                networkGroupNameList.append(networkGroup.Name)
                                break
                            else:
                                networkGroupNameList.append(networkGroup.Name)
                except:
                    pass
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' in start_ip_prefix and '.' not in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        protocol_status = True
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    if start_ip_prefix in networkGroupObj.NetworkAddress.Values:
                                        protocol_status = True
                                        route_count = self._get_route_count(networkGroupObj,route_count,prefixIp=start_ip_prefix)
                                    if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                        raise IxiaConfigException("Passed Invalid Ip %s" % start_ip_prefix)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)
        
        if (network_group and start_ip_prefix is None and ports is None and router_id) or (
                network_group is None and start_ip_prefix is None and router_id):
            if "." in router_id:
                if protocol == "ISIS":
                    raise IxiaConfigException("ISIS protocol doesn't support Router Id, Please pass deviceGroup name instead of router_id (Ex: router_id='Device1')")
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                            deviceGroupName = deviceGroupObj.Name
                            break
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                            # networkGroupNameList = networkGroupNameList
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + deviceGroupName + '$').NetworkGroup.find()]

            else:
                networkGroupNameList = []
                if network_group and router_id:
                    for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$').NetworkGroup.find():
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                if network_group is None and router_id:
                    networkGroupNameList = [networkGroupObj.Name for networkGroupObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                                Name='^' + router_id + '$').NetworkGroup.find()]

            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                            if protocol == "OSPF":
                                if networkGroupObj.OspfRouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                            if protocol == "ISIS":
                                if networkGroupObj.IsisL3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
                            if protocol == "OSPF":
                                if networkGroupObj.Ospfv3RouteProperty.find():
                                    protocol_status = True
                                    route_count = self._get_route_count(networkGroupObj,route_count)
            else:
                raise IxiaConfigException("Router Id not found on this '%s' Network Group" % network_group)

        if network_group and ports is None and start_ip_prefix is None and router_id is None:
            networkGroupNameList = []
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                for networkGroupObj in deviceGroupObj.NetworkGroup.find():
                    if network_group in networkGroupObj.Name:
                        networkGroupNameList.append(networkGroupObj.Name)
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):
                            for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv4PoolObj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv4PoolObj,route_count)
                                if protocol == "OSPF":
                                    if ipv4PoolObj.OspfRouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv4PoolObj,route_count)
                    else:
                        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$'):
                            for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if ipv6PoolObj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv6PoolObj,route_count)
                                if protocol == "OSPF":
                                    if ipv6PoolObj.Ospfv3RouteProperty.find():
                                        protocol_status = True
                                        route_count = self._get_route_count(ipv6PoolObj,route_count)
            else:
                raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'" % (network_group,ip_type))
        if ports:
            vportNameList = [vport.Name for vport in self.ixNetwork.Vport.find()]
            for port in ports:
                if port in vportNameList:
                    for topologyObj in self.ixNetwork.Topology.find():
                        if topologyObj.Vports[0] == self.ixNetwork.Vport.find(Name=port).href:
                            if ip_type.lower() == "ipv4":
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv4PoolObj in networkObj.Ipv4PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv4PoolObj.IsisL3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv4PoolObj,route_count)
                                        if protocol == "OSPF":
                                            if ipv4PoolObj.OspfRouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv4PoolObj,route_count)
                            else:
                                for networkObj in topologyObj.DeviceGroup.find().NetworkGroup.find():
                                    for ipv6PoolObj in networkObj.Ipv6PrefixPools.find():
                                        if protocol == "ISIS":
                                            if ipv6PoolObj.IsisL3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv6PoolObj,route_count)
                                        if protocol == "OSPF":
                                            if ipv6PoolObj.Ospfv3RouteProperty.find():
                                                protocol_status = True
                                                route_count = self._get_route_count(ipv6PoolObj,route_count)
        if (start_ip_prefix and network_group is None and ports is None and router_id is None) or (
                start_ip_prefix and network_group and ports is None and router_id is None):
            networkGroupNameList = []
            if network_group and start_ip_prefix:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find() if
                                        network_group in networkObj.Name]
                # This condition for compact version
                if networkGroupNameList == []:
                    networkGroupNameList = [networkObj.Name for networkObj in
                                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]

            if start_ip_prefix and network_group is None:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()]
            if networkGroupNameList:
                for networkGroupName in networkGroupNameList:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv4PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.OspfRouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' not in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
                    else:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + networkGroupName + '$')
                        try:
                            for network_group_obj in networkObj.Ipv6PrefixPools.find():
                                if protocol == "ISIS":
                                    if network_group_obj.IsisL3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                                if protocol == "OSPF":
                                    if network_group_obj.Ospfv3RouteProperty.find():
                                        protocol_status = True
                                        if start_ip_prefix in network_group_obj.NetworkAddress.Values:
                                            route_count = self._get_route_count(network_group_obj,route_count,prefixIp=start_ip_prefix)
                                        if ':' not in start_ip_prefix and '.' in start_ip_prefix:
                                            raise IxiaConfigException(f'Passed Invalid Ip {start_ip_prefix}')
                        except:
                            pass
        if protocol_status and route_count != 0:
            return route_count
        else:
            raise IxiaConfigException("%s protocol not configured or Configuration issue." % protocol)

    def get_isis_route_count(self,router_id=None, ip_type="ipv4", lsp_id=None, start_ip_prefix=None, **kwargs):
        """
        Get the route count for ISIS protocol.

        :param router_id: It's mandatory value for spirent and represents the Router ID of the router.
        :param ip_type: String demonstrating the IP version
        :param lsp_id: It's optional value specific to Spirent and represents the LSP Name.
        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                        For IXIA, network_group has to be included in the kwargs
                        as a mandatory parameter and ports is optional
        :return: route count value/dictionary.

        :Example: get_isis_route_count(network_group='Network Group 8',ip_type="ipv4")
        """
        self.log.info("Getting ISIS Route Count")
        ports = kwargs.get('ports', None)
        network_group = kwargs.get('network_group', None)
        if router_id:
            if "." in router_id:
                router_id = None
        if not network_group and start_ip_prefix is None and router_id is None and ports is None:
            raise IxiaConfigException('Please send either Network Group/Start Ip Prefix/Router Id/Ports param')
        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol="ISIS",router_id=router_id)
        return routeCount

    def get_ospf_route_count(self, router_id, ip_type="ipv4", lsa_id=None, start_ip_prefix=None, **kwargs):
        """
        Get the route count for OSPF protocol.

        :param router_id: It's mandatory value and represents the Router ID of the router.
        :param ip_type: String demonstrating the IP version
        :param lsa_id: It's optional value specific to Spirent and represents the LSA Name.
        :param start_ip_prefix: It's optional value specific to Spirent and represents the start_ip_prefix of the route.
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                        For IXIA, network_group has to be included in the kwargs
                        as a mandatory parameter and ports is optional
        :return: route count value/dictionary.

        :Example: get_ospf_route_count(router_id="192.0.0.1",ip_type="ipv6",network_group='Network Group 2'))
        """
        self.log.info("Getting OSPF Route Count")
        ports = kwargs.get('ports')
        network_group = kwargs.get('network_group', None)
        routeCount = self._get_isis_ospf_route_count(network_group, ports, ip_type, start_ip_prefix, protocol="OSPF",router_id=router_id)
        return routeCount

    def verify_dhcp_client_bound_count(self, client_dict):
        """
        To verify number of DHCP sessions currently bound to the interface/device

        :param client_dict: {'device1':{'protocol': 'ipv4', 'total_bound_count':'100', 'current_bound_count':'10'}}
        :return: True if successful

        :Example: verify_dhcp_client_bound_count(client_dict={'Device Group 23':{'protocol': 'ipv4', 'total_bound_count':10, 'current_bound_count':10}})
        """
        self.log.info("Verifying DHCP Client Bound Count")
        error_flag = False
        err_msg = ""
        for device in client_dict:
            protocol = client_dict[device]['protocol']
            totalBoundCount, currentBoundCount = self.get_dhcp_client_bound_count(device, protocol)

            expectedTotalBoundCount = client_dict[device]['total_bound_count']
            expectedCurrentBoundCount = client_dict[device]['current_bound_count']

            if totalBoundCount == expectedTotalBoundCount and \
                    currentBoundCount == expectedCurrentBoundCount:
                log.info('Actual and expected bound count for client/device %s match' % device)
            else:
                error_flag = True
                err_msg += 'For device %s:\n' % device
                err_msg += 'Actual values: (totalBoundCount)=%s, (currentBoundCount)=%s \n' \
                           % (totalBoundCount, currentBoundCount)
                err_msg += 'Expected values: (totalBoundCount)=%s, (currentBoundCount)=%s\n\n' \
                           % (expectedTotalBoundCount, expectedCurrentBoundCount)

        if error_flag:
            raise CafyException.VerificationError(err_msg)

        return True

    def ospf_start(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):
        """
        To start OSPFv2/OSPFv3 emulation

        :param version: Version
        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts
        :param devices: Name of the devices in the config
        :return: True on success. raise exception if False/error

        :Example: ospf_start(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])
        """
        self.log = CafyLog('Starting OSPF protocol')
        action = 'Start'
        protocol = []
        if version.lower() not in ('v2', 'v3'):
            CafyException.InvalidValueError('%s not a valid OSPF version' % version)
        protocol.append('ospf' + version)
        nested_device = kwargs.get('nested_device', None)
        self._start_stop_protocols(protocol, port, host_ip, "Start", "True", devices, nested_device)
        return True

    def ospf_stop(self, version='v2', port=None, host_ip=None, devices=None, **kwargs):
        """
        To start OSPFv2/OSPFv3 emulation

        :param version: Version
        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of host ip. If 'None' all the OSPF(v2/v3) hosts
        :param devices: Name of the devices in the config
        :return: True on success. raise exception if False/error

        :Example: ospf_stop(port=['Ethernet - 001','Ethernet - 002'],host_ip=['1.1.1.1','1.1.1.2'])
        """
        self.log = CafyLog('Starting OSPF protocol')
        action = 'Stop'
        protocol = []
        if version.lower() not in ('v2', 'v3'):
            CafyException.InvalidValueError('%s not a valid OSPF version' % version)
        protocol.append('ospf' + version)
        nested_device = kwargs.get('nested_device', None)
        self._start_stop_protocols(protocol, port, host_ip, "Stop", "False", devices, nested_device)
        return True

    def _igmp_configure(self, group_name, igmp_group_start, count, step, prefix, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name:Device group name
        :param ip_version:IGMP Version
        :param igmp_group_start:igmp host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: IGMP Prefix
        """
        result = False
        for igmpHostObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find():
            if group_name.lower() in (igmpHostObj.Name).lower():
                if 'device' not in kwargs:
                    if igmp_group_start != '' and step != '':
                        igmpHostObj.IgmpMcastIPv4GroupList.StartMcastAddr.Increment(start_value=igmp_group_start,step_value=step)
                    elif igmp_group_start != '' and step == '':
                        igmpHostObj.IgmpMcastIPv4GroupList.StartMcastAddr.Single(igmp_group_start)
                if 'device' in kwargs:
                    if count:
                        device_id = kwargs['device']
                        mcastGrpList = igmpHostObj.IgmpMcastIPv4GroupList
                        group_count_list = mcastGrpList.McastAddrCnt.Values
                        group_count_list[device_id - 1] = count
                        mcastGrpList.McastAddrCnt.ValueList(group_count_list)
                    if igmp_group_start:
                        mcastStartList = igmpHostObj.IgmpMcastIPv4GroupList
                        start_addr_list = mcastStartList.StartMcastAddr.Values
                        start_addr_list[device_id - 1] = igmp_group_start
                        mcastStartList.StartMcastAddr.ValueList(start_addr_list)
                else:
                    igmpHostObj.IgmpMcastIPv4GroupList.McastAddrCnt.Single(count)
                if 'igmp_version' in kwargs:
                    igmpHostObj.VersionType.Single(kwargs['igmp_version'])
                result = True
        if result:
            return result
        else:
            raise IxiaConfigException("Passed invalid group name %s" % group_name)

    def _mld_configure(self, group_name, mld_group_start, count, step, prefix, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param ip_version: MLD Version
        :param group_name: mld host group name
        :param mld_group_start: mld host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: 128 for ipv6
        """
        result = False
        for mldHostObj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find():
            if group_name.lower() in (mldHostObj.Name).lower():
                if 'device' not in kwargs:
                    if mld_group_start != '' and step != '':
                        mldHostObj.MldMcastIPv6GroupList.StartMcastAddr.Increment(start_value=mld_group_start,
                                                                                  step_value=step)
                    elif mld_group_start != '' and step == '':
                        mldHostObj.MldMcastIPv6GroupList.StartMcastAddr.Single(mld_group_start)
                if 'device' in kwargs:
                    if count:
                        device_id = kwargs['device']
                        mcastGrpList = mldHostObj.MldMcastIPv6GroupList
                        group_count_list = mcastGrpList.McastAddrCnt.Values
                        group_count_list[device_id - 1] = count
                        mcastGrpList.McastAddrCnt.ValueList(group_count_list)
                    if mld_group_start:
                        mcast_start_list = mcastGrpList.StartMcastAddr.Values
                        mcast_start_list[device_id - 1] = mld_group_start
                        mcastGrpList.StartMcastAddr.ValueList(mcast_start_list)
                else:
                    mldHostObj.MldMcastIPv6GroupList.McastAddrCnt.Single(count)
                if 'mld_version' in kwargs:
                    mldHostObj.VersionType.Single(kwargs['mld_version'])
                result = True
        if result:
            return result
        else:
            raise IxiaConfigException("Passed invalid group name %s" % group_name)

    def _pimv4_configure(self, group_name, pimv4_group_start, count, step, prefix, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name:Device group name
        :param ip_version: IP Version
        :param pimv4_group_start:pimv4 host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: PIMv4 Prefix
        """
        result = False
        for pimv4Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().PimV4Interface.find():
            if group_name.lower() in (pimv4Obj.Name).lower():
                if 'device' not in kwargs:
                    if pimv4_group_start != '' and step != '':
                        pimv4Obj.PimV4JoinPruneList.GroupV4Address.Increment(start_value=pimv4_group_start,
                                                                             step_value=step)
                    elif pimv4_group_start != '' and step == '':
                        pimv4Obj.PimV4JoinPruneList.GroupV4Address.Single(pimv4_group_start)
                if 'device' in kwargs:
                    if count:
                        device_id = kwargs['device']
                        mcastGrpList = pimv4Obj.PimV4JoinPruneList
                        group_count_list = mcastGrpList.GroupAddressCount.Values
                        group_count_list[device_id - 1] = count
                        mcastGrpList.GroupAddressCount.ValueList(group_count_list)
                    if pimv4_group_start:
                        group_start_list = mcastGrpList.GroupV4Address.Values
                        group_start_list[device_id - 1] = pimv4_group_start
                        mcastGrpList.GroupV4Address.ValueList(group_start_list)
                else:
                    pimv4Obj.PimV4JoinPruneList.GroupAddressCount.Single(count)
                result = True
        if result:
            return result
        else:
            raise IxiaConfigException("Passed invalid group name %s" % group_name)

    def _pimv6_configure(self, group_name, pimv6_group_start, count, step, prefix, **kwargs):
        """
        Function used internally by API "config_multicast_group"

        :param group_name:Device group name
        :param ip_version: IP Version
        :param pimv6_group_start:pimv6 host start address
        :param count: group address count
        :param step: group address increment
        :param prefix: PIMv6 Prefix
        """
        result = False
        for pimv6Obj in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().PimV6Interface.find():
            if group_name.lower() in (pimv6Obj.Name).lower():
                if 'device' not in kwargs:
                    if pimv6_group_start != '' and step != '':
                        pimv6Obj.PimV6JoinPruneList.GroupV6Address.Increment(start_value=pimv6_group_start,
                                                                             step_value=step)
                    elif pimv6_group_start != '' and step == '':
                        pimv6Obj.PimV6JoinPruneList.GroupV4Address.Single(pimv6_group_start)
                if 'device' in kwargs:
                    if count:
                        device_id = kwargs['device']
                        mcastGrpList = pimv6Obj.PimV6JoinPruneList
                        group_count_list = mcastGrpList.GroupAddressCount.Values
                        group_count_list[device_id - 1] = count
                        mcastGrpList.GroupAddressCount.ValueList(group_count_list)
                    if pimv6_group_start:
                        group_start_list = mcastGrpList.GroupV6Address.Values
                        group_start_list[device_id - 1] = pimv6_group_start
                        mcastGrpList.GroupV6Address.ValueList(group_start_list)
                else:
                    pimv6Obj.PimV6JoinPruneList.GroupAddressCount.Single(count)
                result = True
        if result:
            return result
        else:
            raise IxiaConfigException("Passed invalid group name %s" % group_name)

    def config_multicast_group(self, ip_version, group_name, start_ip='', count='', step='',
                               prefix='', **kwargs):
        """
        Config ipv4/ipv6 multi cast group

        :param group_name: igmp group name
        :param ip_version: IP version of multicast group
        :param start_ip: Starting IP address of the group
        :param count: Number of Groups
        :param step: Increment step in case of more that one group
        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)
        :param kwargs :
                protocol: Multicast protocol to config Ex igmp/mld/pimv4/pimv6
        :return: True on Success

        :Example: config_multicast_group('ipv6',group_name='MLD Host 2',start_ip='ff03::2', count='13',mld_version='version1')
        """
        self.log.info("Configuring Multicast Group")
        if not group_name:
            raise IxiaOperationException("Multicast group name not provided by user")
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")
        if ip_version.lower() == 'ipv4':
            protocol = kwargs.get('protocol', 'igmp')
            if protocol.lower() == 'igmp':
                self._igmp_configure(group_name, start_ip, count, step, prefix, **kwargs)
            if protocol.lower() == 'pimv4':
                self._pimv4_configure(group_name, start_ip, count, step, prefix, **kwargs)

        if ip_version.lower() == 'ipv6':
            protocol = kwargs.get('protocol', 'mld')
            if protocol.lower() == 'mld':
                self._mld_configure(group_name, start_ip, count, step, prefix, **kwargs)
            if protocol.lower() == 'pimv6':
                self._pimv6_configure(group_name, start_ip, count, step, prefix, **kwargs)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def ldp_neighbor_flap(self, ldp_peer_name_list, action='True'):
        """
        Enable/disable LDP on interfaces and also starts/stops LDP protocol
        Flapping LDP router and LDP connected Interface

        :param ldp_peer_name_list: LDP device name List
        :param action: string format. Not boolean
                       'True' = enable LDP flap
                       'False' = disable LDP flap
        :return: True on success else raise exception.

        :Example: ldp_neighbor_flap(['Device 1','Device 2'],action='false')
        """
        self.log.info("Performing LDP neighbor flap")
        if not isinstance(ldp_peer_name_list, list):
            msg = 'ldpPeerNameList type can not be %s. It should be a list' \
                  % type(ldp_peer_name_list)
            raise TypeError(msg)
        if action.lower() == 'true':
            protocolAction = 'Start'
        else:
            protocolAction = 'Stop'
        for ldpRouter in ldp_peer_name_list:
            try:
                for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=ldpRouter):
                    if deviceObj.LdpBasicRouter.find():
                        ldpv4Obj = deviceObj.LdpBasicRouter.find()
                        ldpv4Obj.Active.Single(action.lower())
                        eval('ldpv4Obj.find().' + protocolAction + '()')
                    if deviceObj.LdpBasicRouterV6.find():
                        ldpv6Obj = deviceObj.LdpBasicRouterV6.find()
                        ldpv6Obj.Active.Single(action.lower())
                        eval('ldpv6Obj.find().' + protocolAction + '()')
                    if deviceObj.Ethernet.find().Ipv4.find():
                        ipv4Obj = deviceObj.Ethernet.find().Ipv4.find()
                        if ipv4Obj.find().LdpBasicRouter.find():
                            eval('ipv4Obj.find().LdpBasicRouter.find().Active.Single(action.lower())')
                            eval('ipv4Obj.find().LdpBasicRouter.find().' + protocolAction + '()')
                        if ipv4Obj.find().LdpConnectedInterface.find():
                            eval('ipv4Obj.find().LdpConnectedInterface.find().Active.Single(action.lower())')
                            eval('ipv4Obj.find().LdpConnectedInterface.find().' + protocolAction + '()')
                    if deviceObj.Ethernet.find().Ipv6.find():
                        ipv6Obj = deviceObj.Ethernet.find().Ipv6.find()
                        if ipv6Obj.find().LdpBasicRouterV6.find():
                            eval('ipv6Obj.find().LdpBasicRouterV6.find().Active.Single(action.lower())')
                            eval('ipv6Obj.find().LdpBasicRouterV6.find().' + protocolAction + '()')
                        if ipv6Obj.find().Ldpv6ConnectedInterface.find():
                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().Active.Single(action.lower())')
                            eval('ipv6Obj.find().Ldpv6ConnectedInterface.find().' + protocolAction + '()')
            except:
                raise IxiaOperationException("LDP flap failed")
        try:
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        except:
            pass
        return True

    def start_arp_on_streams(self, ports=()):
        """
        Starts ARP on all the streams under specified ports

        :param ports: port or list of ports Default all ports
        :return: True on success

        :Example: start_arp_on_streams()
        """

        self.log.info("Starting ARP at stream level")
        trafficItemsPortDict = {}

        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                if trafficItem.TrafficType == 'raw':
                    for count, stream in enumerate(trafficItem.HighLevelStream.find()):
                        trafficItemsPortDict.setdefault(trafficItem.Name, []).append(stream.TxPortId)
        else:
            for count, quickFlow in enumerate(self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find()):
                trafficItemsPortDict.setdefault(quickFlow.Name, []).append(quickFlow.TxPortId)

        vPortDestMacDict = {}
        vPorts = [vport.href for vport in self.ixNetwork.Vport.find()]

        for vPort in vPorts:
            destGatewayMac = []
            for topology in self.ixNetwork.Topology.find():
                if topology.Ports[0] == vPort:
                    try:
                        for ipv4 in topology.DeviceGroup.find().Ethernet.find().Ipv4.find():
                            for resolvedGatewayMac in ipv4.ResolvedGatewayMac:
                                destGatewayMac.append(resolvedGatewayMac)
                    except:
                        pass
                    try:
                        for ipv6 in topology.DeviceGroup.find().Ethernet.find().Ipv6.find():
                            for resolvedGatewayMac in ipv6.ResolvedGatewayMac:
                                destGatewayMac.append(resolvedGatewayMac)
                    except:
                        pass
                    destGatewayMac = [ele for ele in destGatewayMac if ele != 'removePacket[Unresolved]']
            if destGatewayMac:
                vPortDestMacDict[vPort] = destGatewayMac[0]

        if vPortDestMacDict:
            trafficNameMacMapping = {}
            for trafficItemName in trafficItemsPortDict:
                try:
                    for flow in trafficItemsPortDict[trafficItemName]:
                        trafficNameMacMapping.setdefault(trafficItemName, []).append(vPortDestMacDict[flow])
                except:
                    pass

            for trafficName in trafficNameMacMapping:
                traffic = trafficName.replace(')', '\)').replace('+', '\+').replace('*', '\*').replace('(', '\(')
                trafficObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic + '$')
                try:
                    if trafficObj.HighLevelStream.find().Stack.find(DisplayName='Ethernet II'):
                        for count, flow in enumerate(trafficObj.HighLevelStream.find()):
                            flow.Stack.find(DisplayName='Ethernet II').Field.find(
                                DisplayName='Destination MAC Address').ValueType = "singleValue"
                            flow.Stack.find(DisplayName='Ethernet II').Field.find(
                                DisplayName='Destination MAC Address').FieldValue = trafficNameMacMapping[trafficName][
                                count]

                except:
                    pass
                try:
                    if trafficObj.ConfigElement.find().Stack.find(DisplayName='Ethernet II'):
                        for count, flow in enumerate(trafficObj.ConfigElement.find()):
                            flow.Stack.find(DisplayName='Ethernet II').Field.find(
                                DisplayName='Destination MAC Address').ValueType = "singleValue"
                            flow.Stack.find(DisplayName='Ethernet II').Field.find(
                                DisplayName='Destination MAC Address').FieldValue = trafficNameMacMapping[trafficName][
                                count]

                except:
                    pass
            return True
        else:
            self.log.info("Ip stack is down")
            return False

    def get_port_traffic_streams(self, port):
        """
        Get Traffic stream list with respect to port

        :param port: Port(source) under which streams are created
        :return: Stream list for the given port

        :Example: get_port_traffic_streams("Ethernet - 001")
        """
        self.log.info("Getting Traffic Streams based on Port")
        trafficItemsPortDict = {}
        streamList = []
        if self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
            for trafficItem in self.ixNetwork.Traffic.TrafficItem.find():
                trafficItemsPortDict[trafficItem.Name] = trafficItem.HighLevelStream.find()[0].TxPortId
        else:
            for quickFlow in self.ixNetwork.Traffic.TrafficItem.find().HighLevelStream.find():
                trafficItemsPortDict[quickFlow.Name] = quickFlow.TxPortId

        portHref = self.ixNetwork.Vport.find(Name=port).href
        for traffic in  trafficItemsPortDict:
            if trafficItemsPortDict[traffic] == portHref:
                streamList.append(traffic)
        self.log.info(streamList)
        return True

    def get_multicast_group(self, ip_version, group_name):
        """
        Get Multicast's group network block config

        :param ip_version: IP version of multi-cast group
        :param group_name: Multicast's group name
        :return: Network block config in Multicast group

        :Example: get_multicast_group('ipv4','IGMP Host 2')
        """
        self.log.info("Getting Multicast Group")
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid ip version")
        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}

        groupConfig = {}
        try:
            if ip_version.lower() == 'ipv4':
                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.StartMcastAddr
                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrIncr
                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name).IgmpMcastIPv4GroupList.McastAddrCnt
            else:
                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)
                groupConfig['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.StartMcastAddr
                groupConfig['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrIncr
                groupConfig['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=group_name).MldMcastIPv6GroupList.McastAddrCnt
        except:
            raise IxiaOperationException("%s not configured on %s' %(protocol.upper(), device)")

        return groupConfig

    def add_stream_header(self, traffic_item, headerType, headerName):
        """
        Add specific header to a trafficItem/stream

        :param traffic_item: Stream name for which header should be configured
        :param headerType: Type of header
                           Example: "DHCP", "MPLS"
        :param headerName: Header name which should be configured
                           Example: "DhcpClientMsg", "DhcpServerMsg"
                                    "icmp0"   - ICMP Msg Types: 0,8,13,14,15,16
                                    "icmp3"   - ICMP Msg Types: 3,4,5,11,12
                                    "icmp9"   - ICMP Msg Type: 9
                                    "icmpv6"  - ICMPV6, "igmv1" - IGMPv1, "igmpv2" - IGMPv2
                                    "igmpv3q" - IGMPv3 Membership Query
                                    "igmpv3r" - IGMPv3 Membership Report
        :return: True if header is configured else raise exception

        :Example: add_stream_header('Traffic Item 2','ICMP', 'icmp3')
                  add_stream_header('Traffic Item 1','MPLS','mpls')
                  add_stream_header('Traffic Item 2','IGMP', 'igmpv2')
        """
        self.log.info("Adding Stream Header")
        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)
        # add all supported header types and corresponding layer info to headerToLayerMapping dict
        # headerToLayerMapping = {'DHCP':'L5','IPV4':'L3','IPV6':'L3','TCP':'L4','UDP':'L4','ICMP':'L3'}
        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=traffic_item)
        configElement = trafficItem.ConfigElement.find()[0]
        stackIndex = configElement.find().Stack.find().index
        stackTop = configElement.Stack.find()[stackIndex - 1]
        ethernetStack = configElement.Stack.find(StackTypeId='^ethernet$')
        vlanStack = configElement.Stack.find(StackTypeId='^vlan$')
        tcpStack = configElement.Stack.find(StackTypeId='^tcp$')
        udpStack = configElement.Stack.find(StackTypeId='^udp$')
        ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
        ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
        if not streamObj:
            raise IxiaConfigException("stream not found")
        try:
            if headerType.upper() == 'IPV4':
                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv4Template))
            elif headerType.upper() == 'IPV6':
                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6Template))
            elif headerType.upper() == 'DHCP' and not configElement.Stack.find(StackTypeId='^dhcp$'):
                dhcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^dhcp$")
                if tcpStack:
                    configElement.Stack.read(tcpStack.AppendProtocol(dhcpTemplate))
                elif udpStack:
                    configElement.Stack.read(udpStack.AppendProtocol(dhcpTemplate))
                else:
                    configElement.Stack.read(ipv4Stack.AppendProtocol(dhcpTemplate))
                if re.search('dhcpserver', headerName, re.IGNORECASE):
                    configElement.Stack.find(DisplayName='DHCP').Field.find(
                        DisplayName='Message op code').FieldValue = 'BOOTREPLY'
                if re.search('dhcpclient', headerName, re.IGNORECASE):
                    configElement.Stack.find(DisplayName='DHCP').Field.find(
                        DisplayName='Message op code').FieldValue = 'BOOTREQUEST'
            elif headerType.upper() == 'IGMP':
                igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmp$")
                if headerName.upper() == 'IGMPV1':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv1$")
                if headerName.upper() == 'IGMPV2':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv2$")
                if headerName.upper() == 'IGMPV3R':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv3MembershipReport$")
                if headerName.upper() == 'IGMPV3Q':
                    igmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^igmpv3MembershipQuery$")
                configElement.Stack.read(stackTop.AppendProtocol(igmpTemplate))
            elif headerType.upper() == 'ICMP':
                icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmp$")
                if headerName.upper() == 'ICMP3':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv1$")
                if headerName.upper() == 'ICMP0':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv2$")
                if headerName.upper() == 'ICMP9':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv9$")
                if headerName.upper() == 'ICMPV6':
                    icmpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^icmpv6$")
                configElement.Stack.read(stackTop.AppendProtocol(icmpTemplate))
            elif headerType.upper() == 'MPLS':
                mplsTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^mpls$")
                configElement.Stack.read(stackTop.AppendProtocol(mplsTemplate))
            elif headerType.upper() == "OSPFV2" and not configElement.Stack.find(StackTypeId='^ospfv2$'):
                if re.search('ospfv2 Hello Packet', headerName, re.IGNORECASE):
                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ospfv2Hello$")
                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))
            elif headerType.upper() == "OSPFV3" and not configElement.Stack.find(StackTypeId='^ospfv3$'):
                if re.search('ospfv3 Hello', headerName, re.IGNORECASE):
                    ospfTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="ospfv3Hello")
                    configElement.Stack.read(stackTop.AppendProtocol(ospfTemplate))
            elif headerType.upper() == "CUSTOM" and not configElement.Stack.find(StackTypeId='^custom$'):
                if re.search('Custom', headerName, re.IGNORECASE):
                    customTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^custom$")
                    configElement.Stack.read(stackTop.AppendProtocol(customTemplate))
            elif headerType.upper() == 'VLAN':
                vlanTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^vlan$")
                configElement.Stack.read(stackTop.AppendProtocol(vlanTemplate))
            elif headerType.upper() == 'IPV6FRAGMENT':
                ipv6FragmentTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Fragment$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6FragmentTemplate))
            elif headerType.upper() == 'GRE':
                greTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^gre$")
                configElement.Stack.read(stackTop.AppendProtocol(greTemplate))
            elif headerType.upper() == 'L2TP':
                l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2tpv3$")
                if headerName.upper() == 'L2TPV3IPC':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3ControlIP$")
                if headerName.upper() == 'L2TPV3IPD':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3DataIP$")
                if headerName.upper() == 'L2TPV3UDPC':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3ControlUDP$")
                if headerName.upper() == 'L2TPV3UDPD':
                    l2tpv3Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^l2TPv3DataUDP$")
                configElement.Stack.read(stackTop.AppendProtocol(l2tpv3Template))
            elif headerType.upper() == 'IPV6ROUTE':
                ipv6RoutingTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Routing$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6RoutingTemplate))
            elif headerType.upper() == 'IPV6AUTH':
                ipv6AuthTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6Authentication$")
                configElement.Stack.read(stackTop.AppendProtocol(ipv6AuthTemplate))
            else:
                protocolTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId='^' + headerType.lower() + '$')
                configElement.Stack.read(stackTop.AppendProtocol(protocolTemplate))
        except:
            raise IxiaConfigException("Adding header failed")
        return True

    def add_multicast_group(self, ip_version, group_name='', start_ip='', count='', step='',
                            prefix='', **kwargs):
        """
        Create ipv4/ipv6 multi cast group

        :param ip_version: IP version of multicast group
        :param group_name: User defined group name
        :param start_ip: Starting IP address of the group
        :param count: Number of Groups
        :param step: Increment step in case of more that one group
        :param prefix: IP address prefix length (default: IPv4-32, IPv6-128)
        :param group_name: User defined group name
        :return: Unique Group name

        :Example: add_multicast_group('ipv4',group_name='IGMP Host 1',start_ip='227.0.0.0', count='13',igmp_version='version2',deviceName='Device Group 13')
        """
        self.log.info("Adding Multicast Group")
        deviceName = kwargs.get('deviceName')
        igmp_version = kwargs.get('igmp_version','version3')
        mld_version = kwargs.get('mld_version','version2')
        if not deviceName:
            raise IxiaOperationException("Device name is must for IXIA")
        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+deviceName+'$').Stop
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")
        if not group_name:
            group_name = ip_version + 'group'
        if ip_version.lower() == 'ipv4':
            #import pdb ; pdb.set_trace()
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+deviceName+'$').Ethernet.find().Ipv4.find().IgmpHost.add(Name=group_name)
                if start_ip or count or step:
                    self.config_multicast_group('ipv4', group_name=group_name, start_ip=start_ip, count=count,igmp_version=igmp_version)
            except:
                raise IxiaOperationException("Not able to configure igmp multicast group")
        if ip_version.lower() == 'ipv6':
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^'+deviceName+'$').Ethernet.find().Ipv6.find().MldHost.add(Name=group_name)
                if start_ip or count or step:
                    self.config_multicast_group('ipv6', group_name=group_name, start_ip=start_ip, count=count,mld_version=mld_version)
            except:
                raise IxiaOperationException("Not able to configure mld multicast group")
        self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceName + '$').Start
        return group_name

    def get_stream_header(self, traffic_items='all'):
        """
        Get the dictionary of headers configured for a stream

        :param traffic_items: List of stream names whose headers should be retrieved
        :return: Dictionary of Stream headers

        :Example: get_stream_header(['Traffic Item 4'])
        """
        import pdb; pdb.set_trace()
        streamList = self.ixNetwork.Traffic.TrafficItem.find()
        if traffic_items != 'all':
            if type(traffic_items) not in (list, tuple):
                traffic_items = [traffic_items]
        result = {}
        for streamName in traffic_items:
            streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=streamName)
            headers = streamObj.ConfigElement.find().Stack.find()
            update_headers = []
            for header in headers:
                update_headers.append(header.DisplayName)
            for headerName in update_headers:
                fields = streamObj.ConfigElement.find().Stack.find(DisplayName=headerName).Field.find()
                fieldNames = re.findall('DisplayName: (.*)', str(fields))
                fieldValues = re.findall('FieldValue: (.*)', str(fields))
                result[headerName] = list(zip(fieldNames, fieldValues))
        return result

    def config_igmp_group_member(self, router_id , mcast_group_config, mcast_source_config, **kwargs):
        """
        Allows user to change source count/list for device configured with IGMP_V3 and
        group count/list for device configured with IGMP_V2 or IGMP_V3

        :param router_id: NA for IXIA
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param kwargs: optional
        :return: True on Success

        :Example: config_igmp_group_member("192.0.0.1",{'count':'2'},{'count':'2'},device_name ='Device Group 27')
        """
        deviceName = kwargs.get("device_name",None)
        if deviceName is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Configuring multicast group {0}".format(deviceName))
        try:
            self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'igmp')
        except:
            raise IxiaOperationException("igmp host not configured for the device group provided")

        return True

    def config_mld_group_member(self, router_id, mcast_group_config, mcast_source_config, **kwargs):
        """
        Allows user to change source count/list for device configured with IGMP_V3 and
        group count/list for device configured with IGMP_V2 or IGMP_V3

        :param router_id: NA for IXIA
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param kwargs: device_name - Mandatory for IXIA
        :return: True on Success

        :Example: config_mld_group_member("192.0.0.1",{'count':'3'},{'count':'3'},device_name= 'Device Group 7')
        """
        deviceName = kwargs.get("device_name",None)
        if deviceName is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Configuring multicast group {0}".format(deviceName))
        try:
            self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()
        except:
            raise IxiaOperationException("igmp host not configured for the device group provided")
        self._config_group_member(deviceName, mcast_group_config, mcast_source_config, 'mld')

        return True

    def _config_group_member(self, device_name, mcast_group_config, mcast_source_config, protocol):
        """
        config Source & Group multi-cast config for IGMP or MLD on a device.

        :param device_name: device name of the host configured with multicast group
        :param mcast_group_config: Dictionary with Group count/list info
        :param mcast_source_config: Dictionary with Source count/list info
        :param protocol: IGMP or MLD
        :return: Group and Source config for IGMP/MLD
        """
        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if not device_name:
            self.log.info('No matching device found with device name: %s' % device_name)
        if protocol not in ('igmp', 'mld'):
            raise IxiaOperationException("Invalid protocol")
        for key, groupCount in mcast_group_config.items():
            self._config_group(device_name, groupCount, protocol)
        for key, sourceCount in mcast_source_config.items():
            self._config_source(device_name, sourceCount, protocol)

    def _config_group(self, device_name, group_count, protocol):
        """
        Function used internally by other API's

        :param device_name: Device Group Name
        :param group_count: Device Group count
        :param protocol: Protocol . Ex : IGMP/MLD
        """
        if protocol == 'igmp':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType
            if version == 'version2' or version == 'version3':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Single(group_count)
            else:
                raise IxiaOperationException("Invalid version")

        elif protocol == 'mld':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType
            if version == 'version1' or version == 'version2':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Single(
                    group_count)
            else:
                raise IxiaOperationException("Invalid mld version")
        else:
            raise IxiaOperationException("Not able to configure group member")
        return True
    
    def _config_source(self, device_name, source_count, protocol):
        """
        Function used internally by other API's

        :param device_name: Device Group Name
        :param source_count: Source count
        :param protocol: Protocol , Ex: 'igmp','mld'
        """
        if protocol == 'igmp':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().VersionType
            if version == 'version3':
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device_name).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt.Single(source_count)
        elif protocol == 'mld':
            version = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().VersionType
            if version == 'version1':
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt.Single(source_count)
        else:
            raise IxiaOperationException("Not able to configure group member")

        return True

    def get_stream_frame(self, stream_name, header, fields=()):
        """
        Get header field value of specific stream frame

        :param stream_name: stream on which header is configured
        :param header: name of the header configured
        :param fields: field or list of fields in the header for which value should be returned
        :return: Dictionary of requested fields and values in the given header.

        :Example: get_stream_frame('Traffic Item 1', 'IP', fields=['Version','Source Address','Destination Address','Flags'])
        """
        self.log.info("Getting Stream Frame")
        result = {}
        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name)
        if not streamObj:
            raise IxiaConfigException("stream not found")

        headerHandle = streamObj.ConfigElement.find().Stack.find().find(DisplayName=header)
        import pdb ; pdb.set_trace()
        if not headerHandle:
            raise IxiaConfigException("header not found")
        for headerField in fields:
            fieldHandle = headerHandle.Field.find(DisplayName=headerField)
            result[headerField] = fieldHandle.FieldValue
        return result

    def rsvp_te_stop(self, port=None, host_ip=None):
        """
        RSVP TE Stop

        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts
        :return: True. raise exception if False/error

        :Example: rsvp_te_stop()
        """
        self.log = CafyLog('Stopping rsvpte protocol')
        action = 'Stop'
        protocol = ['rsvp','rsvptelf']
        return self._start_stop_protocols(protocol, port, host_ip, action)

    def rsvp_te_start(self, port=None, host_ip=None):
        """
        RSVP TE Start

        :param port: List of ports. If 'None', all the ports
        :param host_ip: List of hostip. If 'None' all the RSVP-TE hosts
        :return: True. raise exception if False/error

        :Example: rsvp_te_start()
        """
        self.log = CafyLog('Stopping rsvpte protocol')
        action = 'Start'
        protocol = ['rsvp','rsvptelf']
        return self._start_stop_protocols(protocol, port, host_ip, action)

    def delete_stream_header(self, traffic_item, headerType, headerName, **kwargs):
        """
        Delete specific header from a stream

        :param traffic_item: Stream name for which header should be deleted
        :param headerType: Type of header\n
                           Example: "DHCP"
        :param headerName: Header name which should be configured\n
                           Example: "DhcpClientMsg", "DhcpServerMsg"
                           "icmp0"   - ICMP Msg Types: 0,8,13,14,15,16
                           "icmp3"   - ICMP Msg Types: 3,4,5,11,12
                           "icmp9"   - ICMP Msg Type: 9
                           "icmpv6"  - ICMPV6
        :return: True if header is deleted else raise exception

        :Example: tgnObj.delete_stream_header('Traffic Item 12','L2TP',headerName='L2TPV3IPD')
                  tgnObj.delete_stream_header('Traffic Item 1','IPv6')
                  tgnObj.delete_stream_header('Traffic Item 1','gre',header_index=1)
                  tgnObj.delete_stream_header('Traffic Item 1','icmp','icmp3')
        """
        self.log.info('Deleting Stream Header')
        headerIndex = kwargs.get('headerIndex', 1)
        trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$')
        if not trafficItem:
            raise IxiaConfigException("{} is not found".format(traffic_item))
        try:
            configElement = trafficItem.ConfigElement.find()[0]
            headerObj = None
            if headerType.upper() == 'IPV6':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6$')[headerIndex - 1]
            elif headerType.upper() == 'IPV6ROUTE':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Routing$')[headerIndex - 1]
            elif headerType.upper() == 'IPV6AUTH':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Authentication$')[headerIndex - 1]
            elif headerType.upper() == 'GRE':
                headerObj = configElement.Stack.find(StackTypeId='^gre$')[headerIndex - 1]
            elif headerType.upper() == 'L2TP':
                if headerName.upper() == 'L2TPV3IPC':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3ControlIP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3IPD':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3DataIP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3UDPC':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3ControlUDP$")[headerIndex - 1]
                elif headerName.upper() == 'L2TPV3UDPD':
                    headerObj = configElement.Stack.find(StackTypeId="^l2TPv3DataUDP$")[headerIndex - 1]
                else:
                    self.log.error('Incorrect L2TP header name')
            elif headerType.upper() == 'IPV6FRAGMENT':
                headerObj = configElement.Stack.find(StackTypeId='^ipv6Fragment$')[headerIndex - 1]
            elif headerType.upper() == 'ICMP':
                if headerName.upper() == 'ICMP3':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv1$')[headerIndex - 1]
                if headerName.upper() == 'ICMP0':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv2$')[headerIndex - 1]
                if headerName.upper() == 'ICMP9':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv9$')[headerIndex - 1]
                if headerName.upper() == 'ICMPV6':
                    headerObj = configElement.Stack.find(StackTypeId='^icmpv6$')[headerIndex - 1]
            else:
                headerObj = configElement.Stack.find(StackTypeId='^' + headerType.lower() + '$')[headerIndex - 1]
            if headerObj:
                headerObj.Remove()
                self.log.info('Stream header {} deleted successfully'.format(headerType))
            else:
                self.log.error('Stream header deletion failed')
        except:
            self.log.error('{} Header is not found in traffic stream {}'.format(headerType, traffic_item))
        return True

    def get_stream_dhcp_client_mac(self, stream_name):
        """
        get the mac_addr of dhcpclientmsg

        :param stream_name: stream on which dhcpclientmsg is configured
        :return: mac_addr of dhcpclientmsg

        :Example: get_stream_dhcp_client_mac('Traffic Item 4')
        """
        self.log.info("Getting Stream DHCP Client MAC")
        clientMac = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(
            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue
        clientMac = ':'.join(format(s, '02x') for s in bytes.fromhex(clientMac))
        return clientMac

    def get_sessions(self):
        """
        Get sessions on the server

        :return: list of sessions on the server

        :Example: get_sessions()
        """
        sessions = []
        if self.tgn_server_type == "linux":
            for eachSession in self.testPlatform.Sessions.find():
                sessions.append(eachSession.Name)
            self.log.info("Existing Sessions on Ixia Lab server '%s' : %s" %(self.server_ip,sessions))

        if self.tgn_server_type == 'windows':
            self.log.warning("Get Sessions is Not Supported on Ixia Windows Lab Server")

        return sessions

    def delete_session_by_name(self, session_name, end_tcsession=True):
        """
        Deletes the TGN session

        :param session_name: Session name to be deleted
        :param end_tcsession: NA for IXIA
        :return: True on success, exception on failure

        :Example: delete_session_by_name("session1")
        """
        if self.tgn_server_type == "linux":
            if self.testPlatform.Sessions.find(Name=session_name):
                if self.testPlatform.Sessions.find(Name=session_name).State == 'ACTIVE':
                    self.testPlatform.Sessions.find(Name=session_name).remove()
                    self.log.info("Deleted Session - '%s'" % session_name)
                    return True
            else:
                self.log.error("Session - '%s' Not Found" % session_name)
                return False

        if self.tgn_server_type == 'windows':
            self.log.warning("Sessions Delete is Not Supported in Ixia Windows Lab Server")
            return False

    def get_igmp_group_member(self, router_id, **kwargs):
        """
        API to get Source & Group multi-cast config for IGMP on a device.

        :param router_id: IGMP Router ID:
        :param device_name: device group name
        :return: Group and Source config for IGMP

        :Example: get_igmp_group_member('1.1.1.1',device_name='Device Group 13')
        """
        deviceName = kwargs.get('device_name')

        return self._get_group_member(deviceName, router_id, 'igmp', )

    def get_mld_group_member(self, router_id, **kwargs):
        """
        API to get Source & Group multi-cast config for MLD on a device.

        :param router_id: IGMP Router ID
        :param device_name: device group name
        :return: Group and Source config for MLD

        :Example: get_mld_group_member('1.1.1.1',device_name='Device Group 16')
        """
        deviceName = kwargs.get('device_name')
        return self._get_group_member(deviceName, router_id, 'mld')

    def _get_group_member(self, deviceName, router_id, protocol):
        """
        Get Source & Group multi-cast config for IGMP or MLD on a device.

        :param deviceName: device group name
        :param router_id: Router ID of a device
        :param protocol: IGMP or MLD
        :return: Group and Source config for IGMP/MLD
        """
        device = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName)
        if not deviceName:
            self.log.info('No matching device found with device name: %s' % deviceName)
            raise IxiaOperationException("Invalid Ip version")
        if protocol not in ('igmp', 'mld'):
            raise IxiaOperationException("Invalid protocol")
        updateKey = lambda D, key_map: {key_map[key]: value for key, value in D.items()}

        key_map = {'StartIpList': 'start_ip', 'AddrIncrement': 'step', 'NetworkCount': 'count'}
        try:
            if protocol.lower() == 'igmp':
                igmpObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find()
            else:
                mldHost = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find()
        except:
            self.log.info('%s not configured on %s' % (protocol.upper(), device))
            raise IxiaOperationException("%s not configured on %s' %(protocol.upper(), device)")
        groupConfig = self._get_group_config(deviceName, protocol)
        groupConfig = updateKey(groupConfig, key_map)
        mcastConfig = {'group': groupConfig}
        sourceConfig = self._get_source_config(deviceName, protocol)
        sourceConfig = updateKey(sourceConfig, key_map)
        mcastConfig['source'] = sourceConfig
        return mcastConfig

    def _get_group_config(self, deviceName, protocol):
        """
        Function used internally by other API's

        :param deviceName: device group name
        :param protocol: Protocol , Ex: 'igmp'
        """
        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}
        if protocol == 'igmp':
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt
        else:
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt
        return keyMap

    def _get_source_config(self, deviceName, protocol):
        """
        Function used internally by other API's

        :param deviceName: device group name
        :param protocol: Protocol , Ex: 'igmp'
        """
        keyMap = {'StartIpList': '', 'AddrIncrement': '', 'NetworkCount': ''}
        if protocol == 'igmp':
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.UcastSrcAddrCnt
        else:
            keyMap['StartIpList'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr
            keyMap['AddrIncrement'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastAddrIncr
            keyMap['NetworkCount'] = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name=deviceName).Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.UcastSrcAddrCnt
        return keyMap

    def reserve_ports(self, ports=None):
        """
        Reserve all or user specified ports

        :param ports: ports to be reserved (Default: all ports)
        :return: True on success

        :Example: reserve_ports()
        """
        update_portname=True
        if ports:
            try:
                self._assign_ports(ports, update_portname)
            except:
                msg = 'failed to reserve ports'
                raise IxiaOperationException(msg)
        return True

    def start_arp_on_ports(self, ports=None):
        '''
        Send arp based on port list

        :param ports: list of port name or port handle or interface name from Json file.
                      Default is None for all ports
        :return: True

        :Example: start_arp_on_ports()
        '''

        return self.start_arp()

    def start_arp_on_devices(self, ports=None):
        '''
        Send arp based on port list

        :param ports: list of port name or port handle or interface name from Json file.
                      Default is None for all ports
        :return: True

        :Example: start_arp_on_devices()
        '''

        return self.start_arp()

    def start_arp_on_objects(self,  objects=None, type='all'):
        '''
        Send arp based on port list

        :param objects: NA for IXIA
        :param type: NA for IXIA
        :return: True

        :Example: start_arp_on_objects()
        '''

        return self.start_arp()

    def set_stream_dhcp_client_mac(self, stream_name, mac_addr):
        """
        change the mac_ddr of dhcpclientmsg of specific stream

        :param stream_name: stream on which dhcpclientmsg is configured
        :param mac_addr: mac_addr that needs to replace mac_addr in dhcpclientmsg
        :return: True if successful else Raise Exception

        :Example: set_stream_dhcp_client_mac('Traffic Item 4','0xaa0a0a0a0a0a')
        """

        self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(
            StackTypeId='dhcp').Field.find(DisplayName='Client hardware address').FieldValue = mac_addr

        return True

    def set_device_vlan_count(self,device_name,vlan_count):
        """
        Set device VLAN parameters
        :param device_name: device Group name
        :param vlan_count: vlan number,  Default is 1

        :return: True if successful
        :Example: set_device_vlan_count(device_name='Device Group 1', vlan_count=2)
        """

        if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$'):
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find().VlanCount = vlan_count
            except:
                self.log.error("Error in setting vlan count")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def set_device_vlan(self, router_id, vlan_number=1, vlan_id=None, vlan_priority=None, vlan_type=None, **kwargs):
        """
        Set device VLAN parameters

        :param router_id: NA for IXIA
        :param vlan_number: vlan number,  Default is 1
        :param vlan_id: VLAN ID to be set
        :param vlan_priority: Priority to be set, Type is Integer. Range [0-7]. Default is 7
        :param vlan_type: Type to be set,  '8100', '88a8', '9100', '9200', '9300'
        :param kwargs: device_name, Mandatory for IXIA

        :return: True if successful

        :Example: set_device_vlan(router_id=None, device_name='Device Group 13' , vlan_number=8 , vlan_priority=0, vlan_id = 3, vlan_type = '0x9200')
        """
        device_name = kwargs.get('device_name',None)
        if device_name is None:
            raise IxiaOperationException("Device Group Name Mandatory for IXIA")
        self.log.info("Changing VLAN Parameters for Vlan {0} in {1}".format(vlan_number, device_name))
        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',
                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}
        try:
            vlanList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find().VlanId.Values

        except:
            raise IxiaOperationException("Device Group not Found")
        priorityList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().Priority.Values
        tpidList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().Tpid.Values
        vlanIdList = self.ixNetwork.Topology.find().DeviceGroup.find(
            Name=device_name).Ethernet.find().Vlan.find().VlanId.Values
        indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
        if indexList:
            for index in indexList:
                priorityList.pop(index)
                priorityList.insert(index, str(vlan_priority))
                vlanIdList.pop(index)
                vlanIdList.insert(index, str(vlan_id))

            for vlan in self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find().Vlan.find():
                vlan.Priority.ValueList(values=priorityList)
                vlan.Tpid.Single(vlanTpid[vlan_type])
                vlan.VlanId.ValueList(values=vlanIdList)
            self.log.info("VLAN Parameters Changed for Vlan {0} in {1}".format(vlan_number, device_name))
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            raise IxiaConfigException("VLAN Number not Found")
        return True

    def set_vlan(self,device_name,vlan_id,**kwargs):
        """
        Set device VLAN id and enable/disable vlan
        :param device_name: device name to set vlan id
        :param vlan_id: VLAN ID to be set
        :param kwargs:
                vlan_number: vlan ID need to be modified
                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111
                vlan_count : vlan number which need to be changes, defalut is 1
                            Ex : vlan_count = 1, vlan ID 1 will be changed
                                 vlan_count = 2, vlan ID 2 will be changed
                vlan_step : Step to increment vlan_id, default 1
                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'
                enable_vlan : enable/disable vlan based on device_name
                              Ex : enable_vlan = True, vlan is enabled on device_name
                                   enable_vlan = False, vlan is disabled on device_name

        :return: None
        :Example: set_vlan(device_name='IPv4 Device Group 1' , vlan_id = 101)
                  set_vlan(device_name='IPv4 Device Group 1'  ,vlan_id = 300,enable_vlan =True )
        """
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        enable_vlan = kwargs.get('enable_vlan', None)
        try:
            self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)
        except:
            pass
        vlan_count = kwargs.get('vlan_count', 1)
        vlan_number = kwargs.get('vlan_number', None)
        if vlan_count:
            vlanObj = deviceObj.Vlan.find()[vlan_count-1]
        else:
            vlanObj = deviceObj.Vlan.find()[0]
        vlanIdList = vlanObj.VlanId.Values
        vlanList = vlanObj.VlanId.Values
        if vlan_number:
            indexList = [index for index in range(len(vlanList)) if vlanList[index] == str(vlan_number)]
            if indexList:
                for index in indexList:
                    try:
                        vlanObj.VlanId.Overlay(index+1, str(vlan_id))
                    except:
                        pass
        else:
            vlan_direction = kwargs.get('vlan_direction', 'increment')
            vlanObj.VlanId.ClearOverlays()
            if vlan_direction.lower() == 'decrement':
                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def set_device_vlan_parameters(self, device_name,**kwargs):
        """
        Set device VLAN parameters
        :param device_name: device name to set vlan and vlan parameters
        :param kwargs:
            vlan1: (list) if vlan id 1 parameters has to be set
            priority1: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0
            tpid1: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'
            vlan2: (list) if vlan id 1 parameters has to be set
            priority2: (list/str) Priority to be set on vlan 1, Type is Integer. Range [0-7]. Default is 0
            tpid2: (list/str) Type to be set on vlan 1,  '8100', '88a8', '9100', '9200', '9300'.  Default '8100'
        :return: True if successful

        :Example: set_device_vlan_parameters(device_name='IPv4 Device Group 1',vlan1=['703-705'],priority1=['4','5','6'],tpid1=['0x88a8','0x88a8','0x88a8'])
        """
        self.log.info("Changing VLAN Parameters for device ".format(device_name))
        vlanTpid = {'0x8100': 'ethertype8100', '0x88a8': 'ethertype88a8', '0x9100': 'ethertype9100',
                    '0x9200': 'ethertype9200', '0x9300': 'ethertype9300', None: None}
        try:
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').Ethernet.find()
        except:
            raise IxiaOperationException("Device Group not Found")
        vlan1 = kwargs.get('vlan1', None)
        vlan2 = kwargs.get('vlan2', None)
        if vlan1:
            priority1 = kwargs.get('priority1', None)
            tpid1 = kwargs.get('tpid1', None)
            vlan1Obj = deviceObj.Vlan.find()[0]
            for id in vlan1:
                if '-' in id:
                    vlanList = id.split('-')
                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]
                else:
                    vlanIdList = vlan1
            vlanList1 = vlan1Obj.VlanId.Values
            tpidList1 = vlan1Obj.Tpid.Values
            priorityList1 = vlan1Obj.Priority.Values
            indexList = [index for index in range(len(vlanList1)) if vlanList1[index] in vlanIdList]
            for index in indexList:
                if type(priority1) == list:
                    for value in range(len(priorityList1)):
                        try:
                            priorityList1.pop(indexList[value])
                            priorityList1.insert(indexList[value], priority1[value])
                        except:
                            pass
                if  type(tpid1) == list:
                    for value in range(len(tpidList1)):
                        try:
                            vlan1Obj.Tpid.Overlay(indexList[value]+1, vlanTpid[tpid1[value]])
                        except:
                            pass
                if type(priority1)== str:
                    priorityList1.pop(index)
                    priorityList1.insert(index, str(priority1))
                if type(tpid1) == str:
                    try:
                        vlan1Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid1]))
                    except:
                        pass
            vlan1Obj.Priority.ValueList(values=priorityList1)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if vlan2:
            priority2 = kwargs.get('priority2', None)
            tpid2 = kwargs.get('tpid2', None)
            vlan2Obj = deviceObj.Vlan.find()[1]
            for id in vlan2:
                if '-' in id:
                    vlanList = id.split('-')
                    vlanIdList = [str(item) for item in range(int(vlanList[0]), int(vlanList[-1]) + 1)]
                else:
                    vlanIdList = vlan2
            vlanList2 = vlan2Obj.VlanId.Values
            tpidList2 = vlan2Obj.Tpid.Values
            priorityList2 = vlan2Obj.Priority.Values
            indexList = [index for index in range(len(vlanList2)) if vlanList2[index] in vlanIdList]
            for index in indexList:
                if type(priority2) == list:
                    for value in range(len(priorityList2)):
                        try:
                            priorityList2.pop(indexList[value])
                            priorityList2.insert(indexList[value], priority2[value])
                        except:
                            pass
                if  type(tpid2) == list:
                    for value in range(len(tpidList2)):
                        try:
                            vlan2Obj.Tpid.Overlay(indexList[value] + 1, vlanTpid[tpid2[value]])
                        except:
                            pass
                if type(priority2)== str:
                    priorityList2.pop(index)
                    priorityList2.insert(index, str(priority2))
                if type(tpid2) == str:
                    try:
                        vlan2Obj.Tpid.Overlay(index+1,str(vlanTpid[tpid2]))
                    except:
                        pass
            vlan2Obj.Priority.ValueList(values=priorityList2)
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _setup_stc_connection(self, server_ip, timeout=300, api_version=1):
        """
        Function NA for IXIA, added just to avoid AP error

        :param server_ip: Server IP of IXIA
        :param timeout: Timout for the IXIA connection
        :param api_version: IXIA API version
        """
        pass

    def _initiate_stream_results(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _apply(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _bll_version(self,**kwargs):
        """
        Function NA for IXIA, returns version to bypass the check
        """
        return "1.79"

    def set_auto_negotiate(self, port_list=None, auto_negotiate=True):
        """
        Function to set auto-negotiation of port speeds.

        :param port_list: List of port names
        :param auto_negotiate: True or False

        :Example: set_auto_negotiate(port_list=['port1'], auto_negotiate=False)
        """
        if port_list == None:
            for vport in self.ixNetwork.Vport.find():
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                try:
                    portObj = getattr(vport.L1Config, capitalizedCardType)
                    portObj.update(AutoNegotiate=auto_negotiate)
                except:
                    self.log.info('card type not supported to perform auto negotiation for port : %' % vport.Name)
        else:
            for port in port_list:
                vport = self.ixNetwork.Vport.find(Name=port)
                if vport.Name == port:
                    portType = vport.Type
                    capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                    try:
                        portObj = getattr(vport.L1Config, capitalizedCardType)
                        portObj.update(AutoNegotiate=auto_negotiate)
                    except:
                        self.log.info('card type not supported to perform auto negotiation for port : %' % port)
                else:
                    self.log.info('port - % not available in the config' % port)

    def _end_session(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        return self.tgn_disconnect()

    def _delete(self,**kwargs):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _connect(self, chassis_list):
        """
        Establish connection to one or more chassis.

        :param chassis_list: List of chassis (IP addresses or DNS names)
        """
        self.connect_to_chassis(chassis_list)

    def _stop_devices(self):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def _get_dict_emulated_devices(self):
        """
        Function NA for IXIA, added just to avoid AP error
        """
        pass

    def get_ospf_router_status(self, router_ids):
        """
        The API returns the ospf status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding ospf status

        :Example: get_ospf_router_status(['192.0.0.1','193.0.0.1'])
        """
        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().Ospfv2.find():
                    if routerId in ospf.LocalRouterID:
                        routerIdIndex = ospf.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def get_bgp_router_status(self, router_ids):
        """
        The API returns the bgp status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding bgp status

        :Example: get_bgp_router_status(['200.0.0.1','200.0.0.2','200.0.0.3','200.0.0.4'])
        """
        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for bgp in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    if routerId in bgp.LocalRouterID:
                        routerIdIndex = bgp.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = bgp.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def get_ospfv3_router_status(self, router_ids):
        """
        The API returns the ospfv3 status for the given router ids

        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their correspoding ospfv3 status

        :Example: get_ospfv3_router_status(['194.0.0.1','195.0.0.1'])
        """

        routerIdStatusMapping = {}
        for routerId in router_ids:
            try:
                for ospf in self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().Ospfv3.find():
                    if routerId in ospf.LocalRouterID:
                        routerIdIndex = ospf.LocalRouterID.index(routerId)
                    routerIdStatusMapping[routerId] = ospf.SessionStatus[routerIdIndex]
            except:pass

        return routerIdStatusMapping

    def set_device_count(self, device_count, router_id=None, device_name=None, **kwargs):
        """
        Set device count
        :param device_count: new device count. Should be >=1
        :param router_id: router ID of Emulated device
        :param device_name: Device Group Name
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA Device name if device count of nested DG to be set
                                And for nested device device_name param in mandatory
        :return: True if successful
                raise exception if router id not found in Ixia

        :Example: set_device_count(device_count = 5, router_id = '200.0.0.1')
                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1')
                  set_device_count(device_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')
       """
        nested_device = kwargs.get('nested_device')
        if device_count >= 1:
            if router_id and device_name == None:
                routerIdList = [routerObj.RouterId for routerObj in
                                self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
                for routerId in routerIdList:
                    if re.search(router_id, str(routerId)):
                        deviceList = [deviceGroupName.Name for deviceGroupName in
                                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
                        for device in deviceList:
                            try:
                                deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).RouterData.find().RouterId
                            except:
                                pass
                            if re.search(router_id, str(deviceRouterId)):
                                self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Multiplier = device_count
            if device_name and nested_device is None:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + device_name + '$').Multiplier = device_count
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            if device_name and nested_device:
                try:
                    self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(
                        Name='^' + nested_device + '$').Multiplier = device_count
                except:
                    pass
                try:
                    self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').DeviceGroup.find(
                        Name='^' + nested_device + '$').Multiplier = device_count
                except:
                    pass
        else:
            raise CafyException.InvalidValueError(
                'Device count (%s) has to be greater than or equal to 1' % device_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def get_link_status(self, print_info=False):
        """
        Get Link status information(Port, portStatus) for each port

        :param print_info: log link status info if this True
        :return: List of LinkStatusInfo objects

        :Example: get_link_status()
        """
        linkStatus = []
        for vport in self.ixNetwork.Vport.find():
            linkStatus.append(["Name:" + vport.Name, "State:" + vport.State])
            if print_info:
                log.info('Link Status Info for Port: %s %s' % (vport.Name, vport.State))
        return linkStatus

    def set_stream_frame(self, stream_name, frame_config):
        """
        Set the header field value of specific stream frame

        :param stream_name: stream on which specific header configured
        :param frame_config: dict with header name and field name with values to be configured \n
            Example: frame_config - single field: {'ipv4':{'sourceAddr':'10.1.1.1'}} \n
            Example: frame_config - list: {'ipv4':{'sourceAddr':['10.1.1.1','10.1.2.1','10.1.3.1']}} \n
            Example: frame_config - modifier: {'ipv4':{'destAddr':{'value': '10.1.1.10','step': '0.0.0.1', 'count': '3',
            'valueType': 'decrement','mask':'255.255.255.255'}}}
        :return: True if successful else Raise Exception

        :Example: set_stream_frame('Traffic Item 4', {'ipv4':{'dest_ip':{'value': '10.1.1.12',
                'step': '0.0.0.1', 'count': '3','valueType': 'increment','mask':'255.255.255.255'}}})
        """
        streamObj = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name)
        if not streamObj:
            raise IxiaConfigException("stream not found")
        for headerName, headerConfig in frame_config.items():
            if not headerName:
                raise IxiaConfigException("header not found")
            for headerField, headerFieldValue in headerConfig.items():
                if type(headerFieldValue) == str:
                    field = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(
                        StackTypeId=headerName.lower()).Field.find(Name=headerField)
                    field.FieldValue = headerFieldValue
                    break
                elif type(headerFieldValue) == 'list':
                    field.ValueType, field.ValueList = 'valueList', headerFieldValue
                    break
                if (headerFieldValue.keys()):
                    if 'valueType' in headerFieldValue.keys():
                        field = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name).ConfigElement.find().Stack.find(StackTypeId=headerName.lower()).Field.find(Name=headerField)
                        if headerFieldValue['valueType'].lower() == 'decrement' or headerFieldValue['valueType'].lower() == 'increment':
                            field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = headerFieldValue['valueType'], headerFieldValue['value'], headerFieldValue[
                                'count'], headerFieldValue['value'], headerFieldValue['step']
                        elif headerFieldValue['valueType'].lower() == 'nonRepeatableRandom':
                            field.ValueType, field.FieldValue, field.RandomMask = headerFieldValue['valueType'], \
                                                                                  headerFieldValue['value'], \
                                                                                  headerFieldValue['mask']
                        elif headerFieldValue['valueType'] == 'repeatableRandomRange':
                            field.ValueType, field.MinValue, field.MaxValue, field.StepValue, field.Seed, field.CountValue = headerFieldValue['valueType'], \
                                                                                                                             headerFieldValue['min'], \
                                                                                                                             headerFieldValue['max'], headerFieldValue['step'], headerFieldValue[
                                                                                                                                 'seed'], headerFieldValue['count']
                        elif headerFieldValue['valueType'] == 'random':
                            field.ValueType, field.FieldValue, field.Mask, field.Seed, field.CountValue = headerFieldValue['valueType'], headerFieldValue['min'], headerFieldValue['max'],\
                                                                                                          headerFieldValue['step'], headerFieldValue['seed'], headerFieldValue['count']
                        elif headerFieldValue['valueType'] == 'list':
                            field.ValueType, field.ValueList = 'valueList', headerFieldValue['value']

                        elif len(headerFieldValue.keys()) > 1:
                            for key in headerFieldValue.keys:
                                field = self.ixNetwork.Traffic.TrafficItem.find(
                                    Name=stream_name).ConfigElement.find().Stack.find(
                                    StackTypeId=headerName.lower()).Field.find(Name=key)
                                field.FieldValue = headerFieldValue[key]
        return True

    def set_port_transmit_deviation(self, port_list=None, deviation='enabled', deviation_value=0, **kwargs):
        """
        Sets the transmit deviation type and value for a given set of ports

        :param port_list: (list) The port(s) to configure
            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']
            Note - for IXIA all ports in the same group will be enabled/disabled regardless of port_list
        :param deviation: (str) Selects whether transmit deviation is enabled or disabled
            e.g. 'enabled', 'disabled'
        :param deviation_value: (int/str): The desired PPM deviation value
            e.g. 10, "10"
        :param kwargs:
                    wait_interval : (int) sleep time default 0
                    repetition : (int) Number of time opertaion to be repeated Ex : 5
                    operation : "increment"/"decrement" if "decrement" then negative deviation_value will be set EX : -10
        :return: True on success, exception otherwise

        :Example: set_port_transmit_deviation(deviation_value=10)
                  set_port_transmit_deviation(deviation_value=10,operation="increment",wait_interval=5, repetition=2)
        """
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)
        operation = kwargs.get("operation", "increment")
        if operation == "decrement":
            deviation_value = - deviation_value

        cardTypeList = ['atlasFourHundredGigLan',
                        'atm',
                        'ethernet',
                        'ethernetImpairment',
                        'ethernetvm',
                        'fc',
                        'fortyGigLan',
                        'hundredGigLan',
                        'krakenFourHundredGigLan',
                        'novusHundredGigLan',
                        'novusTenGigLan',
                        'pos',
                        'tenFortyHundredGigLan',
                        'tenGigLan',
                        'tenGigWan',
                        'aresOneFourHundredGigLan']

        while repetition != 0:
            if port_list:
                for port in port_list:
                    cardType = self.ixNetwork.Vport.find(Name=port).Type
                    if cardType in cardTypeList:
                        cardType = cardType[0].upper() + cardType[1:]
                    else:
                        err_msg = 'Card type: {} not found. Code may need to be updated to support it'.format(cardType)
                        raise CafyException.InvalidValueError(err_msg)
                    if deviation.lower() == 'enabled':
                        cardObj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + cardType)
                        cardObj.EnablePPM = True
                        cardObj.Ppm = deviation_value

                    elif deviation.lower() == 'disabled':
                        cardObj = eval('self.ixNetwork.Vport.find(Name=port).L1Config.' + cardType)
                        cardObj.EnablePPM = False
                        cardObj.Ppm = deviation_value
            else:
                vports = self.ixNetwork.Vport.find()
                vports.ReleasePort()
                for vport in self.ixNetwork.Vport.find():
                    cardType = vport.Type
                    if cardType in cardTypeList:
                        cardType = cardType[0].upper() + cardType[1:]
                    else:
                        err_msg = 'Card type: {} not found. Code may need to be updated to support it'.format(cardType)
                        raise CafyException.InvalidValueError(err_msg)
                    if deviation.lower() == 'enabled':
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.EnablePPM = True
                        cardObj.Ppm = deviation_value
                    elif deviation.lower() == 'disabled':
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.EnablePPM = False
                        cardObj.Ppm = deviation_value

                vports.ConnectPorts()

            time.sleep(wait_interval)
            repetition -= 1
        return True

    def new_session(self, user_name=None, session_name=None, kill_existing=False):
        """
        Creates a new test session. Applicable only for Linux or Windows Connection Manager

        :param user_name: User name part of session ID.
        :param session_name: Session name part of session ID.
        :param kill_existing: If there is an existing session, with the same session name
                              and user name, then terminate it before creating a new session
        :return: True is session started, False if session was already started.

        :Example: new_session(()
        """
        self.log.info("Creating new Session")
        self._new_session(user_name=user_name, session_name=session_name, kill_existing=kill_existing)
        self.log.info("Created new session - '%s'"%self.session_name)

        return True

    def isListEmpty(self, inList):
        """
        Check if the list is empty for each port,This API is not applicable to ixia

        :param inList: list of streams per port

        :Example: isListEmpty([])
        """
        pass

    def get_router_ids(self, device_list=None):
        """
        Retrieves router IDs for a given set of devices

        :param device_list: (str/list) A single device or a list of devices
                to retrieve the router id for. If None get for all devices
                e.g. 'device1' or ['device1', 'device2']
        :returns: a dict of device names/router IDs on pass, exception on failure

        :Example: get_router_ids(device_list=['Device Group 4','Device Group 3'])
        """
        devices_to_check = []
        router_ids = {}
        if device_list:
            if isinstance(device_list, str):
                devices_to_check = device_list.split(',')
            elif isinstance(device_list, list):
                devices_to_check = device_list
            else:
                raise CafyException.InvalidValueError('Invalid input type for device_list. Please use a str or a list')
        else:
            devices_to_check = self.get_device_names()
        for device in devices_to_check:
            deviceName = device
            dName = '^' + deviceName.replace('/', '\/').replace('(', '\(').replace(')', '\)') + '$'
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + dName + '$'):
                try:
                    routerId = deviceGroupObj.RouterData.find().RouterId.Values
                    router_ids[device] = [str(id) for id in routerId]
                except:
                    pass
        return router_ids

    def enable_ping(self, router_id='all'):
        """
        Enable the ping on a device or on all devices, ping enabled by default in IXIA

        :param router_id: Router ID of the device
        :return: True on success else raises exception

        :Example: enable_ping()
        """

        return True

    def disable_ping(self, router_id='all'):
        """
        Disable the ping on a device or on all devices

        :param router_id: Router ID of the device
        :return: True on success else raises exception

        :Example: disable_ping()
        """

        return True

    def get_device_ip_info(self, router_id, ip_version='ipv4', key=None):
        """
        Get emulated device IP info

        :param router_id: Router ID of the device
        :param ip_version: IP Version
        :param key: Get specific key value
        :return: Device key info

        :Example: get_device_ip_info("192.0.0.1", ip_version='ipv4', key='Address')
        """
        if ip_version not in ('ipv4', 'ipv6'):
            raise IxiaOperationException("Invalid Ip version")

        if type(router_id) is str:
            router_id = router_id.split(",")

        routerIdList = self.get_device_names()
        flag = False
        ipFieldsList = []
        for routerId in router_id:
            if '.' in routerId:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                            routerId = deviceGroupObj.Name
                            break
            else:
                routerId = routerId
            if routerId in routerIdList:
                flag = True
                if ip_version == 'ipv4':
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find()
                else:
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find()

                ipFieldsList = re.findall('([a-zA-z]+): (.*)', str(ipData))
                ipFieldsList.pop(0)
                ipFieldsList = dict(ipFieldsList)
                if ip_version == 'ipv4':
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv4.find().Address.Values
                else:
                    ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + routerId + '$').Ethernet.find().Ipv6.find().Address.Values
                ipFieldsList['address'] = ipData

        if not flag:
            raise IxiaOperationException("Router id not found")
        if not key:
            return ipFieldsList
        if key not in ipFieldsList:
            raise IxiaConfigException("key not available in ip info")
        return ipFieldsList[key]

    def set_bgp_route_count_all(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs. For IXIA, network_group has to be included in the kwargs as a mandatory parameter and ports is optional
        :return: True if the operation is successful, False otherwise

        :Example: set_bgp_route_count_all(route_count=20, ip_type="ipv4")
        """
        protocolStatus = False
        self.log.info("Setting Bgp Route Count for all devices with bgp configured")
        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for deviceName in deviceNameList:
            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():
                        if ipv4PoolObj.BgpIPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                        if ipv4PoolObj.BgpV6IPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                else:
                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name=networkGroupObj.Name).Ipv6PrefixPools.find():
                        if ipv6PoolObj.BgpV6IPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
                        if ipv6PoolObj.BgpIPRouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("BGP protocol not configured or Configuration issue.")

    def set_isis_route_count_all(self, route_count, ip_type="ipv4", **kwargs):
        """
        Configures the route count for all isis devices. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
        :return: True if the operation is successful, False otherwise

        :Example: set_isis_route_count_all(route_count=20, ip_type="ipv4")
        """
        protocolStatus = False
        self.log.info("Setting ISIS Route Count for all devices with ISIS configured")
        deviceNameList = [deviceGroupObj.Name for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for deviceName in deviceNameList:
            for networkGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).NetworkGroup.find():
                if ip_type.lower() == "ipv4":
                    for ipv4PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv4PrefixPools.find():
                        if ipv4PoolObj.IsisL3RouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv4PoolObj, route_count)
                else:
                    for ipv6PoolObj in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name=networkGroupObj.Name).Ipv6PrefixPools.find():
                        if ipv6PoolObj.IsisL3RouteProperty.find():
                            protocolStatus = True
                            self._set_route_count(ipv6PoolObj, route_count)
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("ISIS protocol not configured or Configuration issue.")

    def get_device_names(self):
        """
        Retrieves a list of device names

        :returns: device_names (list) on pass, exception on failure

        :Example: get_device_names()
        """
        deviceList = []
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        return deviceList

    def enable_gateway_mac_address(self, ip_type, router_ids=None):
        """
        The API sets the gateway mac status to True

        :param ip_type: ipv4/ipv6
        :param router_ids: List of router_ids
        :return: return True if gateway mac address is enabled else raises exception

        :Example: enable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])
        """
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        routerIdList = [routerObj.RouterId for routerObj in
                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
        if router_ids is not None:
            for routerId in router_ids:
                routerId = ' ' + routerId
                if re.search(routerId, str(routerIdList)):
                    for device in deviceList:
                        try:
                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).RouterData.find().RouterId
                        except:
                            pass
                        if re.search(routerId, str(deviceRouterId)):
                            if ip_type == 'ipv4':
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)
                            else:
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)
                else:
                    raise IxiaConfigException('router id %s not found ', routerId)
        else:
            for device in deviceList:
                deviceRouterId = None
                try:
                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=device).RouterData.find().RouterId
                except:
                    pass
                if re.search('\d+.\d+.\d+.\d+', str(deviceRouterId)):
                    if ip_type == 'ipv4':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(True)
                        except:
                            pass
                    elif ip_type == 'ipv6':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(True)
                        except:
                            pass
        return True

    def disable_gateway_mac_address(self, ip_type, router_ids=None):
        """
        The API sets the gateway mac status to True

        :param ip_type: ipv4/ipv6
        :param router_ids: List of router_ids
        :return: return True if gateway mac address is enabled else raises exception

        :Example: disable_gateway_mac_address('ipv4', router_ids=['200.0.0.1'])
        """
        deviceList = [deviceGroupName.Name for deviceGroupName in
                      self.ixNetwork.Topology.find().DeviceGroup.find() if deviceGroupName]
        routerIdList = [routerObj.RouterId for routerObj in
                        self.ixNetwork.Topology.find().DeviceGroup.find().RouterData.find()]
        if router_ids is not None:
            for routerId in router_ids:
                routerId = ' ' + routerId
                if re.search(routerId, str(routerIdList)):
                    for device in deviceList:
                        try:
                            deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).RouterData.find().RouterId
                        except:
                            pass
                        if re.search(routerId, str(deviceRouterId)):
                            if ip_type == 'ipv4':
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)
                            else:
                                ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                    Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)
                else:
                    raise IxiaConfigException('router id %s not found ', routerId)
        else:
            for device in deviceList:
                deviceRouterId = None
                try:
                    deviceRouterId = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=device).RouterData.find().RouterId
                except:
                    pass
                if re.search('\d+.\d+.\d+.\d+', str(deviceRouterId)):
                    if ip_type == 'ipv4':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv4.find().ResolveGateway.Single(False)
                        except:
                            pass
                    elif ip_type == 'ipv6':
                        try:
                            ipData = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name=device).Ethernet.find().Ipv6.find().ResolveGateway.Single(False)
                        except:
                            pass
        return True

    def change_ipv4_ipv6_src_address(self, cfg_dict, traffic_item_list=None):
        '''
        Changes the IPv4/Ipv6 source address configuration for a given set
        of traffic streams

        :param cfg_dict: Dict including the data need to be modified
        :param traffic_item_list: List of traffic Items name. All Items if it is None.

        :Example: tgnObj.change_ipv4_ipv6_src_address(traffic_item_list=["Traffic Item 4"],cfg_dict={'fieldValue':"3.3.53.3",'startValue':"3.3.53.3",'valueType':"increment",'countValue':100})
        '''

        self.log.info("Change IPv4/IPv6 Source Address %s")
        if traffic_item_list:
            for trafficItemName in traffic_item_list:
                trafficItemName = '^'+trafficItemName+'$'
                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find():
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")

                    else:
                        raise IxiaConfigException("Ipv4/Ipv6 stack not configured on %s" % trafficItemName)
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None),\
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Source Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")
                except:pass
        self.log.info("IPv4/Ipv6 Source Address Updated in Traffic Items")

    def change_ipv4_ipv6_dst_address(self, cfg_dict, traffic_item_list=None):
        '''
        Changes the IPv4/Ipv6 source address configuration for a given set
        of traffic streams

        :param cfg_dict: Dict including the data need to be modified
        :param traffic_item_list: List of traffic Items name. All Items if it is None.

        :Example: tgnObj.change_ipv4_ipv6_dst_address(traffic_item_list=["Traffic Item 4"],cfg_dict={'fieldValue':"3.3.53.3",'startValue':"3.3.53.3",'valueType':"increment",'countValue':100})
        '''

        self.log.info("Change IPv4/IPv6 Source Address %s")
        if traffic_item_list:
            for trafficItemName in traffic_item_list:
                trafficItemName = '^' + trafficItemName + '$'
                for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficItemName).ConfigElement.find():
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Destination Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Destination Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")

                    else:
                        raise IxiaConfigException("Ipv4/Ipv6 stack not configured on %s" % trafficItemName)
        else:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find().ConfigElement.find():
                try:
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Destination Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "0.0.0.1")
                    elif configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        fieldNames = [fieldObj.DisplayName for fieldObj in stackObj.Field.find()]
                        for fieldName in fieldNames:
                            if fieldName.lower() == 'Destination Address'.lower():
                                field = stackObj.Field.find(DisplayName=fieldName)
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = cfg_dict.get('valueType', 'singleValue'), \
                                                                                                                         cfg_dict.get('fieldValue', None), cfg_dict.get('countValue', None), \
                                                                                                                         cfg_dict.get('startValue', None), cfg_dict.get('stepValue', "::1")
                except:pass
        self.log.info("IPv4/Ipv6 Destination Address Updated in Traffic Items")
        return True

    def _addTimestampToFile(self,filename):
        """
        Function used internally by API rfc2544_quicktest

        :param filename: filename for which timestamp to be added
        """
        currentTimestamp = datetime.datetime.now().strftime('%H%M%S')
        if '\\' in filename:
            filename = filename.split('\\')[-1]

        if '/' in filename:
            filename = filename.split('/')[-1]

        newFilename = filename.split('.')[0]
        newFileExtension = filename.split('.')[1]
        newFileWithTimestamp = '{}_{}.{}'.format(newFilename, currentTimestamp, newFileExtension)
        return newFileWithTimestamp

    def _getQuickTestCurrentAction(self,quickTestHandle):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: QucikTestHandle to test current Action
        """
        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber
        match = re.match('([0-9]+)\.[^ ]+ *', ixNetworkVersion)
        ixNetworkVersion = int(match.group(1))

        if ixNetworkVersion >= 8:
            timer = 10
            for counter in range(1, timer + 1):
                currentActions = quickTestHandle.Results.CurrentActions

                self.log.info('\n\ngetQuickTestCurrentAction:\n')
                for eachCurrentAction in quickTestHandle.Results.CurrentActions:
                    self.log.info('\t{}'.format(eachCurrentAction['arg2']))

                self.log.info('\n')

                if counter < timer and currentActions == []:
                    self.log.info('\n\ngetQuickTestCurrentAction is empty. Waiting %s/%s\n\n' % (counter, timer))
                    time.sleep(1)
                    continue

                if counter < timer and currentActions != []:
                    break

                if counter == timer and currentActions == []:
                    raise Exception('\n\ngetQuickTestCurrentActions: Has no action')

            return currentActions[-1]['arg2']
        else:
            return quickTestHandle.Results.Progress

    def _verifyQuickTestInitialization(self,quickTestHandle):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: QucikTest handle to verify Quick Test Initilization
        """
        for timer in range(1, 30 + 1):
            currentAction = self._getQuickTestCurrentAction(quickTestHandle)
            self.log.info('\n\nverifyQuickTestInitialization currentAction: {}\n'.format(currentAction))
            if currentAction == 'TestEnded':
                raise Exception('VerifyQuickTestInitialization: QuickTest failed during initialization: {}'.format(quickTestHandle.Results.Status))

            if timer < 30 and currentAction == 'None':
                self.log.info('\n\nverifyQuickTestInitialization CurrentState = %s\n\tWaiting %s/30 seconds to change state\n' % (currentAction, timer))
                time.sleep(1)
                continue
            else:
                break

            if timer == 20 and currentAction == 'None':
                raise Exception('\n\nQuick Test is stuck.')

        successStatusList = ['TransmittingComplete', 'TransmittingFrames', 'WaitingForStats', 'CollectingStats', 'TestEnded']
        quickTestApplyStates = ['InitializingTest', 'ApplyFlowGroups', 'SetupStatisticsCollection']
        ixNetworkVersion = self.ixNetwork.Globals.BuildNumber
        match = re.match('([0-9]+)\.[^ ]+ *', ixNetworkVersion)
        ixNetworkVersion = int(match.group(1))

        applyQuickTestCounter = 120
        for counter in range(1, applyQuickTestCounter + 1):
            currentAction = self._getQuickTestCurrentAction(quickTestHandle)
            self.log.info('\n\nverifyQuickTestInitialization: CurrentState: %s  Expecting: TransmittingFrames\n\tWaiting %s/%s seconds\n' % (currentAction, counter, applyQuickTestCounter))

            if currentAction == 'TestEnded':
                raise Exception('\n\nVerifyQuickTestInitialization: QuickTest failed!!: {}'.format(quickTestHandle.Results.Status))

            if currentAction == None:
                currentAction = 'ApplyingAndInitializing'

            if ixNetworkVersion >= 8:
                if counter < applyQuickTestCounter and currentAction not in successStatusList:
                    time.sleep(1)
                    continue

                if counter < applyQuickTestCounter and currentAction in successStatusList:
                    self.log.info('\n\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\n')
                    break

            if ixNetworkVersion < 8:
                if counter < applyQuickTestCounter and currentAction != 'ApplyingAndInitializing':
                    time.sleep(1)
                    continue

                if counter < applyQuickTestCounter and currentAction == 'ApplyingAndInitializing':
                    self.log.info('\n\nVerifyQuickTestInitialization is done applying configuration and has started transmitting frames\n')
                    break

            if counter == applyQuickTestCounter:
                if ixNetworkVersion >= 8 and currentAction not in successStatusList:
                    if currentAction == 'ApplyFlowGroups':
                        self.log.info('\n\nVerifyQuickTestInitialization: IxNetwork is stuck on Applying Flow Groups. You need to go to the session to FORCE QUIT it.\n')

                    raise Exception('\n\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (
                        currentAction, counter, applyQuickTestCounter))

                if ixNetworkVersion < 8 and currentAction != 'Trial':
                    raise Exception('\n\nVerifyQuickTestInitialization is stuck on %s. Waited %s/%s seconds' % (
                        currentAction, counter, applyQuickTestCounter))

    def _monitorQuickTestRunningProgress(self,quickTestHandle, getProgressInterval=10):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: qucikTest Handle
        :param getProgressInterval: Progressinterval
        """
        isRunningBreakFlag = 0
        trafficStartedFlag = 0
        waitForRunningProgressCounter = 0
        counter = 1
        connectionFailureCounter = 0
        maxRetries = 10

        while True:
            # This while loop was implemented because sometimes there could be failure to connect to the
            # API server.  It could be caused by many various issues not related to IxNetwork.
            # Going to retry doing GETs up to 10 times.
            connectedToApiServerFlag = False

            while True:
                try:
                    isRunning = quickTestHandle.Results.IsRunning
                    currentRunningProgress = quickTestHandle.Results.Progress
                    self.log.info('\nmonitorQuickTestRunningProgress: isRuning: %s', isRunning)
                    break
                except:
                    self.log.info('\n\nmonitorQuickTestRunningProgress: Failed to connect to API server {}/{} times\n'.format(connectionFailureCounter, maxRetries))
                    if connectionFailureCounter == maxRetries:
                        raise Exception('\n\nmonitorQuickTestRunningProgress: Giving up trying to connecto the the API server after {} attempts\n'.format(maxRetries))

                    if connectionFailureCounter <= maxRetries:
                        connectionFailureCounter += 1
                        time.sleep(3)
                        continue

            self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning: {}  CurrentRunningProgress: {}\n'.format(isRunning, currentRunningProgress))

            if isRunning == True:
                if bool(re.match('^Trial.*', currentRunningProgress)) == False:
                    if waitForRunningProgressCounter < 40:
                        self.log.info('\n\nmonitorQuickTestRunningProgress: Waiting for trial runs {0}/30 seconds\n'.format(waitForRunningProgressCounter))
                        waitForRunningProgressCounter += 1
                        time.sleep(1)

                    if waitForRunningProgressCounter == 40:
                        raise Exception('\n\nmonitorQuickTestRunningProgress: isRunning=True. QT is running, but no quick test iteration stats showing after 40 seconds.')
                else:
                    # The test is running fine.  Keep running until isRunning == False.
                    trafficStartedFlag = 1
                    time.sleep(getProgressInterval)
                    continue
            else:
                if trafficStartedFlag == 1:
                    # We only care about traffic not running in the beginning.
                    # If traffic ran and stopped, then break out.
                    self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning=False. Quick Test ran and is complete\n\n')
                    return True

                if trafficStartedFlag == 0 and isRunningBreakFlag < 40:
                    self.log.info('\n\nmonitorQuickTestRunningProgress: isRunning=False. QT did not run yet. Wait {0}/40 seconds\n\n'.format(isRunningBreakFlag))
                    isRunningBreakFlag += 1
                    time.sleep(1)
                    continue

                if trafficStartedFlag == 0 and isRunningBreakFlag == 40:
                    raise Exception('\n\nmonitorQuickTestRunningProgress: Quick Test failed to start:: {}'.format(quickTestHandle.Results.Status))

    def _copyFileWindowsToLocalWindows(self,windowsPathAndFileName, localPath, includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param windowsPathAndFileName: windowspathandfilename
        :param localPath: localpath
        :param includeTimestamp: boolean True or False
        """
        self.log.info('\n\ncopyFileWindowsToLocalWindows: From: %s to %s\n\n' % (windowsPathAndFileName, localPath))
        fileName = windowsPathAndFileName.split('\\')[-1]
        fileName = fileName.replace(' ', '_')
        if includeTimestamp:
            fileName = self._addTimestampToFile(fileName)

        destinationPath = localPath + '\\' + fileName
        self.log.info('\nCopying from {} -> {}'.format(windowsPathAndFileName, destinationPath))
        self.ixNetwork.CopyFile(windowsPathAndFileName, destinationPath)

    def _copyApiServerFileToLocalLinux(self,apiServerPathAndFileName, localPath, localPathOs='linux', includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param apiServerPathAndFileName: apiServerPathAndFileName
        :param localPath: localPath
        :param localPathOs: localPathOs
        :param includeTimestamp: boolean True or False
        """
        if '/' in apiServerPathAndFileName:
            fileName = apiServerPathAndFileName.split('/')[-1]

        if '\\' in apiServerPathAndFileName:
            fileName = apiServerPathAndFileName.split('\\')[-1]

        fileName = fileName.replace(' ', '_')

        if includeTimestamp:
            fileName = self._addTimestampToFile(fileName)

        if localPathOs == 'linux':
            destinationPath = localPath + '/' + fileName

        if localPathOs == 'windows':
            destinationPath = localPath + '//' + fileName

        self.log.info('\nCopying file from API server:{} -> {}'.format(apiServerPathAndFileName, destinationPath))
        self.session.DownloadFile(apiServerPathAndFileName, destinationPath)

    def _getQuickTestCsvFiles(self,quickTestHandle, copyToPath, csvFile='all', includeTimestamp=False):
        """
        Function used internally by API rfc2544_quicktest

        :param quickTestHandle: quickTestHandle
        :param copyToPath: copyToPath
        :param csvFile: csvFile
        :param includeTimestamp: boolean True or False
        """
        resultsPath = quickTestHandle.Results.ResultPath
        self.log.info('\ngetQuickTestCsvFiles: %s' % resultsPath)

        if csvFile == 'all':
            getCsvFiles = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']
        else:
            if type(csvFile) is not list:
                getCsvFiles = [csvFile]
            else:
                getCsvFiles = csvFile

        for eachCsvFile in getCsvFiles:
            # Backslash indicates the results resides on a Windows OS.
            if '\\' in resultsPath:
                windowsSource = resultsPath + '\\{0}'.format(eachCsvFile)

                if bool(re.match('[a-z]:.*', copyToPath, re.I)):
                    self._copyFileWindowsToLocalWindows(windowsSource, copyToPath, includeTimestamp=includeTimestamp)
                else:
                    # Copy From Windows API server to local Linux client filesystem
                    self._copyApiServerFileToLocalLinux(windowsSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)

            else:
                linuxSource = resultsPath + '/{0}'.format(eachCsvFile)

                # Copy from Linux api server to Local Linux client filesystem.
                try:
                    self.log.info('\nCopying file from Linux API server:{} to local Linux:{}'.format(linuxSource, eachCsvFile))
                    self._copyApiServerFileToLocalLinux(linuxSource, copyToPath, localPathOs='linux', includeTimestamp=includeTimestamp)

                except Exception as errMsg:
                    self.log.info('copyApiServerFileToLocalLinux ERROR: %s', errMsg)

    def rfc2544_quicktest(self,name,options_dict,result_type='csv',timeout=600):
        """
        Creates a new rfc2544 throughput quicktest and configs the desired parameters

        :param name: (str) The name given to the new quicktest e.g. 'RFC2544_QuickTest'
        :param options_dict: (dict) A dict of options to configure

        :Traffic Selection Options:
            traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\n
            flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']\n
            background_traffic_items (list): e.g. ['StaticRoute1-4', 'StaticIPv6']\n
            background_flow_items (list): e.g. ['StaticRoute1-4-EndpointSet-1 - Flow Group 0001','StaticRoute1-4-EndpointSet-2 - Flow Group 0001']

        :Protocol Options:
            protocol_state (str): e.g. default, restart, stop, start\n
            wait_after_start (int): e.g. 120\n
            wait_after_stop (int): e.g. 30\n

        :Traffic Options:
            regenerate_traffic (bool): e.g. True, False\n
            frame_size_mode (str): e.g. increment, random, custom, unchanged\n
            start_size (int): e.g. 64\n
            step_size (int): e.g. 1\n
            end_size (int): e.g. 1280\n
            custom_frame_size (list): e.g ['64', '128', '256', '512', '1024']\n
            use_4_byte_sig (bool): e.g. True, False

        :Learning Frame Options
            learning_Frequency (str): e.g. never,onBinaryIteration,oncePerFramesize,oncePerTest,onTrial\n

        :Stats Parameters Options:
            aggregate_per_iteration (bool): e.g. True, False\n
            show_flooded_frames (bool): e.g. True, False\n
            calculate_latency (bool): e.g. True, False\n
            latency_type (str): e.g. 'cutThrough, forwardingDelay, mef, storeForward'\n
            calculate_jitter (bool): e.g. True, False\n
            sequence_errors (bool): e.g. True, False\n
            data_integrity_checl (bool): e.g. True, False\n
            tx_rx_l1_rates (bool): e.g. True, False\n
            per_flow_stats (bool): e.g. True, False\n
            per_port_stats (bool): e.g. True, False

        :Test Parameters Options:
            duration (int): e.g. 300\n
            trials (int): e.g. 2\n
            initial_rate (double): e.g. 10\n
            min_rate (double): e.g. 10\n
            max_rate (double): e.g. 99.99\n
            resolution (double): e.g. 3\n
            backoff (double): e.g. 50
            acceptable_frame_loss (double): e.g 5

        :param result_type: (str) Choose whether you want to save results as a csv, pdf, or both
        :param timeout: The timeout value set before failing the quicktest

        :return: True if successful, else raise an exception

        :Example: rfc2544_quicktest("QuickTestRFC2544",options_dict={'regenerate_traffic':True,'traffic_items':['Traffic Item 1']},result_type='csv',timeout=600)
        """

        quickTestHandle = self.ixNetwork.QuickTest.Rfc2544throughput.add(Name=name,ForceApplyQTConfig=None, Mode='existingMode')
        # for quickTestHandle in self.ixNetwork.QuickTest.Rfc2544throughput.find():

        if self.tgn_server_type == "linux":
            api_key = self.testPlatform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        quicktest_href = quickTestHandle.href
        #RestAPI
        protocols_args = {'protocol_state': 'protocolState', 'wait_after_start': 'waitAfterStart',
                          'wait_after_stop': 'waitAfterStop'}

        traffic_options_args = {'regenerate_traffic': 'forceRegenerate', 'frame_size_mode': 'frameSizeMode',
                                'start_size': 'minIncrementFrameSize', 'step_size': 'stepIncrementFrameSize',
                                'end_size': 'maxIncrementFrameSize', 'custom_frame_size': 'framesizeList',
                                'use_4_byte_sig': 'enableMinFrameSize'}

        learning_options_args = {'learning_Frequency': 'learnFrequency'}

        stats_parameters_args = {'aggregated_results_per_iteration': '', 'flooded_frames': 'floodedFramesEnabled',
                                 'calculate_latency': 'calculateLatency', 'latency_type': 'latencyType',
                                 'calculate_jitter': 'calculateJitter', 'sequence_errors': 'reportSequenceError',
                                 'data_integrity_check': 'enableDataIntegrity', 'tx_rx_l1_rates': 'enableLayer1Rate',
                                 'per_flow_stats': '', 'per_port_stats': ''}

        test_parameters_args = {'duration': 'duration', 'trials': 'numtrials', 'initial_rate': 'initialBinaryLoadRate',
                                'min_rate': 'minBinaryLoadRate', 'max_rate': 'maxBinaryLoadRate',
                                'resolution': 'binaryResolution', 'backoff': 'binaryBackoff',
                                'acceptable_frame_loss': 'binaryTolerance', 'load_type': 'loadType','custom_load_list':'loadRateList'}

        # Get traffic item hrefs
        traffic_item_hrefs = []
        background_traffic_item_hrefs = []
        flow_item_hrefs = []
        background_flow_item_hrefs = []
        streams = self.get_traffic_items()
        for stream in streams:
            if 'traffic_items' in options_dict:
                if stream in options_dict['traffic_items']:
                    traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)
            if 'background_traffic_items' in options_dict:
                if stream in options_dict['background_traffic_items']:
                    background_traffic_item_hrefs.append(self.ixNetwork.Traffic.TrafficItem.find(Name='^'+stream+'$').href)

        url = server_url + quicktest_href + '/trafficSelection'
        for href in traffic_item_hrefs:
            traffic_item_type = self.ixNetwork.Traffic.TrafficItem.read(traffic_item_hrefs[0]).TrafficType
            if traffic_item_type == 'raw':
                traffic_item_type = 'mac'
            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'inTest','trafficItemType': traffic_item_type}
            requests.post(url, json=data, headers=headers, verify=False)
        for href in background_traffic_item_hrefs:
            data = {'__id__': href, 'itemType': 'trafficItem', 'includeMode': 'background'}
            requests.post(url, json = data, headers=headers,verify=False)
        for href in flow_item_hrefs:
            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'inTest'}
            requests.post(url, json = data, headers=headers,verify=False)
        for href in background_flow_item_hrefs:
            data = {'__id__': href, 'itemType': 'flowGroup', 'includeMode': 'background'}
            requests.post(url, json = data, headers=headers,verify=False)

        # Modify the protocol options
        url = server_url + quicktest_href + '/protocols'
        protocol_args_config = {}
        for key, value in protocols_args.items():
            if key in options_dict.keys():
                protocol_args_config[value] = options_dict[key]
        if protocol_args_config:
            log.info('Configuring the quicktest protocol options...')
            requests.patch(url, json = protocol_args_config, headers=headers,verify=False)

        # Modify the traffic options
        url = server_url + quicktest_href + '/testConfig'
        traffic_options_config = {}
        for key, value in traffic_options_args.items():
            if key in options_dict.keys():
                traffic_options_config[value] = options_dict[key]
        if traffic_options_config:
            log.info('Configuring the quicktest traffic options...')
            requests.patch(url, json = traffic_options_config, headers=headers,verify=False)

        # Modify Learning frames
        url = server_url + quicktest_href + '/learnFrames'
        learn_frames_config = {}
        for key, value in learning_options_args.items():
            if key in options_dict.keys():
                learn_frames_config[value] = options_dict[key]
        if learn_frames_config:
            log.info('Configuring the quicktest learning frame options...')
            requests.patch(url, json=learn_frames_config, headers=headers, verify=False)

        # Modify the stats parameters options
        url =server_url + quicktest_href + '/testConfig'
        stats_parameters_config = {}
        for key, value in stats_parameters_args.items():
            if key in options_dict.keys():
                stats_parameters_config[value] = options_dict[key]
        if stats_parameters_config:
            log.info('Configuring the quicktest stats parameters...')
            requests.patch(url, json = stats_parameters_config, headers=headers,verify=False)

        # Modify the test parameters options
        url = server_url + quicktest_href + '/testConfig'
        test_parameters_config = {}
        for key, value in test_parameters_args.items():
            if key in options_dict.keys():
                if key == 'custom_load_list':
                    options_dict['custom_load_list'] = ','.join(map(str, options_dict['custom_load_list']))
                test_parameters_config[value] = options_dict[key]
        if test_parameters_config:
            log.info('Configuring the quicktest test parameters...')
            requests.patch(url, json=test_parameters_config, headers=headers, verify=False)

        #Restpy
        quickTestHandle.Apply()
        quickTestHandle.Start()
        self._verifyQuickTestInitialization(quickTestHandle)
        self._monitorQuickTestRunningProgress(quickTestHandle)

        try:
            # Store the results in the working dir
            path = CafyLog.work_dir + '/quicktest_results/{}'.format(name)
            os.makedirs(path)
            self.log.info('Saving quick test results to the following dir: {}'.format(path))
        except:
            # Quicktest results dir already exists - skip this step
            self.log.info('Quick test results folder {} already exists - copy the new results over'.format(path))

        linuxDestinationFolder = path
        windowsDestinationFolder = path

        if options_dict.get("load_type", "").lower() == "unchanged":
            csvFiles = ['AggregateResults.csv', 'results.csv', 'logFile.txt', 'portMap.csv']
        else:
            csvFiles = ['AggregateResults.csv', 'iteration.csv', 'results.csv', 'logFile.txt', 'portMap.csv']

        if result_type == 'csv' or result_type == 'both':
            self._getQuickTestCsvFiles(quickTestHandle, csvFile=csvFiles, copyToPath=path, includeTimestamp=False)

        if result_type == 'pdf' or result_type == 'both':
            if self.tgn_server_type != 'linux':
                pdfFile = quickTestHandle.GenerateReport()
                destPdfTestResult = self._addTimestampToFile(pdfFile)

                # Copying the PDF from Windows to local Windows.
                self._copyFileWindowsToLocalWindows(pdfFile, windowsDestinationFolder + '\\' + destPdfTestResult)

                # Copying PDF from either a Windows API server or from a Linux API server to local Linux filesystem.
                self.log.info('Copying test result PDF to: {}'.format(linuxDestinationFolder + destPdfTestResult))
                self.session.DownloadFile(pdfFile, linuxDestinationFolder + destPdfTestResult)

        # Check the result to see if the test passed
        result = quickTestHandle.Results.Result
        if result == 'pass':
            log.info('RFC2544 Throughput Quicktest {} has passed'.format(name))
            return True
        else:
            log.info('RFC2544 Throughput Quicktest {} did not pass'.format(name))
            return False

    def _get_igmp_mld_dict_info(self, igmpMldObj, vlanIndex):
        """
        Function used internally by APIs to get emulated devices and their multicast information.

        :param igmpMldObj: Igmp or Mld object handle
        :param vlanIndex: Vlan id index
        :return: Return emulated devices and thier multicast information
        """
        igmpMldDict = dict()
        if "igmp" in igmpMldObj.href:
            igmpMldDict["igmp"] = {}
            igmpVersion = "IGMP_V2"
            versionTypeValues = igmpMldObj.VersionType.Values
            startMcastAddr = igmpMldObj.IgmpMcastIPv4GroupList.StartMcastAddr.Values
            groupAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.McastAddrCnt.Values
            sourceRange = igmpMldObj.IgmpMcastIPv4GroupList.NoOfSrcRanges
            sourceAddrCount = igmpMldObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
            if versionTypeValues[vlanIndex] == "version3":
                igmpVersion = "IGMP_V3"
            igmpMldDict["igmp"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["igmp"]["source_list"] = sourceAddrCount[vlanIndex*sourceRange]
            igmpMldDict["igmp"]["start_group_address"] = startMcastAddr[vlanIndex]
            igmpMldDict["igmp"]["version"] = igmpVersion
        if "mld" in igmpMldObj.href:
            igmpMldDict["mld"] = {}
            mldVersion = "MLD_V1"
            versionTypeValues = igmpMldObj.VersionType.Values
            startMcastAddr = igmpMldObj.MldMcastIPv6GroupList.StartMcastAddr.Values
            groupAddrCount = igmpMldObj.MldMcastIPv6GroupList.McastAddrCnt.Values
            sourceRange = igmpMldObj.MldMcastIPv6GroupList.NoOfSrcRanges
            sourceAddrCount = igmpMldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
            if versionTypeValues[vlanIndex] == "version2":
                mldVersion = "MLD_V2"
            igmpMldDict["mld"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["mld"]["source_list"] = sourceAddrCount[vlanIndex*sourceRange]
            igmpMldDict["mld"]["start_group_address"] = startMcastAddr[vlanIndex]
            igmpMldDict["mld"]["version"] = mldVersion
        if "pimV4" in igmpMldObj.href:
            igmpMldDict["pimV4"] = {}
            pimVersion = "PIMv4"
            groupaddr = igmpMldObj.PimV4JoinPruneList.GroupV4Address.Values
            groupAddrCount = igmpMldObj.PimV4JoinPruneList.GroupAddressCount.Values
            sourceAddr = igmpMldObj.PimV4JoinPruneList.SourceV4Address.Values
            sourceCount = igmpMldObj.PimV4JoinPruneList.SourceAddressCount.Values
            igmpMldDict["pimV4"]["start_group_address"] = groupaddr[vlanIndex]
            igmpMldDict["pimV4"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["pimV4"]["source_list"] = sourceAddr[vlanIndex]
            igmpMldDict["pimV4"]["version"] = pimVersion
        if "pimV6" in igmpMldObj.href:
            igmpMldDict["pimV6"] = {}
            pimVersion = "PIMv6"
            groupaddr = igmpMldObj.PimV6JoinPruneList.GroupV6Address.Values
            groupAddrCount = igmpMldObj.PimV6JoinPruneList.GroupAddressCount.Values
            sourceAddr = igmpMldObj.PimV6JoinPruneList.SourceV6Address.Values
            sourceCount = igmpMldObj.PimV6JoinPruneList.SourceAddressCount.Values
            igmpMldDict["pimV6"]["start_group_address"] = groupaddr[vlanIndex]
            igmpMldDict["pimV6"]["group_count"] = groupAddrCount[vlanIndex]
            igmpMldDict["pimV6"]["source_list"] = sourceAddr[vlanIndex]
            igmpMldDict["pimV6"]["version"] = pimVersion
        return igmpMldDict

    def get_emulator_info(self, port_name=None, vlan_id=None):
        """
        Creates dictionary of emulated devices(handler) and its multicast configuration information and returns the same
        This Function gets the portname and vlanid and returns the emulated devices and only thier multicast config info like
        start group address, group count and source IP list created in specified portname and having specified vlan ID.

        :param port_name: Name of the port
        :param vlan_id: vlanid of emulated device.
        :return Returns nested dictionary of emulated devices and thier multicast information

        Usage Example:
        tgn.get_emulator_info(port_name="1/15", vlan_id="6")
        Return Output:
        {'P22_SM_v4_Auto_VRF6': {'igmp': {'group_count': '1',
                                          'source_list': '192.0.1.0',
                                          'start_group_address': '226.0.0.1',
                                          'version': 'IGMP_V2'}},
         'P22_SM_v4_BSR_VRF6': {'igmp': {'group_count': '1',
                                         'source_list': '192.0.1.0',
                                         'start_group_address': '227.0.0.1',
                                         'version': 'IGMP_V2'}},
         'P22_SM_v4_Static_VRF6': {'igmp': {'group_count': '1',
                                            'source_list': '192.0.1.0',
                                            'start_group_address': '225.0.0.1',
                                            'version': 'IGMP_V2'}}}
        """
        emulatedInfo = dict()
        dG = None
        if port_name:
            for topology in self.ixNetwork.Topology.find():
                if self.ixNetwork.Vport.find(Name=port_name).href in topology.Vports:
                    igmpMldObjDict = {}
                    for deviceGroupObj in topology.DeviceGroup.find():
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                for igmpObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                    if deviceGroupObj.href in igmpObj.href:
                                        igmpMldObjDict[igmpObj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                for mldObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                    if deviceGroupObj.href in mldObj.href:
                                        igmpMldObjDict[mldObj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():
                                for pimV4Obj in deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find():
                                    if deviceGroupObj.href in pimV4Obj.href:
                                        igmpMldObjDict[pimV4Obj] = deviceGroupObj
                        except:
                            pass
                        try:
                            if deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():
                                for pimV6Obj in deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find():
                                    if deviceGroupObj.href in pimV6Obj.href:
                                        igmpMldObjDict[pimV6Obj] = deviceGroupObj
                        except:
                            pass

                    for igmpMldOBj, deviceGroupObj in igmpMldObjDict.items():
                        for vlanObj in deviceGroupObj.Ethernet.find().Vlan.find():
                            if vlan_id and vlan_id in vlanObj.VlanId.Values:
                                dG = deviceGroupObj.Name
                                vlanIndex = (vlanObj.VlanId.Values).index(vlan_id)
                                igmpDictInfo = self._get_igmp_mld_dict_info(igmpMldOBj, vlanIndex)
                                if dG in emulatedInfo:
                                    emulatedInfo[dG].update(igmpDictInfo)
                                else:
                                    emulatedInfo[dG] = igmpDictInfo
                                break
                    break
        if dG is None:
            log.info('No Emulated devices are configured on port %s with vlan %s' % (port_name, str(vlan_id)))
            return None
        else:
            return emulatedInfo

    def _process_stream_block(self, high_level_stream_entry, endpointset_entry, traffic_item_obj, vlan_index, mcast_addr_dict, mcast_device):
        """
        Internal Method to process stream block
        :param high_level_stream_entry: Details related to frame rate,type,fixed size etc in high level stream
        :param endpointset_entry: Details of Endpoint set to traffic item
        :param traffic_item_obj:Traffic Item Object on which mcast details are captured
        :param vlan_index: Vlan index of Vlan
        :param mcast_addr_dict:Multicast address dictionary
        :param mcast_device: Multicast device details in topology
        """
        streamblock_info = dict()
        stream_source_ip = ''
        stream_destination_ip = ''

        frame_rate = high_level_stream_entry['frameRate']['rate']
        frame_type = high_level_stream_entry['frameRate']['type']
        frame_rate_type = str(frame_rate) + ' ' + frame_type
        frame_size = str(high_level_stream_entry['frameSize']['fixedSize'])
        flow_index = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 0))['arg3']
        source_ip_index = flow_index.index('Source Address')
        destination_ip_index = flow_index.index('Destination Address')

        flow_data = (traffic_item_obj.HighLevelStream.find().PreviewFlowPackets(0, 1))['arg4']
        if endpointset_entry['multicastDestinations']!= []:
            mcast_receivers = endpointset_entry['multicastReceivers']

            list(map(lambda x:x.update({'ethHandle': re.search(r'(\S+ethernet\[\d+\])', x['arg1']).group(0)}),mcast_receivers))

            eth_to_mcast_df = pd.DataFrame(map(lambda x: [x['ethHandle'], x['arg1']],
                                            mcast_receivers))
            eth_to_mcast_df.columns = ['ethHandle', 'mcastProto']
            eth_to_mcast_df.drop_duplicates(inplace=True)
            mcast_href_str = ' '.join(eth_to_mcast_df['mcastProto'])

            mcast_ip_list = list(
                map(lambda x: x['arg3'], endpointset_entry['multicastDestinations']))

            if mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index] in mcast_ip_list:
                mcast_ip = mcast_addr_dict[mcast_device][mcast_device + '_group_addr_values'][vlan_index]
                ip_type = ipaddress.ip_address(mcast_ip).version
                if (ip_type == 4 and mcast_device in ['igmp', 'pimv4']) or \
                    (ip_type == 6 and mcast_device in ['mld', 'pimv6']):
                    for value in flow_data:
                        stream_source_ip = value[source_ip_index]
                        stream_destination_ip = value[destination_ip_index]
                        if mcast_device in mcast_href_str:
                            mcast_source_ip = mcast_addr_dict[mcast_device][mcast_device + '_source_addr_list'][vlan_index]
                            streamblock_info[traffic_item_obj.Name] = {
                                'packet_rate': frame_rate_type,
                                'packet_size': frame_size,
                                'source_list': mcast_source_ip,
                                'start_group_address': mcast_ip,
                                'source_address': stream_source_ip,
                                'destination_address': stream_destination_ip}

        if streamblock_info:
            return streamblock_info
        else:
            return None

    def get_streamblock_info(self, port_name=None, vlan_id=None, **kwargs):
        """
        Creates dictionary of streamblocks and its multicast configuration information and returns the same
        This Function gets the portname and vlanid and returns the streamblocks and only thier multicast config info like
        start group address, group count and source IP list created in specified portname and having specified vlan ID.

        :param port_name: Name of the port. Make sure portname doesnt have "//". Ex: 172.27.152.15/7/12 instead of 172.27.152.15//7/12. This is as per Cisco request.
        :param vlan_id: vlanid of emulated device.
        :return Returns nested dictionary of Streamblocks and thier multicast information

        Usage Example:
        tgn.get_streamblock_info(port_name="172.27.152.15/7/12", vlan_id="6")
        Return Output:
        {'P22_Static_v4_1_7_12': {'packet_rate': '10 % Line Rate',
                                  'packet_size': '128',
                                  'source_list': '192.0.1.0',
                                  'start_group_address': '225.0.0.1'}}
        """
        streamblock_info = dict()
        port_index = kwargs.get('port_index')
        vlan_index = kwargs.get('vlan_index')

        mcast_device = kwargs.get('mcast_device')
        mcast_addr_dict = kwargs.get('mcast_addr_dict')
        if vlan_id != None:
            vlan_id = re.sub("\D", "", vlan_id)
        else:
            return None

        for index, traffic_item_obj in enumerate(self.ixNetwork.Traffic.TrafficItem.find()):
            traffic_item_json = self._get_json_trafficitem(index)
            high_level_stream_list = traffic_item_json['highLevelStream']
            endpointset_list = traffic_item_json['endpointSet']

            for _, high_level_stream_obj in enumerate(high_level_stream_list):
                if 'txPortId' in high_level_stream_obj:
                    streamblock_info = self._process_stream_block(high_level_stream_obj, endpointset_list[0],
                                                                     traffic_item_obj, vlan_index, mcast_addr_dict,
                                                                                 mcast_device)
                    if streamblock_info:
                        return streamblock_info

    def _update_version(self, version, prepend):
        """
        Internal Method to update the Multicast protocols (IGMP , MLD) version
        :param version: Version of the Multicast protocols
        :param prepend: Version type to be added
        """
        if version == 'version2':
            return prepend+ "_V2"
        elif version == "version1":
            return prepend + "_V1"
        else:
            return prepend + "_V3"

    def _retrieve_mcast_device_details(self, device_group_obj, mcast_type):
        """
        Internal Method to retrieve multicast device details
        :param device_group_obj: Device Group Object in topology
        :param mcast_type: given multicast type
        """
        if mcast_type == 'igmp':
            return self._retrieve_igmp_device_details(device_group_obj)
        elif mcast_type == 'mld':
            return self._retrieve_mld_device_details(device_group_obj)
        elif mcast_type == 'pimv4':
            return self._retrieve_pim4_device_details(device_group_obj)
        else:
            return self._retrieve_pim6_device_details(device_group_obj)

    def _retrieve_igmp_device_details(self, deviceGroupObj):
        """
        Internal Method to get the IGMP protocol device details
        :param deviceGroupObj: Device Group Object of IGMP
        return IGMP protocol related details
        """
        igmp_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.StartMcastAddr.Values
        igmp_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.McastAddrCnt.Values
        igmp_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
        igmp_versions = deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find().VersionType.Values
        igmp_version_list = [self._update_version(version, "IGMP") for version in igmp_versions]
        return [igmp_group_addr_values, igmp_group_addr_count, igmp_source_addr_list, igmp_version_list]

    def _retrieve_mld_device_details(self, deviceGroupObj):
        """
        Internal Method to get the MLD protocol device details
        :param deviceGroupObj: Device Group Object of MLD
        return MLD protocol related details
        """
        mld_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.StartMcastAddr.Values
        mld_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.McastAddrCnt.Values
        mld_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
        mld_versions = deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find().VersionType.Values
        mld_version_list = [self._update_version(version, "MLD") for version in mld_versions]
        return [mld_group_addr_values, mld_group_addr_count, mld_source_addr_list, mld_version_list]

    def _retrieve_pim4_device_details(self, deviceGroupObj):
        """
        Internal Method to get the PIMv4 protocol device details
        :param deviceGroupObj: Device Group Object of PIMv4
        return PIMv4 protocol related details
        """
        pimv4_group_addr_values = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupV4Address.Values
        pimv4_group_addr_count = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.GroupAddressCount.Values
        pimv4_source_addr_list = deviceGroupObj.Ethernet.find().Ipv4.find().PimV4Interface.find().PimV4JoinPruneList.SourceV4Address.Values
        pimv4_versions = ["PIMv4"] * len(pimv4_group_addr_count)
        return [pimv4_group_addr_values, pimv4_group_addr_count, pimv4_source_addr_list, pimv4_versions]

    def _retrieve_pim6_device_details(self, deviceGroupObj):
        """
        Internal Method to get the PIMv6 protocol device details
        :param deviceGroupObj: Device Group Object of PIMv6
        return PIMv6 protocol related details
        """
        pimv6_group_addr_values = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupV6Address.Values
        pimv6_group_addr_count = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.GroupAddressCount.Values
        pimv6_source_addr_list = deviceGroupObj.Ethernet.find().Ipv6.find().PimV6Interface.find().PimV6JoinPruneList.SourceV6Address.Values
        pimv6_versions = ["PIMv6"] * len(pimv6_group_addr_count)
        return [pimv6_group_addr_values, pimv6_group_addr_count, pimv6_source_addr_list, pimv6_versions]

    def _create_json_trafficitem(self):
        """
        Internal Method to create Traffic Item Json
        """
        traffic_xpath = '/traffic/trafficItem'
        json_str = self.ixNetwork.ResourceManager.ExportConfig([traffic_xpath+"/descendant-or-self::*"], True, "json")
        self.trafficitem_json = json.loads(json_str)

    def _get_json_trafficitem(self, index):
        """
        Internal Method to get Traffic Item Json
        :param index: Represents traffic item index
        """
        return self.trafficitem_json['traffic']['trafficItem'][index]

    def get_mcast_tgn_info(self, **kwargs):
        """
        Get the emulated device, streamblock info for a given port and vlan combination

        eg of the output:- {'172.27.152.15/7/1': {'vlan1': {'P14_SM_V4_Static_VRF1_7_1': {'igmp': {'group_count': '2500',
                                                                        'source_list': '192.0.1.0',
                                                                        'start_group_address': '225.0.0.1',
                                                                        'version': 'version2'}},
                                 'streamblock': {'P14_SM_V4_VRF1_STATIC_7_1': {'group_count': '2500',
                                                                               'packet_rate': '1004.0 framesPerSecond',
                                                                               'packet_size': '128',
                                                                               'source_list': '192.0.1.0',
                                                                               'start_group_address': '225.0.0.1'}}}}}
        return: Dictionary of emulated devices and stream block info
        """
        port_names_list = self.get_list_port_name()
        topology_dict = {}
        vports_dict = {}

        for port_name, topology_obj in product(port_names_list, self.ixNetwork.Topology.find()):
            vport_href = self.ixNetwork.Vport.find(Name=port_name).href
            if vport_href in topology_obj.Vports:
                topology_dict[port_name] = topology_obj
                vports_dict[port_name] = vport_href


        self._create_json_trafficitem()
        igmp_mld_obj_dict = {}
        mapping_dict = dict()

        for port_name, topology_obj in topology_dict.items():
            if port_name not in mapping_dict:
                mapping_dict.update({port_name: {}})
            if port_name not in igmp_mld_obj_dict:
                igmp_mld_obj_dict.update({port_name: {}})

            for device_group_obj in topology_obj.DeviceGroup.find():
                if device_group_obj.Name not in mapping_dict[port_name]:
                    mapping_dict[port_name].update({device_group_obj.Name: {}})
                vport_count = topology_obj.PortCount
                vports_obj_list = topology_obj.Ports

                vlan_list = device_group_obj.Ethernet.find().Vlan.find().VlanId.Values
                vlan_split_count = len(vlan_list) // vport_count
                port_index = (vports_obj_list.index(vports_dict[port_name]))
                length_to_split = [vlan_split_count] * vport_count
                vlan_id_list = iter(vlan_list)
                vlan_id_split_list = [list(islice(vlan_id_list, elem)) for elem in length_to_split]
                vlan_list = vlan_id_split_list[port_index]
                vlan_list = list(set(vlan_list))  ## TODO
                mapping_dict[port_name][device_group_obj.Name].update(
                    {'vlan': dict(zip(range(len(vlan_list)), (vlan_list)))})

                mcast_deviceobj_dict = {}
                if device_group_obj.Ethernet.find().Ipv4.find():
                    if len(device_group_obj.Ethernet.find().Ipv4.find().IgmpHost.find()) > 0:
                        mcast_deviceobj_dict.update({'igmp': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'igmp': {}})

                    if len(device_group_obj.Ethernet.find().Ipv4.find().PimV4Interface.find()) > 0:
                        mcast_deviceobj_dict.update({'pimv4': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'pimv4': {}})

                if device_group_obj.Ethernet.find().Ipv6.find():
                    if len(device_group_obj.Ethernet.find().Ipv6.find().MldHost.find()) > 0:
                        mcast_deviceobj_dict.update({'mld': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'mld': {}})

                    if len(device_group_obj.Ethernet.find().Ipv6.find().PimV6Interface.find()) > 0:
                        mcast_deviceobj_dict.update({'pimv6': device_group_obj})
                        mapping_dict[port_name][device_group_obj.Name].update({'pimv6': {}})

                group_addr_values = []
                group_addr_count = []
                source_addr_list = []
                version_list = []


                for key, device_group_obj in mcast_deviceobj_dict.items():
                    group_addr_values, group_addr_count, source_addr_list, version_list = \
                        self._retrieve_mcast_device_details(device_group_obj, key)
                    if len(vlan_list) < len(group_addr_values):
                        vlan_list = vlan_list * int(len(group_addr_values) / len(vlan_list))
                        port_index = 0
                    vlan_len = len(vlan_list)
                    start_index = port_index * vlan_len
                    end_index = (port_index + 1) * vlan_len

                    group_addr_count = group_addr_count[start_index:end_index]
                    source_addr_list = source_addr_list[start_index:end_index]
                    group_addr_values = group_addr_values[start_index:end_index]
                    version_list = version_list[start_index:end_index]

                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_group_addr_count': dict(zip(range(len(group_addr_count)), group_addr_count))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_source_addr_list': dict(zip(range(len(source_addr_list)), source_addr_list))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_group_addr_values': dict(zip(range(len(group_addr_values)), group_addr_values))})
                    mapping_dict[port_name][device_group_obj.Name][key].update(
                        {key + '_version_list': dict(zip(range(len(version_list)), version_list))})


        for port_name in mapping_dict.keys():
            for device_name in mapping_dict[port_name].keys():
                for mcast_device in mapping_dict[port_name][device_name].keys():
                    group_count = mcast_device + '_group_addr_count'
                    source_addr = mcast_device + '_source_addr_list'
                    group_addr = mcast_device + '_group_addr_values'
                    version = mcast_device + '_version_list'

                    for vlan_index, vlan_id in mapping_dict[port_name][device_name]['vlan'].items():
                        if 'vlan' + vlan_id not in igmp_mld_obj_dict[port_name]:
                            igmp_mld_obj_dict[port_name].update({'vlan' + vlan_id: {}})

                        if device_name not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({device_name: {}})

                        if mcast_device != 'vlan' and mcast_device not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id][
                            device_name].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name].update({mcast_device: {}})

                        port_index = port_names_list.index(port_name)

                        if mcast_device != 'vlan' and len(mapping_dict[port_name][device_name][mcast_device]) > 0:
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id][device_name][mcast_device] = \
                                {'group_count': mapping_dict[port_name][device_name][mcast_device][group_count][
                                    vlan_index],
                                 'source_list': mapping_dict[port_name][device_name][mcast_device][source_addr][
                                     vlan_index],
                                 'start_group_address': mapping_dict[port_name][device_name][mcast_device][group_addr][
                                     vlan_index],
                                 'version': mapping_dict[port_name][device_name][mcast_device][version][vlan_index],
                                 }
                        if 'streamblock' not in igmp_mld_obj_dict[port_name]['vlan' + vlan_id].keys():
                            igmp_mld_obj_dict[port_name]['vlan' + vlan_id].update({'streamblock': {}})
                        if mcast_device != 'vlan':
                            streamblock = self.get_streamblock_info(port_name=port_name, vlan_id=vlan_id, vlan_index=vlan_index,
                                                          port_index=port_index,
                                                          mcast_device=mcast_device,
                                                          mcast_addr_dict=mapping_dict[port_name][device_name])
                            if streamblock:
                                if igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock']:
                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'].update(streamblock.items())
                                else:
                                    igmp_mld_obj_dict[port_name]['vlan' + vlan_id]['streamblock'] = streamblock


        return igmp_mld_obj_dict

    def get_dhcp_session_info(self, device, protocol='ipv4'):
        """
        Retrieves the DHCP session info for a given device

        :param device: The name of the device as seen in the GUI
        :param protocol: retrieves either the v4 'ipv4' or v6 'ipv6' session info
        :return: The DHCP session info on success, exception on failure
        """
        dhcpSessionDict = {}
        if protocol == 'ipv4':
            try:
                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find()
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        else:
            try:
                dhcpserversessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find()
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        sessionInfoList = dhcpserversessions.SessionInfo
        for sessionIndex in range(0, len(sessionInfoList)):
            sessionId = 'Session ' + str(sessionIndex + 1)
            dhcpSessionDict[sessionId] = sessionInfoList[sessionIndex]
        return dhcpSessionDict

    def set_dhcp_server(self, device, cfg_dict, protocol='ipv4'):
        """
        Configures a DHCP server based on a given dict of attributes

        :param device: The name of the DHCP server device as seen in the GUI
        :param protocol: Can be 'ipv4' or 'ipv6'
        :param cfg_dict: The dictionary of attributes to be used for configuration
            lease_time (int): The desired lease time
            pool_start_addr (str): Starting IP address for DHCP pools
            pool_incr_addr (str): Increment for pool_start_addr
            pool_host_count (int): The host count for address leasing
            pool_host_incr (int): Increment for pool_host_count

        :return: True on success, exception on failure
        """

        if protocol == 'ipv4':
            try:
                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv4.find().Dhcpv4server.find().Dhcp4ServerSessions
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        else:
            try:
                dhcpServersessions = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=device).Ethernet.find().Ipv6.find().Dhcpv6server.find().Dhcp6ServerSessions
            except:
                raise IxiaConfigException("DHCP Server config is not present on this device : '%s' " % device)
        dhcpServersessions.DefaultLeaseTime.Single(cfg_dict.get('lease_time', None))
        dhcpServersessions.IpAddress.Increment(start_value=cfg_dict.get('pool_start_addr', None),
                                               step_value=cfg_dict.get('pool_start_step', None))
        dhcpServersessions.IpAddressIncrement.Increment(start_value=cfg_dict.get('pool_incr_addr', None),
                                                        step_value=cfg_dict.get('pool_incr_step', None))
        dhcpServersessions.PoolSize.Increment(start_value=cfg_dict.get('pool_host_count', None),
                                              step_value=cfg_dict.get('pool_host_incr', None))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def set_bgp_med(self, router_id, med, route_block_name=None, ip_type="ipv4"):
        """
        Modify MED for the eBGP route blocks

        :param med: Integer/string representing new MED value
        :param router_id: Router ID of the device
        :param route_block_name: route block name from config
        :param ip_type: "ipv4" or "ipv6"
        :return:
        """
        self.log.info("setting MED value")
        result = False
        device = None
        if route_block_name == None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        device = deviceGroup
                        indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                        break
                else:
                    self.log.info("Router Configuration doesn't found on this device group '%s'"%(deviceGroup.Name))
            if device and device.NetworkGroup.find():
                for networkGroup in device.NetworkGroup.find():
                    networkMultiplier = networkGroup.Multiplier
                    enableList = ['True'] * networkMultiplier
                    if ip_type.lower() == "ipv4":
                        try:
                            if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()
                            if networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()

                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values
                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)

                            medValueList = bgpIpRoute.MultiExitDiscriminator.Values
                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med] * networkMultiplier
                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)
                            result = True
                        except:
                            pass
                    else:
                        try:
                            if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()
                            if networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find():
                                bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()

                            enableMedList = bgpIpRoute.EnableMultiExitDiscriminator.Values
                            enableMedList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableMultiExitDiscriminator.ValueList(enableMedList)

                            medValueList =bgpIpRoute.MultiExitDiscriminator.Values
                            medValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [med]*networkMultiplier
                            bgpIpRoute.MultiExitDiscriminator.ValueList(medValueList)
                            result = True
                        except:
                            pass
            else:
                self.log.error("Network Group Configuration doesn't found on this device group '%s'" % (deviceGroup.Name))
        if route_block_name:
            if ip_type.lower() == "ipv4":
                try:
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + route_block_name + '$').Ipv4PrefixPools.find().href
                except:
                    raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'"%(route_block_name,ip_type))
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.href in networkGroupObj:
                        for ipv4PoolObj in deviceGroupObj.NetworkGroup.find().Ipv4PrefixPools.find():
                            if ipv4PoolObj.BgpIPRouteProperty.find():
                                result = True
                                bgpV4Route = ipv4PoolObj.BgpIPRouteProperty.find()
                            if ipv4PoolObj.BgpV6IPRouteProperty.find():
                                result = True
                                bgpV4Route = ipv4PoolObj.BgpV6IPRouteProperty.find()
                            bgpV4Route.EnableMultiExitDiscriminator.Single(True)
                            bgpV4Route.MultiExitDiscriminator.Single(med)
            else:
                try:
                    networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().href
                except:
                    raise IxiaConfigException("Network group name '%s' not found for Ip version '%s'"%(route_block_name,ip_type))
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.href in networkGroupObj:
                        for ipv6PoolObj in deviceGroupObj.NetworkGroup.find().Ipv6PrefixPools.find():
                            if ipv6PoolObj.BgpV6IPRouteProperty.find():
                                result = True
                                bgpV6Route = ipv6PoolObj.BgpV6IPRouteProperty.find()
                            if ipv6PoolObj.BgpIPRouteProperty.find():
                                result = True
                                bgpV6Route = ipv6PoolObj.BgpIPRouteProperty.find()
                            bgpV6Route.EnableMultiExitDiscriminator.Single(True)
                            bgpV6Route.MultiExitDiscriminator.Single(med)

        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if result:
            return result
        else:
            self.log.error("Failed due to the config issue")
            return result

    def set_bgp_local_preference(self, router_id, local_preference, route_block_name=None, ip_type="ipv4"):
        """
        Modify local preference for the iBGP route blocks

        :param local_preference: Integer/string representing new local preference. Ex: 100
        :param router_id: Router ID of the device. Ex: 1.1.1.1
        :param route_block_name: route block name from config. Ex: ipv4routerblock101
        :param ip_type: "ipv4" or "ipv6"
        :return:
        """
        self.log.info("setting local_preference value")
        result = True
        if route_block_name == None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in deviceGroup.RouterData.find().RouterId.Values:
                    device = deviceGroup
                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                    break

            for networkGroup in device.NetworkGroup.find():
                networkMultiplier = networkGroup.Multiplier
                enableList = ['True'] * networkMultiplier
                if ip_type.lower() == "ipv4":
                    try:
                        if networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find():
                            bgpIpRoute = networkGroup.Ipv4PrefixPools.find().BgpIPRouteProperty.find()

                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values
                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)

                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values
                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier
                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)
                    except:
                        pass
                else:
                    try:
                        if networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                            bgpIpRoute = networkGroup.Ipv6PrefixPools.find().BgpIPRouteProperty.find()

                            enableLocalPreferenceList = bgpIpRoute.EnableLocalPreference.Values
                            enableLocalPreferenceList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = enableList
                            bgpIpRoute.EnableLocalPreference.ValueList(enableLocalPreferenceList)

                            LocalPreferenceValueList = bgpIpRoute.LocalPreference.Values
                            LocalPreferenceValueList[(indexValue * networkMultiplier):(indexValue * networkMultiplier + networkMultiplier)] = [local_preference] * networkMultiplier
                            bgpIpRoute.LocalPreference.ValueList(LocalPreferenceValueList)
                    except:
                        pass
        if route_block_name:
            if ip_type.lower() == "ipv4":
                try:
                    bgpV4Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv4PrefixPools.find().BgpIPRouteProperty.find()
                    bgpV4Route.EnableLocalPreference.Single(True)
                    bgpV4Route.LocalPreference.Single(local_preference)
                except:
                    result = False
            else:
                try:
                    bgpV6Route = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + route_block_name + '$').Ipv6PrefixPools.find().BgpIPRouteProperty.find()
                    bgpV6Route.EnableLocalPreference.Single(True)
                    bgpV6Route.LocalPreference.Single(local_preference)
                except:
                    result = False
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return result

    def _bgp_asn_type(self, bgpObj, asn, dutAsn, index_value):
        """
        Internal function used by set_bgp_asn API .Configure type of BGP based on asn and dut_asn value.

        :param bgpObj: BGP Object
        :param asn: Ex: 100
        :param dutAsn: Ex: 100
        :param index_value: Ex: 1
        :return:
        """
        if dutAsn and asn:
            bgpTypeList = bgpObj.Type.Values
            if int(asn) != int(dutAsn):
                bgpTypeList[index_value] = 'external'
            else:
                bgpTypeList[index_value] = 'internal'
            bgpObj.Type.ClearOverlays()
            bgpObj.Type.ValueList(bgpTypeList)
        if dutAsn and asn is None:
            for asn in bgpObj.LocalAs2Bytes.Values:
                if int(asn) != int(dutAsn):
                    bgpObj.Type.Single('external')
                else:
                    bgpObj.Type.Single('internal')

    def set_bgp_asn(self, router_id, asn=None, dut_asn=None):
        """
        Modify AS number on BGP devices.
        Note: First set ASPATH and then modify ASN if changing from IBGP to EBGP.

        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1
        :param asn: AS number of the device on TGN. Ex: 100
        :param dut_asn: NA for IXIA
        :return:

        :Example: set_bgp_asn(router_id="192.0.0.2", asn=1000)
        """
        self.log.info("setting asn value")
        deviceGroupObj = None
        for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
            if deviceGroup.RouterData.find():
                if router_id in deviceGroup.RouterData.find().RouterId.Values:
                    deviceGroupObj = deviceGroup
                    indexValue = list(deviceGroup.RouterData.find().RouterId.Values).index(router_id)
                    break
        if deviceGroupObj:
            try:
                if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                        asnValueList = bgpObj.LocalAs2Bytes.Values
                        asnValueList[indexValue] = asn
                        bgpObj.LocalAs2Bytes.ClearOverlays()
                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)
                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)
            except:
                pass

            try:
                if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                    for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                        asnValueList = bgpObj.LocalAs2Bytes.Values
                        asnValueList[indexValue] = asn
                        bgpObj.LocalAs2Bytes.ClearOverlays()
                        bgpObj.LocalAs2Bytes.ValueList(asnValueList)
                        self._bgp_asn_type(bgpObj, asn, dut_asn, indexValue)
            except:
                pass
        else:
            raise IxiaConfigException("Router Id '%s' not found on this configuration." % router_id)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def _config_bgp_aspath(self, ipPoolsObj, aspath, ipType):
        """
        Configure BGP Aspath
        :param ipPoolsObj: Ipv4/Ipv6 Prefix Pool Object
        :param aspath: asPath value
        :param ipType: v4/v6
        :return:
        """
        if ipType == "v4":
            if ipPoolsObj.BgpIPRouteProperty.find():
                for bgpIpRoute in ipPoolsObj.BgpIPRouteProperty.find():
                    bgpIpRoute.Stop()
                    bgpIpRoute.OverridePeerAsSetMode.Single("True")
                    bgpIpRoute.EnableAsPathSegments.Single("True")
                    bgpIpRoute.AsSetMode.Single("dontincludelocalas")
                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():
                        pathSegmentObj.SegmentType.Single("asseq")
                    if aspath:
                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(aspath)
                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),
                                                        aspath):
                            bgpAspath.AsNumber.Single(pathValue)
                    else:
                        self.log.info("Aspath passed as null, not configured Aspath")
                    bgpIpRoute.Start()
        else:
            if ipPoolsObj.BgpV6IPRouteProperty.find():
                for bgpIpRoute in ipPoolsObj.BgpV6IPRouteProperty.find():
                    bgpIpRoute.Stop()
                    bgpIpRoute.OverridePeerAsSetMode.Single("True")
                    bgpIpRoute.EnableAsPathSegments.Single("True")
                    bgpIpRoute.AsSetMode.Single("dontincludelocalas")
                    for pathSegmentObj in bgpIpRoute.BgpAsPathSegmentList.find():
                        pathSegmentObj.SegmentType.Single("asseq")
                    if aspath:
                        bgpIpRoute.BgpAsPathSegmentList.find().NumberOfAsNumberInSegment = len(
                            aspath)
                        for bgpAspath, pathValue in zip(bgpIpRoute.BgpAsPathSegmentList.find().BgpAsNumberList.find(),
                                                        aspath):
                            bgpAspath.AsNumber.Single(pathValue)
                    else:
                        self.log.info("Aspath passed as null, not configured Aspath")
                    bgpIpRoute.Start()
        return True

    def set_bgp_aspath(self, router_id, aspath=[], route_block_name=None, ip_type="ipv4"):
        """
        Modify AS path on BGP route blocks

        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1
        :param aspath: AS path to be set on TGN for the route_block. Ex: [10,20,30]
        :param route_block_name: BGP route block name under the BGP device. Ex: "ipv4routeblock101"
        :param ip_type: "ipv4" or "ipv6"
        :return: True or raise exception
        """
        self.log.info("setting BGP AP path value")
        deviceGroupObj = None
        result = False
        if route_block_name is None:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObj = deviceGroup
                        break
            if deviceGroupObj.NetworkGroup.find():
                for networkGroup in deviceGroupObj.NetworkGroup.find():
                    if ip_type.lower() == "ipv4":
                        if networkGroup.Ipv4PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                        if networkGroup.Ipv6PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                    if ip_type.lower() == 'ipv6':
                        if networkGroup.Ipv6PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv6PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
                        if networkGroup.Ipv4PrefixPools.find():
                            ipPoolsObj = networkGroup.Ipv4PrefixPools.find()
                            result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")

        if route_block_name and router_id:
            if type(route_block_name) is list:
                routeBlockNameList = route_block_name
            else:
                routeBlockNameList = [route_block_name]
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObj = deviceGroup
                        break
            if deviceGroupObj:
                for routeBlockName in routeBlockNameList:
                    if ip_type.lower() == "ipv4":
                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                                if networkGroupObj.Ipv4PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                                if networkGroupObj.Ipv6PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v4")
                    else:
                        if deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                            for networkGroupObj in deviceGroupObj.NetworkGroup.find(Name='^' + routeBlockName + '$'):
                                if networkGroupObj.Ipv6PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv6PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
                                if networkGroupObj.Ipv4PrefixPools.find():
                                    ipPoolsObj = networkGroupObj.Ipv4PrefixPools.find()
                                    result = self._config_bgp_aspath(ipPoolsObj, aspath, "v6")
        if result:
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
            return result
        else:
            raise IxiaConfigException(
                "Failed due to configuration issue, Please check RouterId/Route Block Name/IpType")

    def enable_ecn(self, traffic_item, reserved):
        """
        The API is to enable ECN bits on  ipv4 or ipv6 stream

        :param traffic_item: Name of the stream on which ECN bit is to be enabled
        :param reserved: Reserved bits
        :return: None

        """
        self.log.info("Changing ECN value for the traffic item")
        reserved = int(reserved, 2)
        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^'+traffic_item+'$')
        if not trafficItemObj:
            raise IxiaConfigException("Traffic item not found")
        if trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv4"):
            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv4")
            if headerHandle.Field.find(Name='default_phb').ActiveFieldChoice == True:
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='class_selector_phb').ActiveFieldChoice == True:
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.classSelectorPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='assured_forwarding_phb').ActiveFieldChoice == True:
                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.assuredForwardingPHB.unused').FieldValue = reserved
            elif headerHandle.Field.find(Name='expedited_forwarding_phb').ActiveFieldChoice == True:
                headerHandle.Field.find( FieldTypeId='ipv4.header.priority.ds.phb.expeditedForwardingPHB.unused').FieldValue = reserved
            else:
                headerHandle.Field.find(Name='default_phb').ActiveFieldChoice = True
                headerHandle.Field.find(FieldTypeId='ipv4.header.priority.ds.phb.defaultPHB.unused').FieldValue = reserved
        elif trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv6"):
            headerHandle = trafficItemObj.ConfigElement.find().Stack.find(DisplayName="IPv6")
            headerHandle.Field.find(Name='trafficClass').FieldValue = reserved
        else:
            raise IxiaConfigException("IPV4/V6 stack not configured on traffic item")

    def retrieve_per_prefix_frame_loss(self, ip_type="ipv4", show_all=False, traffic_item_list=None):
        """
        API to retrieve per prefix frame-loss (Provided by Spirent vendor).
        On Spirent, a stream can have max 4000 flows and a dynamic result view
        can show upto 2000 entries only.
        Once a user-defined view is created, pages of 2000 entries need to be
        scanned to get the least loss and most loss for the flows.

        :param ip_type: If prefix is ipv4 or ipv6.
        :param show_all: True/False
        :param traffic_item_list: list of traffic items on which stats to be retrieved
        :return: Dictionary containing loss prefixes with loss duration
        Examples:
                retrieve_per_prefix_frame_loss()
                retrieve_per_prefix_frame_loss("ipv6",show_all=False)
                retrieve_per_prefix_frame_loss("ipv4",show_all=True)
                retrieve_per_prefix_frame_loss("ipv4",show_all= True, traffic_item_list=['Traffic_item1'])
        """
        prefixesLossDict = {}
        drildownIndex = 0
        prefixBaseStats = None
        all_traffic_items = self.get_traffic_items()

        if not traffic_item_list:
            traffic_item_list = self.get_active_streams()

            if ip_type.lower() == "ipv4":
                for item in all_traffic_items:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "ipv6":
                        try:
                            traffic_item_list.remove(item)
                        except:
                            pass
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "raw":
                        if 'ipv4DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(
                                Name='^' + item + '$').Tracking.find().TrackBy:
                            try:
                                traffic_item_list.remove(item)
                            except:
                                pass

            if ip_type.lower() == "ipv6":
                for item in all_traffic_items:
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "ipv4":
                        try:
                            traffic_item_list.remove(item)
                        except:
                            pass
                    if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').TrafficType == "raw":
                        if 'ipv6DestIp0' not in self.ixNetwork.Traffic.TrafficItem.find(
                                Name='^' + item + '$').Tracking.find().TrackBy:
                            try:
                                traffic_item_list.remove(item)
                            except:
                                pass

        trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')
        rowList = [rowNumber for rowNumber, stat in enumerate(trafficItemStats.Rows) if
                   stat['Traffic Item'] in traffic_item_list]
        for rowIndex in rowList:
            trafficItemStats = StatViewAssistant(self.ixNetwork, 'Traffic Item Statistics')
            if ip_type == "ipv4":
                destType = 'IPv4 :Destination Address'
            else:
                destType = 'IPv6 :Destination Address'
            try:
                prefixBaseStats = trafficItemStats.Drilldown(rowIndex,
                                                             trafficItemStats.DrillDownOptions(rowIndex)[drildownIndex],
                                                             trafficItemStats.TargetRowFilters()[rowIndex])
                time.sleep(10)
            except KeyError:
                raise IxiaConfigException("traffic stream not found or in-valid configuration")
            except:
                pass

            if prefixBaseStats:
                trafficHeadersList = prefixBaseStats.ColumnHeaders
                trafficPrefixStatsDict = []
                for rowNumber, stat in enumerate(prefixBaseStats.Rows):
                    headerDict = {}
                    for column in trafficHeadersList:
                        if destType == column or column == 'Packet Loss Duration (ms)':
                            headerDict[column] = stat[column]
                            trafficPrefixStatsDict.append(headerDict)

                for trafficdict in trafficPrefixStatsDict:
                    try:
                        prefixIp = trafficdict[destType]
                        lossDuration = trafficdict['Packet Loss Duration (ms)']
                        if show_all:
                            prefixesLossDict.update({prefixIp: lossDuration})
                        else:
                            if int(float(lossDuration)) != 0:
                                prefixesLossDict.update({prefixIp: lossDuration})
                    except:
                        if drildownIndex == 0:
                            drildownIndex = drildownIndex + 1
                        break
        if prefixesLossDict:
            return prefixesLossDict
        else:
            raise IxiaConfigException("%s type Traffic stream not found" % ip_type)

    def get_arp_status(self, devices=None):
        """
        Get ARP/ND status for All/specific devices
        :param devices: list of devices' router IDs and/or names
        :return: arp status for each device. Ex: {'192.0.0.20': 'FAILED', 'TestDeviceLDP1': 'FAILED'}
        """
        arpStatus = {}
        if not devices:
            log.info("Devices arg not passed. Fetching all devices from config")
            devices = [device.Name for device in self.ixNetwork.Topology.find().DeviceGroup.find()]
        for device in devices:
            try:
                if '.' in device:
                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                        routerIdIndex = None
                        for routerDataObj in deviceObj.RouterData.find():
                            if device in routerDataObj.RouterId.Values:
                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)
                                break
                        if routerIdIndex is not None:
                            resolveGatewayList = deviceObj.Ethernet.find().Ipv4.find().ResolvedGatewayMac
                            if "Unresolved" in resolveGatewayList[routerIdIndex]:
                                arpStatus[device] = 'Failed'
                            else:
                                arpStatus[device] = 'Resolved'
                else:
                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv4.find().ResolvedGatewayMac
                    if "Unresolved" in resolveGatewayList[0]:
                        arpStatus[device] = 'Failed'
                    else:
                        arpStatus[device] = 'Resolved'
            except:
                pass
            try:
                if '.' in device:
                    for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                        routerIdIndex = None
                        for routerDataObj in deviceObj.RouterData.find():
                            if device in routerDataObj.RouterId.Values:
                                routerIdIndex = (routerDataObj.RouterId.Values).index(device)
                                break
                        if routerIdIndex is not None:
                            resolveGatewayList = deviceObj.Ethernet.find().Ipv6.find().ResolvedGatewayMac
                            if "Unresolved" in resolveGatewayList[routerIdIndex]:
                                arpStatus[device] = 'Failed'
                            else:
                                arpStatus[device] = 'Resolved'
                else:
                    resolveGatewayList = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device).Ethernet.find().Ipv6.find().ResolvedGatewayMac
                    if "Unresolved" in resolveGatewayList[0]:
                        arpStatus[device] = 'Failed'
                    else:
                        arpStatus[device] = 'Resolved'
            except:
                pass
        return arpStatus

    def get_worst_flows(self, sort_by="Dropped Frame", traffic_items=None, size=10):
        """
        Creates a new DRV and grabs the 10 worst flows

        Code is a modified version that was initially provided by Spirent (Matt Jefferson)
        :param sort_by: which property to sort Dynamic Result View
            "Dropped Frame"
            "Dropped Frame Duration"
        :param traffic_items: List of traffic items that interested to view it. Default is None, which will view
                            all flows that meet the conditions limited by size
        :param size: number flows per item.
        :return: A list of dictionaries on success, exception on failure
        """
        worstFlows = []
        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
        flowHeadersList = flowStats.ColumnHeaders
        flowStatHeaderValues = []
        for rowNumber, stat in enumerate(flowStats.Rows):
            headerDict = {}
            for column in flowHeadersList:
                headerDict[column] = stat[column]
            flowStatHeaderValues.append(headerDict)
        if traffic_items:
            trafficItemList = []
            for trafficItemName in traffic_items:
                for trafficItemDict in flowStatHeaderValues:
                    for key,value in trafficItemDict.items():
                        if value == trafficItemName:
                            trafficItemList.append(trafficItemDict)
        else:
            trafficItemList = flowStatHeaderValues
        sortedTrafficItemsDict = dict()
        if sort_by == "Dropped Frame":
            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: int(trafficItem.get('Frames Delta')),reverse=True)
        if sort_by == "Dropped Frame Duration":
            sortedTrafficItemsDict = sorted(trafficItemList, key=lambda trafficItem: float(trafficItem.get('Packet Loss Duration (ms)')),reverse=True)
        for trafficItemIndex in range(0,len(sortedTrafficItemsDict)):
            if trafficItemIndex < size:
                worstFlows.append(sortedTrafficItemsDict[trafficItemIndex])
        if worstFlows:
            return worstFlows
        else:
            raise CafyException.InvalidValueError('No results found')

    def enable_traffic_minimum_size(self):
        """
        API to enable to send minimum size traffic
        :return:
        """
        self.ixNetwork.Traffic.EnableMinFrameSize = True

    def change_port_speed(self,port_list, speed='1G', media='fiber'):
        """
        To change the speed of the port

        :param port_list: list of ports
        :param speed: type of speed 1G, 10G
        :param media: type of media - "fiber" , "copper"

        Ex: tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='1G', media='copper')
            tgnObj.change_port_speed(port_list=['10.105.230.252/2/9','10.105.230.252/2/10'], speed='10G')
        """
        speedDictIxiaMapping = {'1G': 'speed1000','10G':'speed10g'}
        for port in port_list:
            for vport in self.ixNetwork.Vport.find():
                if port.replace("/",":") == vport.AssignedTo:
                    cardType = vport.Type
                    if cardType == 'novusTenGigLan':
                        cardType = cardType[0].upper() + cardType[1:]
                        cardObj = eval('vport.L1Config.' + cardType)
                        cardObj.Media = media
                        if media == 'fiber':
                            cardObj.AutoNegotiate = False
                        cardObj.Speed = speedDictIxiaMapping[speed]
                    else:
                        self.log.info("Skipping changing the port speed as card type is not novusTenGigLan")

    def get_frame_l3_information(self,stream_name, mode='ipv4'):
        """
        Returns L3 header info for the stream requested

        :param stream_name: stream name used in TGN GUI
        :param mode: ipv4 or ipv6
        :return: dictionary containing L3 header info

        Example of data returned:
        {'VLAN Priority': '7', 'VLAN-ID': '2', 'Precedence': '110 Internetwork Control', 'Source Address': '50.0.0.2',
        'Destination Address': '70.0.0.2', 'TCP-Source-Port': '1024', 'TCP-Dest-Port': '1024', 'Name': 'v4-stream-2-1'}
        """
        try:
            trafficitem = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')
        except:
            raise IxiaConfigException("Stream Not available")

        highlevelstream = trafficitem.HighLevelStream.find()
        output = highlevelstream.PreviewFlowPackets(0,1)
        l3Info = dict(zip(output['arg3'], output['arg4'][0]))
        remove = ['Packet #', 'Destination MAC Address', 'Source MAC Address', 'Ethernet-Type', 'PFC Queue']
        l3Info = dict([(k, v) for k, v in l3Info.items() if k not in remove])
        l3Info['Name'] = stream_name
        return l3Info

    def add_multiple_devices(self, port_tuple=None, device_info=None, csv_file=None, new_config=True):
        """
        API to create multiple devices in single attempt

        :param port_tuple: list of ports
        :param device_info: list of dictionary as shown in example
        :param csv_file: csv file
        :param new_config: boolean, True if want to clear the config else False

        :Example: add_multiple_devices(port_tuple = ['10.39.64.137/1/3', '10.39.64.137/2/3', '10.39.64.137/1/5', '10.39.64.137/2/4'],
                                       device_info = [{'port_name':'hu2_39_np0_sl0',  'device_name':'hu2_39_np0_sl0_v4',  'ipv4_address':'120.0.0.2',  'ipv4_gateway':'120.0.0.1'},
                                                      {'port_name': 'hu2_21_np0_sl1', 'device_name': 'hu2_21_np0_sl1_v4', 'ipv4_address': '120.0.1.2', 'ipv4_gateway': '120.0.1.1'}],
                                                      csv_file=device.csv)
        """
        self.log.info("Adding Multiple devices")
        if self.update_license == False and new_config == True:
            self._new_session(self.user_name, self.session_name, kill_existing=True)
        devicesInfo = list()
        portTuple = list()
        if csv_file:
            devicesInfoTemp = list()
            portTupleTemp = list()
            with open(csv_file) as csvFile:
                reader = csv.DictReader(csvFile)
                for row in reader:
                    rowAsDict = {key: value for key, value in row.items()}
                    devicesInfoTemp.append(rowAsDict)

            for deviceInfo in devicesInfoTemp:
                portTupleTemp.append(deviceInfo['port'])

            for port in portTupleTemp:
                if port not in portTuple and port != '':
                    portTuple.append(port)

            for deviceInfo in devicesInfoTemp:
                del deviceInfo['port']
                devicesInfo.append(deviceInfo)
        else:
            devicesInfo = device_info
            portTuple = port_tuple

        if new_config:
            self.ixNetwork.NewConfig()
        self.ixNetwork.Traffic.UseRfc5952 = True
        for device in devicesInfo:
            if device['port_name'] == '':
                continue
            else:
                if self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$'):
                    topology = self.ixNetwork.Topology.find(Name='^' + device['port_name'] + '$')
                else:
                    topology = self.ixNetwork.Topology.add(Name=device['port_name'], Note=None, Ports=None, Vports=self.ixNetwork.Vport.add(Name=device['port_name']))

                if 'subinterfaces_count' in device and device['subinterfaces_count']!= '':
                    multiplier = device['subinterfaces_count']
                else:
                    multiplier = 1
                if topology.DeviceGroup.find(Name=device['device_name']):
                    devicegroupObj = topology.DeviceGroup.find(Name=device['device_name'])
                    ethernetObj = devicegroupObj.Ethernet.find()
                else:
                    devicegroupObj = topology.DeviceGroup.add(Multiplier=multiplier, Name=device['device_name'])
                    ethernetObj = devicegroupObj.Ethernet.add()

                if 'vlan' in device and device['vlan'] != '':
                    ethernetObj.EnableVlans.Single(True)
                    ethernetObj.Vlan.find()[0].VlanId.Increment(start_value=device['vlan'], step_value=1)
                if 'ipv4_address' in device and device['ipv4_address'] != '':
                    if ethernetObj.Ipv4.find():
                        ipv4Obj = ethernetObj.Ipv4.find()
                    else:
                        ipv4Obj = ethernetObj.Ipv4.add()
                    if 'ipv4_address_step' in device  and device['ipv4_address_step'] != '':
                        step = device['ipv4_address_step']
                    else:
                        step = "0.0.1.0"
                    ipv4Obj.Address.Increment(start_value=device['ipv4_address'], step_value=step)
                if 'ipv4_prefix' in device and device['ipv4_prefix'] != '':
                    ipv4Obj.Prefix.Single(device['ipv4_prefix'])
                if 'ipv4_gateway' in device and device['ipv4_gateway'] != '':
                    if 'ipv4_gateway_step' in device  and device['ipv4_gateway_step'] != '':
                        step = device['ipv4_gateway_step']
                    else:
                        step = "0.0.1.0"
                    ipv4Obj.GatewayIp.Increment(start_value=device['ipv4_gateway'], step_value=step)
                if 'ipv6_address' in device and device['ipv6_address'] != '':
                    if ethernetObj.Ipv6.find():
                        ipv6Obj = ethernetObj.Ipv6.find()
                    else:
                        ipv6Obj = ethernetObj.Ipv6.add()
                    if 'ipv6_address_step' in device  and device['ipv6_address_step'] != '':
                        step = device['ipv6_address_step']
                    else:
                        step = "::1:0"
                    ipv6Obj.Address.Increment(start_value=device['ipv6_address'], step_value=step)
                if 'ipv6_prefix' in device and device['ipv6_prefix'] != '':
                    ipv6Obj.Prefix.Single(device['ipv6_prefix'])
                if 'ipv6_gateway' in device and device['ipv6_gateway'] != '':
                    if 'ipv6_gateway_step' in device  and device['ipv6_gateway_step'] != '':
                        step = device['ipv6_gateway_step']
                    else:
                        step = "::1:0"
                    ipv6Obj.GatewayIp.Increment(start_value=device['ipv6_gateway'], step_value=step)

                igmpKwargs = {key: device[key] for key in device if "igmp" in key and device[key] != ""}
                mldKwargs = {key: device[key] for key in device if "mld" in key and device[key] != ""}
                ospfv2Kwargs = {key: device[key] for key in device if "ospf_v2" in key and device[key] != ""}
                ospfv3Kwargs = {key: device[key] for key in device if "ospf_v3" in key and device[key] != ""}
                ldpv4Kwargs = {key: device[key] for key in device if "ldp_v4" in key and device[key] != ""}
                ldpv6Kwargs = {key: device[key] for key in device if "ldp_v6" in key and device[key] != ""}
                bgpv4Kwargs = {key: device[key] for key in device if "bgp_v4" in key and device[key] != ""}
                bgpv6Kwargs = {key: device[key] for key in device if "bgp_v6" in key and device[key] != ""}
                isisKwargs = {key: device[key] for key in device if "isis" in key and device[key] != ""}

                # Create IGMP
                if igmpKwargs != {}:
                    igmpObj = IGMP(ixNetwork=self.ixNetwork,
                                   obj=ipv4Obj,
                                   **igmpKwargs)
                    igmpObj.config()

                # Create MLD
                if mldKwargs != {}:
                    mldObj = MLD(ixNetwork=self.ixNetwork,
                                 obj=ipv6Obj,
                                 **mldKwargs)
                    mldObj.config()

                # Create OSPFv2
                if ospfv2Kwargs != {}:
                    ospfv2Obj = OSPFv2(ixNetwork=self.ixNetwork,
                                       obj=ipv4Obj,
                                       **ospfv2Kwargs)
                    ospfv2Obj.config()

                # Create OSPFv3
                if ospfv3Kwargs != {}:
                    ospfv3Obj = OSPFv3(ixNetwork=self.ixNetwork,
                                       obj=ipv6Obj,
                                       **ospfv3Kwargs)
                    ospfv3Obj.config()

                #Create LDP on IPV4
                if ldpv4Kwargs != {}:
                    ldpv4Obj = LDPv4(ixNetwork=self.ixNetwork,
                                       obj=ipv4Obj,
                                       **ldpv4Kwargs)
                    ldpv4Obj.config()

                #Create LDP on IPV6
                if ldpv6Kwargs != {}:
                    ldpv6Obj = LDPv6(ixNetwork=self.ixNetwork,
                                       obj=ipv6Obj,
                                       **ldpv6Kwargs)
                    ldpv6Obj.config()

                # Create BGPv4
                if bgpv4Kwargs != {}:
                    bgpv4Obj = BGPv4(ixNetwork=self.ixNetwork,
                                     obj=ipv4Obj,
                                     **bgpv4Kwargs)
                    bgpv4Obj.config()

                # Create BGPv6
                if bgpv6Kwargs != {}:
                    bgpv6Obj = BGPv6(ixNetwork=self.ixNetwork,
                                     obj=ipv6Obj,
                                     **bgpv6Kwargs)
                    bgpv6Obj.config()

                # Create ISIS
                if isisKwargs != {}:
                    isisObj = ISIS(ixNetwork=self.ixNetwork,
                                   obj=ethernetObj,
                                   test_platform=self.testPlatform,
                                   server_type=self.tgn_server_type,
                                   server_ip=self.server_ip,
                                   port=self.port,
                                   **isisKwargs)
                    isisObj.config()

        if portTuple:
            chassisList = list()
            portList = list()
            for port in portTuple:
                chassisListTemp = port.split('/')
                portListTemp = port.split('/')
                if len(chassisListTemp) < 3:
                    chassisList.append(self.chassis_ip)
                    portListTemp.insert(0, self.chassis_ip)
                else:
                    chassisList.append(port.split('/')[0])
                portList.append(portListTemp)
            chassisList = list(set(chassisList))
            self.connect_to_chassis(chassisList)
            self._assign_ports(portList)

    def add_multiple_traffic_streams(self, traffic_info=None, csv_file=None, **kwargs):
        """
        API to create multiple traffic streams

        :param traffic_info: list of dictionary [{'stream_name': 'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc',
        'stream_type': 'Unicast', 'traffic_type': 'ipv4', 'stream_src': 'TenGigE0/2/0/0_v4',
        'stream_dest': 'TenGigE0/2/0/1_v4', 'frame_size': '1518', 'multicast_address': '', 'bi-directional': 'FALSE',
        'Groupname(multicast) (Eg: ipv4Group1)': '', 'Increment(Multicast)(Eg: 3:1)': '255.255.255.255', 'txLoad(%)': '100',
        'tolerance(%)': '', 'tcp_header': 'TRUE', 'tcp_src_port': '2000', 'tcp_dst_port': '3000', 'udp_header': '',
        'udp_src_port': '', 'udp_dst_port': '', 'throughput(%)': '', 'tos': 'Precedence'}]

        :param csv_file: csv file
        :param  stream_name'    Ex:  'TenGigE0/2/0/0_to_TenGigE0/2/0/1_ipv4_uc'
        :param   'stream_type'  Ex:  'Unicast'
        :param   'traffic_type' Ex:  'ipv4'
        :param   'stream_src'   Mandatory parameter Ex:  'TenGigE0/2/0/0_v4'
        :param   'stream_dest'  Mandatory parameter Ex:  'TenGigE0/2/0/1_v4'
        :param   'frame_size'   Ex:  '1518'
        :param   'multicast_address'    Ex:  '255.255.255.255'
        :param   'bi-directional'   Ex:  'FALSE'
        :param   'Groupname(multicast)  Ex:  ipv4Group1)'
        :param   'Increment(Multicast)  Ex: 3
        :param   'txLoad(%)'    Ex:  '100'
        :param   'tolerance(%)' Ex:  ''
        :param   'tcp_header'   Ex:  'TRUE'
        :param   'tcp_src_port' Ex:  '2000'
        :param   'tcp_dst_port' Ex:  '3000'
        :param   'udp_header'   Ex:  'TRUE'
        :param   'udp_src_port' Ex:  '2000'
        :param   'udp_dst_port' Ex:  '3000'
        :param   'throughput(%)'Ex: '100'
        :param   'tos' if value is from '0'-'255'
                  IP Priority will be set to 'TOS' if 'tos' value is  from '0' to '7' or ""000 Routine","001 Priority","010 Immediate","011 Flash","100 Flash Override","101 CRITIC/ECP","110 Internetwork Control"
                  IP Priority will be set to 'Raw Priority' if value is from '8' to '255'
        :param   'enable' bool
        :param   'raw_stream_ip_stack' : ipv4 or ipv6
        :param   'eth_src_mac' Ex: '00:00:00:00:00:01'
        :param   'eth_dst_mac' Ex: '00:00:00:00:01:01'
        :param   'eth_dst_mac_mode' Ex: 'INCR'
        :param   'eth_src_mac_mode' Ex: 'INCR'
        :param   'eth_src_mac_count' Ex: 1
        :param   'eth_dst_mac_count' Ex: 1
        :param   'eth_dst_mac_step' Ex: '00:00:00:00:00:01'
        :param   'eth_src_mac_step' Ex: '00:00:00:00:00:01'
        :param   'src_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'
        :param   'src_count' Ex: 1
        :param   'dst_mode' Ex: 'INCR'
        :param   'dst_ip' Ipv4/Ipv6 address Ex: '100.0.1.1'/'1000::1'
        :param   'dst_count' Ex: 1
        :param   'dst_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'
        :param   'src_mode' Ex: 'INCR'
        :param   'src_count' Ex: 1
        :param   'src_step' Ipv4/Ipv6 address Ex: '0.0.0.1'/'::1'
        :return:
        """
        self.log.info("Adding Multiple Traffic Items")
        trafficsItemInfo = list()
        if csv_file:
            with open(csv_file) as csvFile:
                reader = csv.DictReader(csvFile)
                for row in reader:
                    rowAsDict = {key: value for key, value in row.items()}
                    trafficsItemInfo.append(rowAsDict)
        else:
            trafficsItemInfo = traffic_info
        for trafficItemInfo in trafficsItemInfo:
            if trafficItemInfo['stream_type'] == '':
                continue
            else:
                trafficItemInfo['stream_name'] = trafficItemInfo['stream_name'].replace('+', '\+').replace('*', '\*')
                if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemInfo['stream_name'] + '$'):
                    trafficItem = self.ixNetwork.Traffic.TrafficItem.find(
                        Name='^' + trafficItemInfo['stream_name'] + '$')
                else:
                    trafficItem = self.ixNetwork.Traffic.TrafficItem.add(Name=trafficItemInfo['stream_name'],
                                                                         TrafficType=trafficItemInfo['traffic_type'],
                                                                         BiDirectional=trafficItemInfo.get(
                                                                             'bi-directional', False))
                if 'enable' in trafficItemInfo:
                    if trafficItemInfo['enable'] != '':
                        trafficItem.Enabled = trafficItemInfo['enable']
                sourcesIp = list()
                destinationsIp = list()
                sources = list()
                destinations = list()
                if trafficItemInfo['stream_type'] == 'Unicast':
                    if 'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] != '':
                        if trafficItemInfo['traffic_type'] == "raw":
                            if 'stream_src' not in trafficItemInfo or trafficItemInfo['stream_src'] == '':
                                raise IxiaConfigException(
                                    "Please send 'stream_src' parameter value to create Raw Traffic")
                            else:
                                vportHref = self.ixNetwork.Vport.find(
                                    Name='^' + trafficItemInfo['stream_src'] + '$').href
                                sources.append(vportHref + '/protocols')
                        else:
                            sourcesIp = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],
                                                                      topology=None)
                    else:
                        if trafficItemInfo['traffic_type'] == "raw":
                            if self.ixNetwork.Vport.find(Name='^' + trafficItemInfo['stream_src'] + '$'):
                                vportHref = self.ixNetwork.Vport.find(
                                    Name='^' + trafficItemInfo['stream_src'] + '$').href
                                sources.append(vportHref + '/protocols')
                            else:
                                raise IxiaConfigException("Port Name '%s' not found" % trafficItemInfo['stream_src'])
                        else:
                            sources = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + trafficItemInfo['stream_src'] + '$')
                    if 'dst_ip' in trafficItemInfo and trafficItemInfo['dst_ip'] != '':
                        if trafficItemInfo['traffic_type'] == "raw":
                            if 'stream_dest' not in trafficItemInfo or trafficItemInfo['stream_dest'] == '':
                                raise IxiaConfigException(
                                    "Please send 'stream_dest' parameter value to create Raw Traffic")
                            else:
                                vportHref = self.ixNetwork.Vport.find(
                                    Name='^' + trafficItemInfo['stream_dest'] + '$').href
                                destinations.append(vportHref + '/protocols')
                        else:
                            destinationsIp = self._endpoint_destination_handles(trafficItemInfo['dst_ip'],
                                                                                destinationsList=[], topology=None)
                    else:
                        if trafficItemInfo['traffic_type'] == "raw":
                            if self.ixNetwork.Vport.find(Name='^' + trafficItemInfo['stream_dest'] + '$'):
                                vportHref = self.ixNetwork.Vport.find(
                                    Name='^' + trafficItemInfo['stream_dest'] + '$').href
                                destinations.append(vportHref + '/protocols')
                            else:
                                raise IxiaConfigException("Port Name '%s' not found" % trafficItemInfo['stream_dest'])
                        else:
                            destinations = self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + trafficItemInfo['stream_dest'] + '$')
                    if sourcesIp and destinationsIp:
                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesIp,
                                                    ScalableDestinations=destinationsIp)
                    elif sourcesIp and not destinationsIp:
                        raise IxiaConfigException("Raised exception due to destination Ip not passed")
                    elif not sourcesIp and destinationsIp:
                        raise IxiaConfigException("Raised exception due to source Ip not passed")
                    else:
                        trafficItem.EndpointSet.add(Name=None, Sources=sources, Destinations=destinations)
                else:
                    sources = self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + trafficItemInfo['stream_src'] + '$')
                    if 'src_ip' in trafficItemInfo and trafficItemInfo['src_ip'] != '':
                        sourcesIp = self._endpoint_source_handles(trafficItemInfo['src_ip'], sourcesList=[],
                                                                  topology=None)
                    mcastdestination = [
                        {"arg1": False, "arg2": "none", "arg3": trafficItemInfo['multicast_address'], "arg4": "0.0.0.0",
                         "arg5": 1}]
                    if sourcesIp:
                        trafficItem.EndpointSet.add(Name=None, ScalableSources=sourcesIp,
                                                    MulticastDestinations=mcastdestination)
                    else:
                        trafficItem.EndpointSet.add(Name=None, Sources=sources, MulticastDestinations=mcastdestination)

                if 'frame_size' in trafficItemInfo and trafficItemInfo['frame_size'] != '':
                    stackObj = trafficItem.ConfigElement.find().FrameSize
                    setattr(stackObj, 'FixedSize', trafficItemInfo['frame_size'])

                if 'txLoad(%)' in trafficItemInfo and trafficItemInfo['txLoad(%)'] != '':
                    stackObj = trafficItem.ConfigElement.find().FrameRate
                    setattr(stackObj, 'Type', 'percentLineRate')
                    setattr(stackObj, 'Rate', trafficItemInfo['txLoad(%)'])

                if trafficItemInfo['traffic_type'] == "raw":
                    if kwargs.get('eth_src_mac', None) or kwargs.get('eth_dst_mac', None) or kwargs.get('eth_src_mac',
                                                                                                        None) is None or kwargs.get(
                        'eth_dst_mac', None) is None:
                        if kwargs.get('eth_dst_mac_mode', None) == "INCR" or kwargs.get('eth_dst_mac_mode',
                                                                                        None) is None:
                            kwargs['eth_dst_mac_mode'] = 'increment'
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(
                            DisplayName="Destination MAC Address")
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                            'eth_dst_mac_mode', None), \
                                                                                                                 kwargs.get(
                                                                                                                     'eth_dst_mac',
                                                                                                                     "00:00:00:00:01:01"), kwargs.get(
                            'eth_dst_mac_count', 1), kwargs.get('eth_dst_mac', "00:00:00:00:01:01"), kwargs.get(
                            'eth_dst_mac_step', "00:00:00:00:00:01")

                        if kwargs.get('eth_src_mac_mode', None) == "INCR" or kwargs.get('eth_src_mac_mode',
                                                                                        None) is None:
                            kwargs['eth_src_mac_mode'] = 'increment'
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(
                            DisplayName="Source MAC Address")
                        field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = kwargs.get(
                            'eth_src_mac_mode', None), \
                                                                                                                 kwargs.get(
                                                                                                                     'eth_src_mac',
                                                                                                                     "00:00:00:00:00:01"), kwargs.get(
                            'eth_src_mac_count', 1), kwargs.get('eth_src_mac', "00:00:00:00:00:01"), kwargs.get(
                            'eth_src_mac_step', "00:00:00:00:00:01")
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46'):
                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':
                            pass
                        else:
                            trafficItemInfo['tos'] = 0
                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')
                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')
                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                        if ipv4Stack:
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                            flag = False
                            try:
                                if int(trafficItemInfo['tos']) > 7:
                                    flag = True
                            except:
                                pass
                            if flag:
                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                            else:
                                setattr(stackObj.Field.find(Name='precedence'), 'FieldValue', trafficItemInfo['tos'])
                        else:
                            if ethernetStack and vlanStack and not ipv4Stack:
                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv4Template))
                            if ethernetStack and not vlanStack and not ipv4Stack:
                                ipv4Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv4$")
                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv4Template))
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                            flag = False
                            try:
                                if int(trafficItemInfo['tos']) > 7:
                                    flag = True
                            except:
                                pass
                            if flag:
                                stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                                setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                            else:
                                setattr(stackObj.Field.find(Name='precedence'), 'FieldValue', trafficItemInfo['tos'])
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46'):
                        if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '':
                            pass
                        else:
                            trafficItemInfo['tos'] = 0
                        ethernetStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ethernet$')
                        vlanStack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^vlan$')
                        ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                        ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                        if ipv6Stack:
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',
                                    trafficItemInfo['tos'])
                        else:
                            if ethernetStack and vlanStack and not ipv6Stack and not ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(vlanStack.AppendProtocol(ipv6Template))
                            if ethernetStack and not vlanStack and not ipv6Stack and not ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ethernetStack.AppendProtocol(ipv6Template))
                            if ethernetStack and not vlanStack and not ipv6Stack and ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))
                            if ethernetStack and vlanStack and not ipv6Stack and ipv4Stack:
                                ipv6Template = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^ipv6$")
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(ipv6Template))
                            stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                            setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue',
                                    trafficItemInfo['tos'])
                    if 'raw_stream_ip_stack' in trafficItemInfo and (
                            trafficItemInfo['raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo[
                        'raw_stream_ip_stack'] == 'ipv46' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv6'):
                        if 'src_ip' in trafficItemInfo or 'dst_ip' in trafficItemInfo or 'src_count' in trafficItemInfo:
                            if 'dst_mode' in trafficItemInfo:
                                if trafficItemInfo['dst_mode'] == "INCR" or trafficItemInfo['dst_mode'] is None:
                                    trafficItemInfo['dst_mode'] = 'increment'
                            else:
                                trafficItemInfo['dst_mode'] = 'increment'
                            if 'dst_ip' in trafficItemInfo:
                                if trafficItemInfo['dst_ip'] == '':
                                    trafficItemInfo['dst_ip'] = None
                            else:
                                trafficItemInfo['dst_ip'] = None
                            if 'dst_count' not in trafficItemInfo or 'src_count' not in trafficItemInfo:
                                trafficItemInfo['dst_count'] = 1
                                trafficItemInfo['src_count'] = 1
                            if 'dst_step' not in trafficItemInfo or 'src_step' not in trafficItemInfo:
                                if ':' in trafficItemInfo['src_ip']:
                                    trafficItemInfo['dst_step'] = '::1'
                                    trafficItemInfo['src_step'] = '::1'
                                else:
                                    trafficItemInfo['dst_step'] = '0.0.0.1'
                                    trafficItemInfo['src_step'] = '0.0.0.1'
                            if ':' in trafficItemInfo['dst_ip']:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(
                                    DisplayName="Destination Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['dst_mode'], \
                                    trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo['dst_ip'], \
                                    trafficItemInfo['dst_step']
                            else:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(
                                    DisplayName="Destination Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['dst_mode'], \
                                    trafficItemInfo['dst_ip'], trafficItemInfo['dst_count'], trafficItemInfo['dst_ip'], \
                                    trafficItemInfo['dst_step']

                            if 'src_mode' in trafficItemInfo:
                                if trafficItemInfo['src_mode'] == "INCR" or trafficItemInfo['src_mode'] is None:
                                    trafficItemInfo['src_mode'] = 'increment'
                            else:
                                trafficItemInfo['src_mode'] = 'increment'
                            if 'src_ip' in trafficItemInfo:
                                if trafficItemInfo['src_ip'] == '':
                                    trafficItemInfo['src_ip'] = None
                            else:
                                trafficItemInfo['src_ip'] = None
                            if ':' in trafficItemInfo['src_ip']:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6").Field.find(
                                    DisplayName="Source Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['src_mode'], \
                                    trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo['src_ip'], \
                                    trafficItemInfo['src_step']
                            else:
                                field = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4").Field.find(
                                    DisplayName="Source Address")
                                field.ValueType, field.FieldValue, field.CountValue, field.StartValue, field.StepValue = \
                                    trafficItemInfo['src_mode'], \
                                    trafficItemInfo['src_ip'], trafficItemInfo['src_count'], trafficItemInfo[
                                        'src_ip'], trafficItemInfo['src_step']

                if trafficItemInfo['traffic_type'] == "ipv4" or trafficItemInfo[
                    'traffic_type'] == "ipv6" or 'raw_stream_ip_stack' in trafficItemInfo and (
                        trafficItemInfo['raw_stream_ip_stack'] == 'ipv6' or trafficItemInfo[
                    'raw_stream_ip_stack'] == 'ipv4' or trafficItemInfo['raw_stream_ip_stack'] == 'ipv46'):
                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[
                        'traffic_type'] == "ipv4":
                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv4")
                        flag = False
                        try:
                            if int(trafficItemInfo['tos']) > 7:
                                flag = True
                        except:
                            pass
                        if flag:
                            stackObj.Field.find(Name='raw').ActiveFieldChoice = True
                            setattr(stackObj.Field.find(Name='raw'), 'FieldValue', hex(int(trafficItemInfo['tos'])))
                        else:
                            setattr(stackObj.Field.find(Name='precedence'), 'FieldValue', trafficItemInfo['tos'])

                    if 'tos' in trafficItemInfo and trafficItemInfo['tos'] != '' and trafficItemInfo[
                        'traffic_type'] == "ipv6":
                        stackObj = trafficItem.ConfigElement.find().Stack.find(DisplayName="IPv6")
                        setattr(stackObj.Field.find(DisplayName='Traffic Class'), 'FieldValue', trafficItemInfo['tos'])

                    trafficItem.Tracking.find().TrackBy = ['trackingenabled0']

                    if 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [True, 'TRUE']:
                        tcpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^tcp$")
                        if trafficItemInfo['traffic_type'] == "raw":
                            ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                            ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                            if ipv4Stack and not ipv6Stack:
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))
                            if (ipv6Stack and not ipv4Stack) or (ipv6Stack and ipv4Stack):
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))
                        if trafficItemInfo['traffic_type'] == "ipv4":
                            ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                            trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(tcpTemplate))

                        if trafficItemInfo['traffic_type'] == "ipv6":
                            ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                            trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(tcpTemplate))

                    elif 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [True, 'TRUE']:
                        udpTemplate = self.ixNetwork.Traffic.ProtocolTemplate.find(StackTypeId="^udp$")
                        if trafficItemInfo['traffic_type'] == "raw":
                            ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                            ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                            if ipv4Stack and not ipv6Stack:
                                trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))
                            if (ipv6Stack and not ipv4Stack) or (ipv6Stack and ipv4Stack):
                                trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))
                        if trafficItemInfo['traffic_type'] == "ipv4":
                            ipv4Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv4$')
                            trafficItem.ConfigElement.find().Stack.read(ipv4Stack.AppendProtocol(udpTemplate))

                        if trafficItemInfo['traffic_type'] == "ipv6":
                            ipv6Stack = trafficItem.ConfigElement.find().Stack.find(StackTypeId='^ipv6$')
                            trafficItem.ConfigElement.find().Stack.read(ipv6Stack.AppendProtocol(udpTemplate))

                    if 'tcp_src_port' in trafficItemInfo and trafficItemInfo[
                        'tcp_src_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="TCP-Source-Port")
                        field.Auto = trafficItemInfo.get('tcp_src_auto', 'False')
                        field.ValueType = trafficItemInfo.get('tcp_src_mode', None)
                        field.FieldValue = trafficItemInfo.get('tcp_src_port', 1024)
                        field.CountValue = trafficItemInfo.get('tcp_src_count', 1)
                        field.StartValue = trafficItemInfo.get('tcp_src_port', None)
                        field.StepValue = trafficItemInfo.get('tcp_src_step', 1)

                    if 'tcp_dst_port' in trafficItemInfo and trafficItemInfo[
                        'tcp_dst_port'] != '' and 'tcp_header' in trafficItemInfo and trafficItemInfo['tcp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="TCP-Dest-Port")
                        field.Auto = trafficItemInfo.get('tcp_dst_auto', 'False')
                        field.ValueType = trafficItemInfo.get('tcp_dst_mode', None)
                        field.FieldValue = trafficItemInfo.get('tcp_dst_port', 1024)
                        field.CountValue = trafficItemInfo.get('tcp_dst_count', 1)
                        field.StartValue = trafficItemInfo.get('tcp_dst_port', None)
                        field.StepValue = trafficItemInfo.get('tcp_dst_step', 1)

                    if 'udp_src_port' in trafficItemInfo and trafficItemInfo[
                        'udp_src_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="UDP-Source-Port")
                        field.Auto = trafficItemInfo.get('udp_src_auto', 'False')
                        field.ValueType = trafficItemInfo.get('udp_src_mode', None)
                        field.FieldValue = trafficItemInfo.get('udp_src_port', 1024)
                        field.CountValue = trafficItemInfo.get('udp_src_count', 1)
                        field.StartValue = trafficItemInfo.get('udp_src_port', None)
                        field.StepValue = trafficItemInfo.get('udp_src_step', 1)

                    if 'udp_dst_port' in trafficItemInfo and trafficItemInfo[
                        'udp_dst_port'] != '' and 'udp_header' in trafficItemInfo and trafficItemInfo['udp_header'] in [
                        True, 'TRUE']:
                        field = trafficItem.ConfigElement.find().Stack.find().Field.find(DisplayName="UDP-Dest-Port")
                        field.Auto = trafficItemInfo.get('udp_dst_auto', 'False')
                        field.ValueType = trafficItemInfo.get('udp_dst_mode', None)
                        field.FieldValue = trafficItemInfo.get('udp_dst_port', 1024)
                        field.CountValue = trafficItemInfo.get('udp_dst_count', 1)
                        field.StartValue = trafficItemInfo.get('udp_dst_port', None)
                        field.StepValue = trafficItemInfo.get('udp_dst_step', 1)

    def add_device_traffic_configuration(self, csv_file=None):
        """
        API to add devices and traffic configuration using csv file format

        :param csv_file: csv file
        :return:
        """
        rows = list()
        devicesInfo = list()
        portTuple = list()

        with open(csv_file, 'r') as csvfile:
            csvreader = csv.reader(csvfile)

            for row in csvreader:
                rows.append(row)

        for rowIndex in range(len(rows)):
            if 'stream_name' in rows[rowIndex]:
                trafficConfigRow = rowIndex

        deviceConfigRows = rows[:trafficConfigRow]
        trafficConfigRows = rows[trafficConfigRow:]

        deviceHeaders = deviceConfigRows[0]
        devicesInfoList = deviceConfigRows[1:]

        devicesInfoTemp = [dict(zip(deviceHeaders, deviceInfo)) for deviceInfo in devicesInfoList]
        portTupleTemp = [deviceInfo['port'] for deviceInfo in devicesInfoTemp]

        for port in portTupleTemp:
            if port not in portTuple and port != '':
                portTuple.append(port)

        for deviceInfo in devicesInfoTemp:
            del deviceInfo['port']
            devicesInfo.append(deviceInfo)

        trafficHeaders = trafficConfigRows[0]
        trafficInfoList = trafficConfigRows[1:]

        trafficsItemInfo = [dict(zip(trafficHeaders, trafficInfo)) for trafficInfo in trafficInfoList]
        self.add_multiple_devices(port_tuple=portTuple, device_info=devicesInfo)
        self.add_multiple_traffic_streams(traffic_info=trafficsItemInfo)

    def get_twamp_test_sessions(self):
        """
        Get TWAMP Test Sessoin handler with respect to its Name

        :return: List of Name and handler of TWAMP Test Sessions
        :Example: get_twamp_test_sessions()
        """
        ControlRangeName_list = []
        for ControlRange in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampTestRange.find():
            ControlRangeName_list.append(ControlRange.ControlRangeName)
        return ControlRangeName_list

    def start_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):
        """
        Start TWAMP Sessions

        :param delay_time: Delay Time (by default 30)
        :param twamp_test_sessions: List of TWAMP Test session Name
        :return: Raises exception on failure
        :Example: start_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')
        """

        if delay_time:
            time.sleep(delay_time)
        if twamp_test_sessions:
            ControlRangeName_list = twamp_test_sessions
        else:
            ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name=ControlRange).Start()
            except:
                pass

    def stop_twamp_sessions(self, delay_time=None, twamp_test_sessions=None):
        """
        Stop TWAMP Sessions

        :param delay_time: Delay Time (by default 30)
        :param twamp_test_sessions: List of TWAMP Test session Name
        :return: Raises exception on failure
        :Example: stop_twamp_sessions(delay_time= 30, twamp_test_sessions='192.0.0.1')
        """
        if delay_time:
            time.sleep(delay_time)
        if twamp_test_sessions:
            ControlRangeName_list = twamp_test_sessions
        else:
            ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name=ControlRange).Stop()
            except:
                pass

    def request_twamp_sessions(self, router_ids):
        """
        Start Requesting TWAMP session by client from server

        :param router_ids: device list by default it request on all TWAMP client configured devices
        :return: Raises exception on failure
        :Example: request_twamp_sessions(router_ids='192.0.0.2')
        """
        ControlRangeName_list = self.get_twamp_test_sessions()
        for ControlRange in ControlRangeName_list:
            ControlRange = str(ControlRange)
            try:
                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name='^' + ControlRange + '$').Enabled = False
            except:
                pass
        if router_ids:
            self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                Name='^' + router_ids + '$').Enabled = True
            try:

                self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
                    Name='^' + router_ids + '$').Start()
            except:
                pass

    def create_custom_stats_view(self, custom_view_name=None):
        """
        Create custome stats view for each traffic stream.
        :param custom_view_name: Custom view name
        :param tree_view_node_name: Tree view node name
        :return:
        """

        self.ixNetwork.Statistics.View.add(Caption=custom_view_name, Type='layer23ProtocolStack', Visible=True)
        afil = self.ixNetwork.Statistics.View.find(
            Caption='^' + custom_view_name + '$').AvailableProtocolStackFilter.find()

        fil = \
        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Layer23ProtocolStackFilter.find()[0]
        fil.update(DrilldownType='perSession', ProtocolStackFilterId=afil[-1], SortAscending=True)
        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Statistic.find():
            stats.Enabled = True
        self.ixNetwork.Statistics.View.find(Caption='^' + custom_view_name + '$').Enabled = True

        TrafficItemStats = StatViewAssistant(self.ixNetwork, custom_view_name, LocalCsvStorage=CafyLog.work_dir)
        trafficItemStatsDict = {}
        columnCaptions1 = TrafficItemStats.ColumnHeaders
        columnCaptions = []

        for ele in columnCaptions1:
            if ele == ' Max Latency [us]':
                columnCaptions.append('" Max Latency [us]"')
            else:
                columnCaptions.append(ele)

        for rowNumber, stat in enumerate(TrafficItemStats.Rows):
            statsDict = {}
            for column in columnCaptions:
                statsDict[column] = stat[column]
            trafficItemStatsDict[rowNumber + 1] = statsDict
        dict = {'avg_jitter': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Jitter Max [us]'],
                'avg_latency': trafficItemStatsDict[list(trafficItemStatsDict.keys())[0]]['Network Max Latency [us]']}
        for key, value in trafficItemStatsDict.items():
            value.update(dict)
        return trafficItemStatsDict

    def get_twamp_test_session_results(self, router_id):
        """
        Get TWAMP Test Sessions Results of TWMP client device

        :param router_id: TWAMP Client ID on which TWAMP result should be obtained
        :return: TWAMP Test session result in dictionary
        :Example: get_twamp_test_session_results(router_id = '192.0.0.4')
        """
        view_name = self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find().TwampControlRange.find(
            Name='^' + router_id + '$').Name
        return self.create_custom_stats_view(custom_view_name=view_name)

    def start_twamp(self, router_ids):
        """
        Start TWAMP on mentioned hosts or on all
        :param router_ids: List of router_id by default it starts on all TWAMP configured devices
        :return: Raises exception on failure
        :Example: start_twamp(router_ids = '192.0.0.4')
        """
        if router_ids:
            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                try:
                    if range.TwampControlRange.find():
                        range.TwampControlRange.find(Name='^' + router_ids + '$').Start()
                except:
                    pass
        else:
            for port in self.ixNetwork.Vport.find():
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStart()
                except:
                    pass
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStart()
                except:
                    pass

    def stop_twamp(self, router_ids):
        """
        Stop TWAMP on mentioned hosts or on all
        :param router_ids: List of router_id by default it stops on all TWAMP configured devices
        :return: Raises exception on failure
        :Example: stop_twamp(router_ids = '192.0.0.4')
        """
        if router_ids:
            for range in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                try:
                    if range.TwampControlRange.find():
                        range.TwampControlRange.find(Name='^' + router_ids + '$').Stop()
                except:
                    pass
        else:
            for port in self.ixNetwork.Vport.find():
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampServer.find().TwampServerStop()
                except:
                    pass
                try:
                    if (port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find()):
                        port.find().ProtocolStack.Ethernet.find().IpEndpoint.find().TwampClient.find().TwampStop()
                except:
                    pass

    def get_twamp_test(self, router_id, delay=10):
        """
        Start TWAMP hosts, establish & start sessions and obtain their test results
        :param router_id: TWAMP Client device id from which TWAMP results to be obtained
        :param delay: Delay duration between Start and Stop
        :return: Results of TWAMP Test
        :Example: get_twamp_test(router_id = '192.0.0.4', delay = 10)
        """
        self.start_twamp()
        Helper.sleep(5, msg='Starting TWAMP on all Hosts')
        self.request_twamp_sessions()
        Helper.sleep(5, msg='Starting all TWAMP sessions')
        self.start_twamp_sessions()
        Helper.sleep(delay, msg='TWAMP Test delay')
        self.stop_twamp_sessions()
        results = self.get_twamp_test_session_results(router_id)
        self.stop_twamp()
        Helper.sleep(3, msg='Collecting TWAMP Results')
        return results

    def set_stream_only_generation(self, stream_block_name, enable=True):
        """
        This API is not applicable for IXIA and adding a dummy API to make it TGN vendor agnostic

        Set or unset stream only generation option for stream block(s)
        :param stream_block_name: string representing a stream block or 'all' representing all the streamblocks
        :param enable: boolean, false if you want to disable the stream only generation option
        :example: set_stream_only_generation(stream_block_name='StreamBlock 1',enable=False)
        :return:
        """
        pass

    def connect_to_lab_server(self,server_ip, timeout=300, api_version=1):
        """
        To connect to given TGN Lab server or API Server
        :param server_ip: IP address of TGN LabServer/APISerer
        :param timeout: Spirent Only Argument. Time to wait to receive response from server
        :param api_version: Spirent Only Argument. API version to use. Default is 1
        :return:
        """
        self.server_ip = server_ip
        self.log.info("Connecting to Ixia Lab Server - '%s'" %server_ip)

        if self.tgn_server_type == 'linux':
            self.testPlatform = TestPlatform(ip_address=server_ip, rest_port=self.port, platform='linux',
                                             log_file_name=CafyLog.work_dir + '/restpy.log')
            self.testPlatform.Authenticate(self.tgn_server_user, self.tgn_server_pw)

        if self.tgn_server_type == 'windows':
            self.log.warning("Connect Lab Server is Not Supported for Ixia Windows Lab Server")

    def _download_debug_files(self, type='ixncfg'):
        """
        To download debug files  and config files from Labserver to Cafy working directory.

        :param type: Format to save the Ixia config. Supports 'ixncfg' & 'json'. Default is 'ixncfg' format.
        :return: None
        :Example: _download_debug_files(type='ixncfg')
                  _download_debug_files(type='json')
        """
        filesToZip = []
        path = self.ixNetwork.Globals.PersistencePath
        if type == 'ixncfg':
            if self.tgn_server_type == 'windows':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')
                self._copyApiServerFileToLocalLinux(path + '\\' + 'IxiaConfig.ixncfg', CafyLog.work_dir,
                                                    localPathOs='windows',
                                                    includeTimestamp=False)
            if self.tgn_server_type == 'linux':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.ixncfg')
                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.ixncfg', CafyLog.work_dir,
                                                    localPathOs='linux',
                                                    includeTimestamp=False)
            filesToZip.append('IxiaConfig.ixncfg')
        elif type == 'json':
            if self.tgn_server_type == 'windows':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')
                self._copyApiServerFileToLocalLinux(path + '\\' + 'IxiaConfig.json', CafyLog.work_dir,
                                                    localPathOs='windows',
                                                    includeTimestamp=False)
            if self.tgn_server_type == 'linux':
                self.ixNetwork.SaveConfig(path + '/' + 'IxiaConfig.json')
                self._copyApiServerFileToLocalLinux(path + '/' + 'IxiaConfig.json', CafyLog.work_dir,
                                                    localPathOs='linux',
                                                    includeTimestamp=False)
            filesToZip.append('IxiaConfig.json')

        filesToZip.append('all.log')
        zip_file = os.path.join(CafyLog.work_dir, 'IxiaDebugLogs.zip')
        lenDirPath = len(CafyLog.work_dir)
        with ZipFile(zip_file, 'w') as zip:
            # writing each file one by one
            for file in filesToZip:
                log.info("Downloading %s from LabServer to %s" % (file, CafyLog.work_dir))
                file = CafyLog.work_dir + '/' + file
                zip.write(file, file[lenDirPath :])
                if file[lenDirPath :] != '/all.log':
                    os.remove(file)

    def traffic_options(self, **kwargs):
        """
        This API is used for the traffic options stats related changes
        :param kwargs:
                Argument:"frames_ordering" --> "No Ordering" , "peakLoading", "flowGroupSetup", "RFC2889"
        :return:
        """
        frames_order = kwargs.get("frames_ordering", None)
        if frames_order:
            if frames_order == 'RFC2889':
                self.ixNetwork.Traffic.EnableStreamOrdering = True
                self.ixNetwork.Traffic.FrameOrderingMode = frames_order
            else:
                self.ixNetwork.Traffic.EnableStreamOrdering = False
                self.ixNetwork.Traffic.FrameOrderingMode = frames_order

    def set_device_ip(self, device_name, ip_address_start, **kwargs):
        """
        Sets Device Ip addresses based on the device group name
        :param device_name: device name to which Ipv4/Ipv6 address need be set
        :param ip_address_start: Start Ip address to be set
        :param kwargs:
            :type: Ipv4/IPv6, Default value is ipv4
            :ip_address_step: Default Ipv4 ip address step is "0.0.0.1",
                              Default Ipv6 ip address step is "::0.1.0.0"

            :direction: increment|decrement, Default value is increment
            :gateway_address_start: Gateway Start Address
            :gateway_address_step: Default Ipv4 gateway address step is "0.0.0.0"
                                   Default Ipv6 gateway address step is "::0.0.0.0"
        :return: True if successful
        :Example: set_device_ip(device_name= 'TenGigE0/2/0/0_v4', ip_address_start = '6.5.5.5', gateway_address_start = '6.5.5.1')
        """
        # Setting Default values
        kwargs['type'] = kwargs.get('type', 'ipv4')
        kwargs['direction'] = kwargs.get('direction', 'increment')
        if kwargs['type'].lower() == 'ipv6':
            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '::0.1.0.0')
            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '::0.0.0.0')
            try:
                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
            except:
                raise IxiaOperationException("Device Group not Found")
        elif kwargs['type'].lower() == 'ipv4':
            kwargs['ip_address_step'] = kwargs.get('ip_address_step', '0.0.0.1')
            kwargs['gateway_address_step'] = kwargs.get('gateway_address_step', '0.0.0.0')
            try:
                ipObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().Ipv4.find()
            except:
                raise IxiaOperationException("Device Group not Found")

        if type(ip_address_start) == list:
            ipObj.Address.ValueList(values= ip_address_start)
        else:
            if kwargs['direction'].lower() == "decrement":
                ipObj.Address.Decrement(start_value= ip_address_start, step_value= kwargs['ip_address_step'])
                if kwargs['gateway_address_start']:
                    ipObj.GatewayIp.Decrement(start_value=kwargs['gateway_address_start'], step_value=kwargs['gateway_address_step'])
                else:
                    pass
            elif kwargs['direction'].lower() == "increment":
                ipObj.Address.Increment(start_value=ip_address_start, step_value= kwargs['ip_address_step'])
                if kwargs['gateway_address_start']:
                    ipObj.GatewayIp.Increment(start_value=kwargs['gateway_address_start'],
                                                  step_value=kwargs['gateway_address_step'])
                else:
                    pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Device IP Address configured successfully")
        return True

    def capture_start_or_stop(self, port_name_list=None, action='Start'):
        """
        API used to Collect Data or control plane packets

        :param port_name_list: port name list on whc packet need to be captured. E.g. '1/10'
        :param action: To start capture or stop capture. Default is "start". options are "start" and "stop"
        :return: filename with path

        :Example: capture_start_or_stop(port_name_list=['1/9' ,'1/10'], action='stop')
        """
        port_list = []
        filenames = []
        if not port_name_list:
            for port in self.ixNetwork.Vport.find():
                port_list.append(port.AssignedTo)
        else:
            if type(port_name_list) == str:
                port_name_list = port_name_list.split(",")
            for port in port_name_list:
                port_info = port.split('/')
                port_info.insert(0, self.chassis_ip)
                port_list.append(':'.join(port_info))
        if action.lower() == 'stop':
            path = self.ixNetwork.Globals.PersistencePath
            captured_files = self.ixNetwork.SaveCaptureFiles(path)
            captured_files = [eachFile for eachFile in captured_files if "HW.cap" in eachFile]
            for port_name in port_list:
                vport = self.ixNetwork.Vport.find(AssignedTo='^' + port_name + '$')
                vportName = re.sub('/', '-', (vport.Name))
                for eachFile in captured_files:
                    if vportName in eachFile:
                        timestamp = time.strftime("%Y%m%d-%H%M%S")
                        filename = "capture_" + re.sub(' |/', '_',(vport.Name).replace("(offline)", "")) + "_" + timestamp + ".cap"
                        try:
                            if self.tgn_server_type == 'windows':
                                apiFilename = eachFile.split('\\')[-1]
                                apiFilename = apiFilename.replace(' ', '_')
                                srcFile = CafyLog.work_dir + "/" + apiFilename
                                dstFile = CafyLog.work_dir + "/" + filename
                                self._copyApiServerFileToLocalLinux(eachFile, CafyLog.work_dir, localPathOs='windows')
                            elif self.tgn_server_type == 'linux':
                                apiFilename = eachFile.split("/")[-1]
                                apiFilename = apiFilename.replace(' ', '_')
                                srcFile = CafyLog.work_dir + "/" + apiFilename
                                dstFile = CafyLog.work_dir + "/" + filename
                                self._copyApiServerFileToLocalLinux(eachFile, CafyLog.work_dir, localPathOs='linux')
                            os.rename(srcFile, dstFile)
                            filenames.append(dstFile)
                            log.info("Capture file successfully created: %s" % dstFile)
                        except:
                            pass
                        break
        elif action.lower() == 'start':
            self.ixNetwork.CloseAllTabs()
            for vport in self.ixNetwork.Vport.find():
                vport.Capture.HardwareEnabled = False
                vport.Capture.SoftwareEnabled = False
            for eachPort in port_list:
                vport = self.ixNetwork.Vport.find(AssignedTo='^' + eachPort + '$')
                vport.Capture.HardwareEnabled = True
                vport.Capture.SoftwareEnabled = True
                vport.Capture.CaptureMode = "captureContinuousMode"
                vport.RxMode = 'captureAndMeasure'
                self.log.info("Starting Packet Capture on Port - '%s'" % eachPort)
                vport.Capture.Start()
        return filenames

    def set_bgp_ttl(self, ttl, router_id=None):
        """
        Modify ttl value on BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100
        :return True on pass, Exception on failure.

        :Example: set_bgp_ttl(ttl=255, router_id='192.0.0.1')
        """
        if router_id:
            self.log.info("setting BGP ttl value {} on BGP Router ID {}".format(ttl, router_id))
        else:
            self.log.info("setting BGP ttl value {} on all BGP instances".format(ttl))
        self._set_get_bgp_ttl(action='set', ttl=ttl, router_id=router_id)
        return True

    def get_bgp_ttl(self, router_id=None):
        """
        To fetch ttl value of BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :return ttl_dict: Dictionary of router_id's and ttl value on pass, Exception on failure.

        :Example: get_bgp_ttl(router_id='192.0.0.1')
        """
        if router_id:
            self.log.info("getting BGP ttl value for BGP Router ID {}".format(router_id))
            dicttmp = self._set_get_bgp_ttl(action='get', router_id=router_id)
            if router_id in dicttmp.keys():
                ttl_dict = {router_id: dicttmp[router_id]}
        else:
            self.log.info("getting BGP ttl value for all BGP instances")
            ttl_dict = self._set_get_bgp_ttl(action='get', router_id=router_id)
        return ttl_dict

    def _set_get_bgp_ttl(self, action, ttl=None, router_id=None):
        """
        To Modify or to get ttl value on/of BGP devices.
        :param action: 'set' to set the ttl value on BGP devices, 'get' to get the ttl value of BGP devices.
        :param router_id: Router ID of the device on TGN. Ex: 1.1.1.1. If not provided, TTL in all the BGP devices will be set.
        :param ttl: ttl to be set on TGN for the devices. Ex: ttl=100
        :return True - If action is 'set'. ttl_dict - If action is 'get'.
        """
        deviceGroupObjects = []
        ttlDict = {}
        if router_id:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    if router_id in deviceGroup.RouterData.find().RouterId.Values:
                        deviceGroupObjects.append(deviceGroup)
                        break
            else:
                raise IxiaConfigException("Router Id '%s' not found on this configuration." % router_id)
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroup.RouterData.find():
                    deviceGroupObjects.append(deviceGroup)
        if deviceGroupObjects:
            for deviceGroupObj in deviceGroupObjects:
                try:
                    if deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                            if action.lower() == 'set':
                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))
                                if (len(listVal) > 1):
                                    if router_id:
                                        index = bgpObj.LocalRouterID.index(router_id)
                                        ttlValueList = bgpObj.Ttl.Values
                                        ttlValueList[index] = ttl
                                    else:
                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]
                                    bgpObj.Ttl.ValueList(ttlValueList)
                                else:
                                    bgpObj.Ttl.Single(ttl)
                            else:
                                rIdValueList = bgpObj.LocalRouterID
                                ttlValueList = bgpObj.Ttl.Values
                                dictTmp = zip(rIdValueList, ttlValueList)
                                ttlDict.update(dictTmp)
                except:
                    pass
                try:
                    if deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                        for bgpObj in deviceGroupObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                            if action.lower() == 'set':
                                listVal = list(dict.fromkeys(bgpObj.LocalRouterID))
                                if (len(listVal) > 1):
                                    if router_id:
                                        index = bgpObj.LocalRouterID.index(router_id)
                                        ttlValueList = bgpObj.Ttl.Values
                                        ttlValueList[index] = ttl
                                    else:
                                        ttlValueList = [ttl for val in bgpObj.Ttl.Values]
                                    bgpObj.Ttl.ValueList(ttlValueList)
                                else:
                                    bgpObj.Ttl.Single(ttl)
                            else:
                                rIdValueList = bgpObj.LocalRouterID
                                ttlValueList = bgpObj.Ttl.Values
                                dictTmp = zip(rIdValueList, ttlValueList)
                                ttlDict.update(dictTmp)
                except:
                    pass
        else:
            raise IxiaConfigException("No BGP found on this configuration.")
        if action.lower() == 'set':
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        else:
            return ttlDict

    def get_port_dict_streams(self, port='all'):
        '''
        Get dictionary of streams with port
        :param port: Port under which streams to returned, by default it is all ports
        :return: Dictionary of port and stream list

        :Example: get_port_dict_streams(port = ['Ethernet - 001'])
        '''
        portDict = dict()
        streamsList = []
        if port != 'all':
            ports = self._get_port_name_list(ports= port)
            if ports == []:
               raise CafyException.InvalidValueError('%s Port not available in config' % port)
        else:
            ports = [port.Name for port in self.ixNetwork.Vport.find()]
        for port_name in ports:
            for trafficItemObj in self.ixNetwork.Traffic.TrafficItem.find():
                for highLevelStreamObj in trafficItemObj.HighLevelStream.find():
                    if highLevelStreamObj.TxPortName == port_name:
                        if port_name not in portDict:
                            portDict[port_name] = []
                        portDict[port_name].append(trafficItemObj)
                    else:
                        streamsList.append(trafficItemObj)
        return portDict

    def activate_devices(self, device_list=None):
        """
        API to activate a given set of devices
        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'
        :return: True on success, else exception

        :Example: activate_devices(device_list=["Group Device 1"])
        """
        result = False
        if device_list:
            for deviceName in device_list:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(True)
            result = True
        else:
            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                deviceObj.Enabled.Single(True)
            result = True
        if result:
            return True
        else:
            raise IxiaConfigException("Failed due to configuration issue")

    def deactivate_devices(self, device_list=None):
        """
        API to deactivate a given set of devices
        :param device_list: (list) A list of devices to activate e.g. 'Device 1', 'Device 2'
        :return: True on success, else exception

        :Example: deactivate_devices(device_list=["Group Device 1"])
        """
        result = False
        if device_list:
            for deviceName in device_list:
                self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceName).Enabled.Single(False)
            result = True
        else:
            for deviceObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                deviceObj.Enabled.Single(False)
            result = True
        if result:
            return True
        else:
            raise IxiaConfigException("Failed due to configuration issue")

    def get_module_port_status(self, chassis_to_check=None, port_list=None, check_ports=False):
        """
        Checks the module and port group status of the current chassis
        :param chassis_to_check: (str) Optional IP of the chassis to check (default is current)
            e.g. '172.16.20.5'
        :param port_list: (list) An optional list of ports to check (default is check all)
            e.g. ['5/7', '5/8', '7/10']
        :param check_ports: (bool) Toggles checking at the port level
        :return: 172.16.20.5,

        :Example: get_module_port_status(chassis_to_check = '10.1.1.1')
        """
        result = False
        if chassis_to_check is None:
            chassis_final = self.ixNetwork.AvailableHardware.Chassis.find().Ip
        else:
            chassis_final = [chassisObj.Ip for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find() if
                             chassisObj.Ip == chassis_to_check]
        if chassis_final:
            statusDict = {}
            chassisIP = str(chassis_final)
            statusDict[chassisIP] = {}
            result = True
            try:
                if check_ports:
                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():
                        chassisState = chassisObj.State
                        statusDict[chassisIP][chassisState] = {}
                        if chassisObj.Ip == chassis_to_check:
                            for cport in port_list:
                                cslot, cinterface = cport.split('/')[0], cport.split('/')[1]
                                for cardObj in chassisObj.Card.find():
                                    slot = cardObj.CardId
                                    if slot == int(cslot):
                                        if slot not in statusDict[chassisIP][chassisState].keys():
                                            statusDict[chassisIP][chassisState][slot] = {}
                                        for portObj in cardObj.Port.find():
                                            portId = portObj.PortId
                                            if portId == int(cinterface):
                                                portId = portObj.PortId
                                                statusDict[chassisIP][chassisState][slot][portId] = {}
                                                statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable
                else:
                    for chassisObj in self.ixNetwork.AvailableHardware.Chassis.find():
                        chassisState = chassisObj.State
                        statusDict[chassisIP][chassisState] = {}
                        if chassisObj.Ip == chassis_to_check:
                            for cardObj in chassisObj.Card.find():
                                slot = cardObj.CardId
                                statusDict[chassisIP][chassisState][slot] = {}
                                for portObj in cardObj.Port.find():
                                    portId = portObj.PortId
                                    statusDict[chassisIP][chassisState][slot][portId] = {}
                                    statusDict[chassisIP][chassisState][slot][portId] = portObj.IsAvailable
            except Exception as err:
                raise CafyException.TgenClientError('Failed to retrieve module/port status: {}'.format(err))
        if result:
            return statusDict
        else:
            raise CafyException.InvalidValueError('No matching chassis found in {}'.format(chassis_to_check))

    def create_ipv4_interface(self, router_id=None, ipv4_address=None, ipv4_gateway=None, ipv4_gateway_mac=None,
                              ipv4_prefix_length=None):
        """
        Creates Ipv4If object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param ipv4_address: Mapping Ipv4If attribute - Address. Example: 105.1.0.2
        :param ipv4_gateway: Mapping Ipv4If attribute - Gateway. IPv4 gateway address. Example: 104.1.0.1
        :param ipv4_gateway_mac: Mapping Ipv4If attribute - GatewayMac. Gateway MAC address. Example: 00:00:00:00:00:01
        :param ipv4_prefix_length: Mapping Ipv4If attribute - PrefixLength. IPv4 address prefix length. Range: 0 - 32
        :return: Ipv4If object.
        :Example: create_ipv6_interface(router_id='10.10.10.1',ipv4_address='10.10.1.1',
                              ipv4_gateway='10.10.1.2', ipv4_gateway_mac='00:00:01:00:00:01',
                              ipv4_prefix_length='24')
        """
        result = False
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            print("self.ixNetwork.Topology.find().")
            print(self.ixNetwork.Topology.find().DeviceGroup.find())
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    Ipv4Obj = deviceGroup.Ethernet.add().Ipv4.add()
                    Ipv4Obj.Address.Increment(start_value=ipv4_address)
                    Ipv4Obj.GatewayIp.Increment(start_value=ipv4_gateway)
                    Ipv4Obj.ManualGatewayMac.Increment(start_value=ipv4_gateway_mac)
                    Ipv4Obj.Prefix.Increment(start_value=ipv4_prefix_length)
                    break
        if result:
            return Ipv4Obj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_ipv6_interface(self, router_id, ipv6_address=None, ipv6_gateway=None, ipv6_gateway_mac=None,
                              ipv6_prefix_length=None,ipv6_gateway_learning=None):
        """
        Creates Ipv6If object.
        :param router_id: Router ID of Device
        :param ipv6_address: ipv6 address
        :param ipv6_gateway: ipv6 gateway address
        :param ipv6_gateway_mac: ipv6 gateway mac address
        :param ipv6_prefix_length: ipv6 prefix length
        :param ipv6_gateway_learning: ipv6 gateway learning mode
                                    : for ixia Resolve gateway True|False, default is True.
        :return: Ipv6If object.
        :Example: create_ipv6_interface(router_id='10.10.10.1', ipv6_address='1000:0:0:1::1',
                              ipv6_gateway='1000:0:0:1::2',ipv6_gateway_mac='00:00:10:00:00:10',
                              ipv6_prefix_length='112',ipv6_gateway_learning=True)))
        """
        result = False
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    Ipv6Obj = deviceGroup.Ethernet.add().Ipv6.add()
                    Ipv6Obj.Address.Increment(start_value=ipv6_address)
                    Ipv6Obj.GatewayIp.Increment(start_value=ipv6_gateway)
                    Ipv6Obj.ManualGatewayMac.Increment(start_value=ipv6_gateway_mac)
                    Ipv6Obj.Prefix.Increment(start_value=ipv6_prefix_length)
                    Ipv6Obj.ResolveGateway.Single(ipv6_gateway_learning)
                    break
        if result:
            return Ipv6Obj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))


    def delete_emulated_device(self, router_id=None):
        """
        Deletes emulated device Objects.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
        configured.
        :return: True on success
        :Example: delete_emulated_device(router_id='10.10.10.1')
        """
        result = False
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
            if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                result = True
                deviceGroup.remove()
                break
        if result:
            return True
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_dhcp_option(self,router_id,option_type,address_family,
                           msg_type=['kDiscover', 'kRequest'],
                           msg_type_list=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'],
                           remove=False, **kwargs):
        """
        Configures dhcpv4 or dhcpv6 options (TLV).
        :param router_id: Name of Device group in which DHCP client is configured.
        :param option_type: Option value (code).
        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6.
        :param msg_type: only applicable to dhcpv4. Includes the message option in 'kDiscover', 'kRequest', 'kDecline', 'kRelease'.
            Default value for v4 client is ['kDiscover', 'kRequest']
        :param msg_type_list: only applicable to dhcpv6. Possible values are 'kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'
            Default value for v4 client is ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'']
        :param remove: Enable or disable removal of option (TLV). Default is False.
        :return: True on success.
        :Example: create_dhcp_option(router_id="dhcp-v6-client", option_type=['SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',
                 'Identity Association for Prefix Delegation'], address_family="IPV6", msg_type=['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind'], remove=True)
        """

        v4Msg = ['kDiscover', 'kRequest', 'kDecline', 'kRelease', 'kInform']
        v4Tlv = ['Subnet Mask', 'Time Offset', 'Router Address', 'Time Server', 'Name Server', 'Domain Name Server',
                 'Log Server', 'Cookie Server', 'LPR Server', 'Impress Server', 'Resource Location Server', 'Host Name',
                 'Boot File Size', 'Merit Dump File', 'Domain Name', 'Swap Server', 'Root Path', 'Extension Path',
                 'IP Forwarding Enable/Disable', 'Non-Local Source Routing Enable/Disable', 'Policy Filter',
                 'Maximum Datagram Reassembly Size', 'Default IP Time-to-live', 'Path MTU Aging Timeout',
                 'Path MTU Plateau Table', 'Interface MTU Size', 'All Subnets are Local', 'Broadcast Address',
                 'Perform Mask Discovery', 'Mask Supplier', 'Perform Router Discovery', 'Router Solicitation Address',
                 'Static Route', 'Trailer Encapsulation', 'ARP Cache Timeout', 'Ethernet Encapsulation',
                 'TCP Default TTL', 'TCP Keepalive Interval', 'TCP Keepalive Garbage',
                 'Network Information Service Domain', 'Network Information Servers', 'Network Time Protocol Servers',
                 'Vendor Specific Information', 'NetBIOS over TCP/IP Name Server',
                 'NetBIOS over TCP/IP Datagram Distribution Server', 'NetBIOS over TCP/IP Node Type',
                 'NetBIOS over TCP/IP Scope', 'X Window System Font Server', 'X Window System Display Manager',
                 'Requested IP Address', 'IP Address Lease Time', 'Option Overload', 'DHCP Message Type',
                 'Server Identifier', 'Parameter Request List', 'Message', 'Maximum DHCP Message Size',
                 'Renewal (T1) Time Value', 'Renewal (T2) Time Value', 'Vendor Class Identifier', 'Client Identifier',
                 'NetWare/IP Domain Name', 'NetWare/IP Information', 'Network Information Service+ Domain',
                 'Network Information Service+ Servers', 'TFTP Server Name', 'Bootfile Name', 'Mobile IP Home Agent',
                 'Simple Mail Transport Protocol (SMTP) Server', 'Post Office Protocol (POP3) Server',
                 'Network News Transport Protocol (NNTP) Server', 'Default World Wide Web (WWW) Server',
                 'Default Finger Server', 'Default Internet Relay Chat (IRC) Server', 'StreetTalk Server',
                 'StreetTalk Directory Assistance (STDA) Server', 'User Class Information', 'SLP Directory Agent',
                 'SLP Service Scope', 'Rapid Commit', 'DHCP Client FQDN', 'DHCP Relay Agent Information',
                 'Authentication (RFC3118)']
        v6Msg = ['kSolicit', 'kRequest', 'kInformReq', 'kRelease', 'kRenew', 'kRebind']
        v6Tlv = ['Client Identifier', 'Client Identifier', 'Server Identifier',
                 'Identity Association for Non-temporary Addresses', 'Identity Association for Temporary Addresses',
                 'IA Address', 'Option Request', 'Preference', 'Elapsed Time', 'Relay Message', 'Authentication',
                 'Server Unicast', 'Status Code', 'Rapid Commit', 'User Class', 'Vendor Class',
                 'Vendor-specific Information', 'Interface-ID', 'Reconfigure Message', 'Reconfigure Accept',
                 'SIP Servers Domain Name', 'SIP Servers IPv6 Address', 'DNS Recursive Name Server', 'Domain Search',
                 'Identity Association for Prefix Delegation', 'IA_PD Prefix',
                 'Network Information Service (NIS) Servers', 'Network Information Service V2 (NIS+) Servers',
                 'Network Information Service (NIS) Domain Name',
                 'Network Information Service V2 (NIS+) Domain Name Option',
                 'Simple Network Time Protocol (SNTP) Servers', 'Information Refresh Time',
                 'Broadcast and Multicast Service Controller Domain Name',
                 'Broadcast and Multicast Service Controller IPv6 Address', 'DHCP Civic Location',
                 'Relay Agent Remote-ID', 'Relay Agent Subscriber-ID', 'Client FQDN', 'PANA Authentication Agent',
                 'POSIX Timezone', 'Timezone Database', 'Relay Agent Echo Request', 'Query', 'Client Data',
                 'Client Last Transaction Time', 'Relay Data', 'Client Link', 'MIPv6 Home Network ID FQDN',
                 'MIPv6 Visited Home Network Information', 'LoST Server', 'CAPWAP AC', 'Relay-ID', 'MoS IPv6 Address',
                 'MoS Domain Name List', 'NTP Server', 'Access Network Domain Name',
                 'SIP User Agent Configuration Service Domains', 'Boot File Uniform Resource Locator',
                 'Boot File Parameters', 'Client System Architecture Type', 'Client Network Interface Identifier',
                 'Geographical Location', 'AFTR-Name', 'ERP Local Domain Name', 'Relay-Supplied DHCP Options',
                 'Prefix Exclude', 'Virtual Subnet Selection', 'MIPv6 Identified Home Network Information',
                 'MIPv6 Unrestricted Home Network Information', 'MIPv6 Home Network Prefix', 'MIPv6 Home Agent Address',
                 'MIPv6 Home Agent FQDN', 'RDNSS Selection DHCPv6', 'Kerberos Principal Name', 'Kerberos Realm Name',
                 'Kerberos Default Realm Name', 'Kerberos KDC']

        if re.match('\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif any(type(var) is not list for var in (option_type, msg_type_list, msg_type)):
            raise IxiaOperationException('All these msg_type/msg_type_list/option_type arguments has to be in'
                                         ' list format')
        else:
            if self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id):
                if re.fullmatch('ipv4|v4', address_family, re.IGNORECASE):
                    if set(option_type) - set(v4Tlv) or set(msg_type) - set(v4Msg):
                        raise IxiaOperationException('DHCP v4 client supports the following message {0} and the '
                                                     'following TLV {1}'.format(v4Msg, v4Tlv))
                    else:
                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find()\
                            .Dhcpv4client.find()
                        tlvMessage = msg_type
                elif re.fullmatch('ipv6|v6', address_family, re.IGNORECASE):
                    if set(option_type) - set(v6Tlv) or set(msg_type_list) - set(v6Msg):
                        raise IxiaOperationException('DHCP v6 client supports the following message {0} and the '
                                                     'following TLV {1}'.format(v6Msg, v6Tlv))
                    else:
                        dhcpObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=router_id).Ethernet.find().\
                            Dhcpv6client.find()
                        tlvMessage = msg_type_list
                else:
                    raise IxiaOperationException('Given "{}" format is not supported for "address_family" argument. '
                                                 'It accepts any one from the following ipv4/v4/ipv6/v6'.
                                                 format(address_family))

                if not dhcpObj:
                    raise IxiaConfigException(
                        'DHCP {} client is not configured in the "{}" devicegroup'.format(address_family, router_id))

                if not remove:
                    for tlv in option_type:
                        dhcpObj.TlvProfile.find().Tlv.add(Name=tlv, IncludeInMessages=tlvMessage)
                    return True
                else:
                    tlvnotconfigured = []
                    for tlv in option_type:
                        if dhcpObj.TlvProfile.find().Tlv.find(Name=tlv):
                            dhcpObj.TlvProfile.find().Tlv.find(Name=tlv).remove()
                        else:
                            tlvnotconfigured.append(tlv)

                    if tlvnotconfigured:
                        self.log.info('The following TLV"s {0} are not configured in the DHCP {1} Client'
                                      .format(tlvnotconfigured, address_family))
                    return True
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))

    def _get(self, handle, *args):
        """
        Returns the value(s) of one or more object attributes.

        If multiple arguments, this method returns a dictionary of argument
        names mapped to the value returned by each argument.
        Ex :{attrib_name:attrib_val, attrib_name:attrib_val, ..}

        If a single argument is given, then the response is a list of values/string value
        for that argument.

        NOTE: If the string contains multiple substrings, then the
        client will need to parse these.
        :param handle: Handle that identifies object to get info for.
        :param args: Zero or more attributes or relationships.
        :return: Dictionary/list/string mapped to object attributes else raises exception.
        """
        data = {}
        try:
            if args:
                for arg in args:
                    if self.bgp_devices != {} and handle in self.bgp_devices:
                        bgpHandle = self.bgp_devices[handle]
                        data[arg] = eval('bgpHandle.' + arg)
                    if self.isis_devices != {} and handle in self.isis_devices:
                        isisHandle = self.isis_devices[handle]
                        data[arg] = eval('isisHandle.' + arg)
                    if self.ldp_devices != {} and handle in self.ldp_devices:
                        ldpHandle = self.ldp_devices[handle]
                        data[arg] = eval('ldpHandle.' + arg)
                    if self.ospf_devices != {} and handle in self.ospf_devices:
                        ospfHandle = self.ospf_devices[handle]
                        data[arg] = eval('ospfHandle.' + arg)
        except:
            raise IxiaOperationException(
                'Invalid handle "%s". Please obtain the handle using create or get' % str(handle))
        return data

    def _get_emulated_devices(self):
        """
        Get the list of Emulated Devices in configuration.

        :return: list of emulated devices.
        """
        log.debug('Fetch emulated devices from config')
        try:
            if self.ixNetwork.Topology.find().DeviceGroup.find():
                self.emulated_devices = self.ixNetwork.Topology.find().DeviceGroup.find()
            return self.emulated_devices
        except:
            raise IxiaOperationException("Device Config Not Found")

    def _get_bgp_config_for_emulated_devices(self):
        """
        Get BGP routers in the configuration.

        :return: Dictionary of BGP routers.
        """
        log.info('Fetch BGP devices from config')
        for device in self.emulated_devices:
            try:
                if device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find():
                    self.bgp_devices[
                        device.Ethernet.find().Ipv4.find()] = device.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()
                    self._get_bgp_routes_for_emulated_device(device)
            except:
                pass
            try:
                if device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find():
                    self.bgp_devices[
                        device.Ethernet.find().Ipv6.find()] = device.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()
                    self._get_bgp_routes_for_emulated_device(device)
            except:
                pass
        return self.bgp_devices

    def _get_bgp_routes_for_emulated_device(self, device, bgp_router_config=None):
        """
        Get the BGP routes for a given device.

        :param device: Emulated device name
        :param bgp_router_config: BGP router config handle
        :return:
        """
        device_name = device.Name
        try:
            if device.NetworkGroup.find().Ipv4PrefixPools.find().BgpIPRouteProperty.find() or device.NetworkGroup.find().Ipv4PrefixPools.find().BgpV6IPRouteProperty.find():
                for ipv4PrefixPool in device.NetworkGroup.find().Ipv4PrefixPools.find():
                    start_ip = ipv4PrefixPool.NetworkAddress.Values
                    router_id = device.RouterData.find().RouterId.Values
                    self.bgp_routes_startip_rid_v4[str(start_ip), str(router_id)] = ipv4PrefixPool
                    self.bgp_routes_startip_device_name_v4[str(start_ip), device_name] = ipv4PrefixPool
                    for topology in self.ixNetwork.Topology.find():
                        if topology.href in device.href:
                            for vportObj in self.ixNetwork.Vport.find():
                                if vportObj.href in topology.Vports:
                                    port_name = vportObj.Name
                                    self.bgp_routes_startip_port_name_v4[port_name, str(start_ip)] = ipv4PrefixPool
        except:
            pass
        try:
            if device.NetworkGroup.find().Ipv6PrefixPools.find().BgpV6IPRouteProperty.find() or device.NetworkGroup.find().Ipv6PrefixPools.find().BgpIPRouteProperty.find():
                for ipv6PrefixPool in device.NetworkGroup.find().Ipv6PrefixPools.find():
                    start_ip = ipv6PrefixPool.NetworkAddress.Values
                    router_id = device.RouterData.find().RouterId.Values
                    self.bgp_routes_startip_rid_v6[str(start_ip), str(router_id)] = ipv6PrefixPool
                    self.bgp_routes_startip_device_name_v6[str(start_ip), device_name] = ipv6PrefixPool
                    for topology in self.ixNetwork.Topology.find():
                        if topology.href in device.href:
                            for vportObj in self.ixNetwork.Vport.find():
                                if vportObj.href in topology.Vports:
                                    port_name = vportObj.Name
                                    self.bgp_routes_startip_port_name_v6[port_name, str(start_ip)] = ipv6PrefixPool
        except:
            pass

    def set_ipv4_traffic_ttl(self, traffic_item, ttl):
        """
        setting the value of the TTL Value for the specified traffic items

        :param traffic_item: (list/str) of Traffic items to set the TTL value from.
        :param ttl: (list/str/int) of ttl values to be set
        :return: return True on success else raises exception

        :Example: set_ipv4_traffic_ttl(traffic_item= ["Traffic Item 1","Traffic Item 2"],ttl = ['255','220'])
                  set_ipv4_traffic_ttl(traffic_item= ["Traffic Item 1","Traffic Item 2"],ttl = '255')
                  set_ipv4_traffic_ttl(traffic_item= "Traffic Item 1",ttl = '255')
                  set_ipv4_traffic_ttl(traffic_item= "Traffic Item 1",ttl = 255)
        """
        self.log.info("Setting TTL for Traffic item")
        if type(traffic_item) != list:
            traffic_item = [traffic_item]
        for item in traffic_item:
            item = item.replace('+', '\+').replace('*', '\*').replace('(','\(').replace(')','\)')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():
                try:
                    configElement.Stack.find(DisplayName="IPv4")
                    fieldValue = configElement.Stack.find(StackTypeId='ipv4').Field.find(Name='ttl')
                    fieldValue.ValueType = 'singleValue'
                    if type(ttl) == int:
                        ttl = str(ttl)
                        fieldValue.SingleValue = ''.join(ttl)
                    if type(ttl) == list:
                        fieldValue.SingleValue = ttl[traffic_item.index(item)]
                    if type(ttl) == str:
                        fieldValue.SingleValue = ''.join(ttl)
                except:
                    self.log.info("IPV4 stack Not Available in %s" % item)
                    raise IxiaOperationException("IPV4 Stack Not Available in %s" % item)
        return True

    def set_ipv6_traffic_hop_limit(self, traffic_item, hop_limit):
        """
        setting the value of the Hop Limit Value for the specified traffic items

        :param traffic_item: (list/str) of Traffic items to set the TTL value from.
        :param hop_limit: (list/str/int) of hop_limit values to be set
        :return: return True on success else raises exception

        :Example: set_ipv6_traffic_hop_limit(traffic_item= ["Traffic Item 1","Traffic Item 2"],hop_limit = ['255','220'])
                  set_ipv6_traffic_hop_limit(traffic_item= ["Traffic Item 1","Traffic Item 2"],hop_limit = '225')
                  set_ipv6_traffic_hop_limit(traffic_item= "Traffic Item 1",hop_limit = '225')
                  set_ipv6_traffic_hop_limit(traffic_item= "Traffic Item 1",hop_limit = 225)
        """
        self.log.info("Setting Hop Limit for Traffic item")
        if type(traffic_item) != list:
            traffic_item = [traffic_item]
        for item in traffic_item:
            item = item.replace('+', '\+').replace('*', '\*').replace('(','\(').replace(')','\)')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + item + '$').ConfigElement.find():
                try:
                    configElement.Stack.find(DisplayName="IPv6")
                    fieldValue = configElement.Stack.find(StackTypeId='ipv6').Field.find(Name='hopLimit')
                    fieldValue.ValueType = 'singleValue'
                    if type(hop_limit) == int:
                        hop_limit = str(hop_limit)
                        fieldValue.SingleValue = ''.join(hop_limit)
                    if type(hop_limit) == list:
                        fieldValue.SingleValue = hop_limit[traffic_item.index(item)]
                    if type(hop_limit) == str:
                        fieldValue.SingleValue = ''.join(hop_limit)
                except:
                    self.log.info("IPV6 stack Not Available in %s" % item)
                    raise IxiaOperationException("IPV6 Stack Not Available in %s" % item)
        return True

    def get_traffic_ethernet_vlan_priority(self, traffic_list):
        """
        Gets the value of the Ethernet VLAN priority for the specified traffic items

        :param traffic_list: A list of traffic items to get the VLAN priority values from.
        :return: A dict of results containing the VLAN ID and VLAN priority value for the specified traffic items

        :Example: get_traffic_ethernet_vlan_priority(traffic_list=["Traffic Item 1"])
        """
        self.log.info("Getting VLAN Priority For Traffic Items")
        results = {}
        for trafficName in traffic_list:
            vlanPriority = list()
            try:
                for vlanStack in self.ixNetwork.Traffic.TrafficItem.find(Name='^'+trafficName+'$').ConfigElement.find().Stack.find(StackTypeId='vlan'):
                    vlanPriority.append({'vlan':vlanStack.Field.find(Name='vlan_id').SingleValue,'priority': vlanStack.Field.find(Name='vlan_user_priority').SingleValue})
                results[trafficName] = vlanPriority
            except:
                self.log.info("Not able to find the %s in config" % trafficName)
                raise IxiaOperationException("Not able to find the %s in config" % trafficName)
        return results

    def set_network_group_count(self, network_count, network_group, **kwargs):
        """
        set network group count of MAC Pools
        :param network_count: network_count. Should be >=1
        :param network_group: Network Group Name
        :param kwargs:
                    network_group_mac: MAC address to be set on NG default is '10:00:00:00:00:00'
                    network_group_mac_step: MAC address to be incremented default is '00:00:00:00:00:01'
                    mac1: custom type mac address 1 default is '00:00:00:00:00:01'
                    mstep1: custom type mac address step 1 default is 1
                    mac2: custom type mac address 2 default is '00:00:00:00:00:01'
                    mstep2: custom type mac address step 2 default is 1

                    network_group_vlan: vlan start value default is 1001
                    network_group_vlan_step: vlan step value default is 1
                    vlan1: custom vlan1 increment value default is 1
                    vstep1: custom vlan1 step1 default is 1
                    vlan2: custom vlan2 increment value default is 1
                    vstep2: custom vlan2 step2 default is 1

        :return: True if successful
                raise exception if network group not found in config

        :Example: set_network_group_count(network_count = 5,network_group='Network Group 1')
                  set_network_group_count(network_count = 3,network_group='Network Group 1',network_group_mac = "00:13:00:01:10:01",
                               network_group_mac_step = "00:00:00:00:00:00",mac1 = '00:00:00:01:00:00',mstep1 = 4, mac2 = '00:00:00:00:00:01',mstep2 = 5,
                               network_group_vlan = 200, network_group_vlan_step = 3, vlan1 = 2,vstep1 = 1,vlan2 = 2,vstep2 = 2)
        """
        self.log.info("Setting Network Group count and MAC and VLAN")
        network_group_mac = kwargs.get('network_group_mac', '10:00:00:00:00:00')
        network_group_mac_step = kwargs.get('network_group_mac_step', '00:00:00:00:00:01')
        mac1 = kwargs.get('mac1', '00:00:00:00:00:01')
        mstep1 = kwargs.get('mstep1', 1)
        mac2 = kwargs.get('mac2', '00:00:00:00:00:01')
        mstep2 = kwargs.get('mstep2', 1)
        network_group_vlan = kwargs.get('network_group_vlan', '1001')
        network_group_vlan_step = kwargs.get('network_group_vlan_step', '0')
        vlan1 = kwargs.get('vlan1', '0')
        vstep1 = kwargs.get('vstep1', 1)
        vlan2 = kwargs.get('vlan2', '1')
        vstep2 = kwargs.get('vstep2', 1)
        try:
            import pdb
            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$')
            networkObj.Multiplier = network_count
            networkObj.MacPools.find().Mac.Custom(start_value=network_group_mac, step_value=network_group_mac_step,
                                                  increments=[(mac1, mstep1, [(mac2, mstep2, [])])])

            networkObj.MacPools.find().Vlan.find().VlanId.Custom(start_value=network_group_vlan,
                                                                 step_value=network_group_vlan_step,
                                                                 increments=[(vlan1, vstep1, [(vlan2, vstep2, [])])])
        except:
            self.log.info("%s Not in config " % network_group)
            raise IxiaOperationException("%s Not in config " % network_group)
        return True

    def create_ethernetII_interface(self, router_id=None, source_mac=None):

        """
        Creates VlanIf object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param source_mac: Mapping EthIIIf attribute - SourceMac. Example: 00:10:94:00:00:02
        :return: EthIIIf object.

        Example: create_ethernetII_interface(router_id="192.0.0.1", source_mac="00:10:94:00:00:ff")
        """
        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    EthObj = deviceGroup.Ethernet.find()
                    if not EthObj:
                        EthObj = deviceGroup.Ethernet.add()
                    else:
                        EthObj.Mac.Increment(start_value=source_mac)
                    break

        if result:
            return EthObj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_vlan_interface(self, router_id, vlan_id=None, id_step=None, vlan_priority=None):

        """
        Creates VlanIf object.
        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be
                configured.
        :param vlan_id: Mapping VlanIf attribute - VlanId. Range: 0 - 4095
        :param id_step: Mapping VlanIf attribute - IdStep.
        :param vlan_priority: Mapping VlanIf attribute - Priority. Range: 0 - 7
        :return: VlanIf object.
        Example: create_vlan_interface(router_id="192.0.0.1", vlan_id=5, id_step=1, vlan_priority=2)
        """

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                    result = True
                    deviceGroup.Ethernet.find().UseVlans = True
                    VlanObj = deviceGroup.Ethernet.find().Vlan.find()
                    VlanObj.VlanId.Increment(start_value=vlan_id, step_value=id_step)
                    VlanObj.Priority.Increment(start_value=vlan_priority)
                    break

        if result:
            return VlanObj
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def set_emulated_device_basic_attributes(self,
                                             router_id=None,
                                             device_count=None,
                                             enable_ping_response=None,
                                             router_id_step=None,
                                             ipv6_router_id=None,
                                             ipv6_router_id_step=None,
                                             emulated_device_name=None):

        """
        Sets emulated device attributes.

        :param router_id: Mandatory parameter. Router ID of emulated device to which attributes need to be configured.
        :param device_count: Mapping emulated device attribute - DeviceCount.
            Description: Number of devices in the device block.
            Type: u32
            Range: 1 - 0xFFFFFFFF
        :param enable_ping_response: Mapping emulated device attribute - EnablePingResponse.
            Description: Whether the emulated device will respond to ping.
            Type: bool
            Possible Values: TRUE - Respond to ping. FALSE - Do not respond to ping.
        :param router_id_step: Mapping emulated device attribute - RouterIdStep.
            Type: ip (Example: 0.0.0.1)
        :param ipv6_router_id: Mapping emulated device attribute - Ipv6RouterId.
            Type: ipv6 (Example: 2000::1)
        :param ipv6_router_id_step: Mapping emulated device attribute - Ipv6RouterIdStep.
            Type: ipv6 (Example: 0000::1)
        :param emulated_device_name: Mapping emulated device attribute - Name.
            Description: Emulated device name, Example: "Device 1"
        :return: True on success

        Example: set_emulated_device_basic_attributes(router_id="193.0.0.1",
                                             device_count=30,
                                             enable_ping_response=True,
                                             router_id_step="0.0.0.5",
                                             ipv6_router_id='150::0',
                                             ipv6_router_id_step=2,
                                             emulated_device_name="DG2")
        """

        result = False

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            for deviceGroup in self.ixNetwork.Topology.find().DeviceGroup.find():
                try:
                    if router_id in self.ixNetwork.Topology.find().DeviceGroup.find(
                            Name=deviceGroup.Name).RouterData.find().RouterId.Values:
                        devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=deviceGroup.Name)
                        if devicegroupObj:
                            if emulated_device_name is not None:
                                devicegroupObj.Name = emulated_device_name
                            if device_count is not None:
                                devicegroupObj.Multiplier = device_count
                            if devicegroupObj.RouterData.find():
                                devicegroupObj.RouterData.find().RouterId.Increment(step_value=router_id_step)
                            else:
                                raise IxiaConfigException(
                                    "No router data found on the given Router-ID '{}'".format(router_id))
                            result = True
                except:
                    pass
        if result:
            return True
        else:
            raise IxiaOperationException("Given Router-ID '{}' is not found in the existing config".format(router_id))

    def create_dhcp_client(self, router_id, address_family, vlan1_id=None, vlan1_step=1, vlan2_id=None, vlan2_step=1,
                           source_mac=None, dhcpv6_client_mode='iana', dhcpv6_duid_type='duid_llt'):

        """
        Creates dhcp client (IPv4, IPv6).

        :param router_id: Mandatory parameter. IXIA doesn't support IPv4 / IPv6 address format. Please input Device Group Name to which DHCP client has to be configured.
        :param address_family: IP address family of dhcp client. Possible options are IPV4|IPV6|.\
            IXIA doesn't support dual stack (IPv4v6)
        :param vlan1_id: vlan ID in case of single tagged and SVLAN (Outer VLAN), in case of QinQ.
            Parent Object: VlanIf
            Range: 0 - 4095
        :param vlan1_step: VLAN ID step value.
            Parent Object: VlanIf
        :param vlan2_id: CVLAN (Inner VLAN), in case of QinQ.
            Parent Object: VlanIf
            Range: 0 - 4095
        :param vlan2_step: VLAN ID step value.
            Parent Object: VlanIf
        :param source_mac: Mapping EthiiIf attribute - SourceMac. Source MAC address. Example: 00:10:94:00:00:02
        :param dhcpv6_client_mode: The type of client to emulate. Applicable to dhcpv6 only. possible values:
            IANA - The client emulates DHCPv6. (default)
            IATA - The client emulates DHCP PD.
            IAPD - The client emulates DHCP PD.
            IANA_IAPD - The client emulates DHCPv6 and DHCP PD.
        :param dhcpv6_duid_type: DHCPv6 unique identifier type. possible values:
            DUID_LLT    - Link-layer address plus time. (default)
            DUID_EN     - Vendor-assigned unique ID based on enterprise number.
            DUID_LL     - Link-layer address.
        :return: True on success
        Example: create_dhcp_client(router_id='DG1',
                                    address_family='ipv4',
                                    vlan1_id=2,
                                    vlan1_step=1,
                                    vlan2_id=3,
                                    vlan2_step=1,
                                    source_mac="00:10:94:00:00:02",
                                    dhcpv6_client_mode='iana',
                                    dhcpv6_duid_type='duid_llt')
        """
        result = False

        if re.match('\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format for DHCP. Please provide Device'
                                      ' Group Name')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                result = True
                if vlan1_id is None and vlan2_id or vlan1_id and vlan2_id:
                    enableVlan = True
                    TotalVlan = 2
                elif vlan1_id and vlan2_id is None:
                    enableVlan = True
                    TotalVlan = 1
                elif vlan1_id is None and vlan2_id is None:
                    enableVlan = None
                    TotalVlan = None
                vlanId = [vlan1_id, vlan2_id]
                vlanId = [0 if vId is None else vId for vId in vlanId]
                vlanStep = [vlan1_step, vlan2_step]
                EthObj = devicegroupObj.Ethernet.add(UseVlans=enableVlan, VlanCount=TotalVlan)
                EthObj.Mac.Increment(start_value=source_mac)
                if enableVlan:
                    for vlanObj, id, step in zip(EthObj.Vlan.find(), vlanId, vlanStep):
                        vlanObj.VlanId.Increment(start_value=id, step_value=step)
                if re.search('ipv4|v4', address_family.lower()):
                    dhcpObj = EthObj.Dhcpv4client.add()
                elif re.search('ipv6|v6', address_family.lower()):
                    dhcpObj = EthObj.Dhcpv6client.add()
                    dhcpObj.Dhcp6IaType.Single(dhcpv6_client_mode.lower())
                    dhcpObj.Dhcp6DuidType.Single(dhcpv6_duid_type.lower())

        if result:
            return result
        else:
            raise IxiaConfigException('No matching Device Group is found for the given name "{}"'.format(router_id))

    def set_stream_ip_count(self, stream_name, src_or_dest, ip_count, version='ipv4', **kwargs):
        """
        API to modify traffic items source and destination step count
        :param stream_name: Traffic item name Ex : "Traffic Item 1"
        :param src_or_dest: set IP count on src/dest/both EX: src
        :param ip_count: IP count to set EX: 50
        :param version: ipv4/6 EX: "ipv4"
        :param kwargs: Supported step_value parameters as optional in kwargs.
        :return: True on Success

        :Example: tgnObj.set_stream_ip_count(stream_name="Traffic Item 1",src_or_dest="src",ip_count=50,version="ipv4")
        """
        trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')
        if not trafficItemObj:
            raise IxiaConfigException("Traffic item not found")
        if trafficItemObj.TrafficType != 'raw':
            raise IxiaConfigException("Traffic type should be raw")
        if version.lower() == 'ipv4':
            version = "IPv4"
        if version.lower() == 'ipv6':
            version = "IPv6"
        if src_or_dest.lower() in ["src", "both"]:
            try:
                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(
                    DisplayName="Source Address")
                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[
                    0] if field.ValueType == 'valueList' else field.StartValue]
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \
                    , str(start_address[0]), ip_count, str(start_address[0])
                if kwargs['step_value']:
                    field.StepValue = kwargs['step_value']
            except:
                pass
        if src_or_dest.lower() in ["dest", "both"]:
            try:
                field = trafficItemObj.ConfigElement.find().Stack.find(DisplayName=version).Field.find(
                    DisplayName="Destination Address")
                start_address = [field.SingleValue if field.ValueType == 'singleValue' else field.ValueList[
                    0] if field.ValueType == 'valueList' else field.StartValue]
                field.ValueType, field.FieldValue, field.CountValue, field.StartValue = 'increment' \
                    , str(start_address[0]), ip_count, str(start_address[0])
                if kwargs['step_value']:
                    field.StepValue = kwargs['step_value']
            except:
                pass
        return True

    def get_dynamic_ip_list_device(self, router_id, protocol='ipv4'):

        """
        Returns a list of IP Address configured for a specific device

        :param router_id: Mandatory parameter. Router ID of emulated device.
        :param protocol: IP Protocol (ipv4|ipv6)

        :return: A list of ip addresses for the emulated device.
                e.g: ['10.0.0.1', '10.0.0.2', '10.0.0.3']

        :Example: get_dynamic_ip_list_device("DG1", 'ipv4')
        """
        self.log.info("Getting Dynamic IP list of the devices")
        if re.match('\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif protocol.lower() != 'ipv4' and protocol.lower() != 'ipv6':
            raise IxiaConfigException("Unsupported IP type. Please use ipv4 or ipv6")
        else:
            protocol = protocol[0].capitalize() + protocol[1:]
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                try:
                    ipObj = getattr(devicegroupObj.Ethernet.find(), protocol).find()
                    deviceIp = ipObj.Address.Values
                except:
                    raise IxiaConfigException("{0} stack doesn't exist on given device group {1}.".format(protocol, router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return deviceIp

    def set_invalid_ipv4(self, traffic_items, cfg_dict):
        """
        API used to configure invalid IPv4 headers for a given list of streams

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            src_addr (sourceAddr)
            dst_addr (destAddr)
            checksum (checksum)
            header_length (ihl)
            ttl (ttl)
            version (version)
            total_length (totalLength)
            frag_offset (fragOffset)
            options (options)
            source_routing (loosesrcroute)
            record_route (recordroute)
            timestamp (timestamp)
        :return: True on success, exception on failure
        :Example: set_invalid_ipv4(['Traffic item'], {'src_addr':'100.1.1.1', 'dst_addr':'100.1.1.2', 'checksum':64, 'header_length':10, 'ttl':64, 'total_length':8,'frag_offset':10})
        """
        self.log.info("Configuring invalid Ipv4 headers")
        for trafficItemName in traffic_items:
            trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):
                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType
            else:
                trafficType = None
                raise IxiaConfigException("Traffic stream '%s' not found on the config"%(trafficItemName))
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():
                if trafficType.lower() == 'ipv4' or trafficType.lower() == 'raw':
                    if configElement.Stack.find(DisplayName="IPv4"):
                        stackObj = configElement.Stack.find(DisplayName="IPv4")
                        if "header_length" in cfg_dict:
                            field = stackObj.Field.find(DisplayName='Header Length')
                            field.Auto, field.FieldValue, field.SingleValue = 'False', cfg_dict['header_length'], cfg_dict['header_length']
                        if "checksum" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Header checksum'), 'SingleValue', cfg_dict['checksum'])
                        if "ttl" in cfg_dict:
                            setattr(stackObj.Field.find(Name='ttl'), 'SingleValue', cfg_dict['ttl'])
                        if "version" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Version'), 'SingleValue', cfg_dict['version'])
                        if "total_length" in cfg_dict:
                            setattr(stackObj.Field.find(Name='total_len'), 'Auto', 'False')
                            setattr(stackObj.Field.find(Name='total_len'), 'SingleValue', cfg_dict['total_length'])
                        if "frag_offset" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Fragment offset'), 'SingleValue', cfg_dict['frag_offset'])
                        if "timestamp" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Timestamp'), 'SingleValue', cfg_dict['timestamp'])
                    if trafficType.lower() == 'raw':
                        if "src_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue', cfg_dict['src_addr'])
                        if "dst_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue', cfg_dict['dst_addr'])

    def set_invalid_ipv6(self, traffic_items, cfg_dict):
        """
        API used to configure invalid IPv6 headers for a given list of streams

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            src_addr (sourceAddr)
            dst_addr (destAddr)
            checksum (checksum)
            ttl (hopLimit)
            total_length (payloadLength)
        :return: True on success, exception on failure
        :Example: set_invalid_ipv6(['Traffic item 1'], {'checksum':74, 'ttl':84, 'total_length':8})
        """
        self.log.info("Configuring invalid Ipv6 headers")
        for trafficItemName in traffic_items:
            trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
            if self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$'):
                trafficType = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').TrafficType
            else:
                trafficType = None
                raise IxiaConfigException("Traffic stream '%s' not found on the config" % (trafficItemName))
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(
                    Name='^' + trafficItemName + '$').ConfigElement.find():
                if trafficType.lower() == 'ipv6' or trafficType.lower() == 'raw':
                    if configElement.Stack.find(DisplayName="IPv6"):
                        stackObj = configElement.Stack.find(DisplayName="IPv6")
                        if "checksum" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Next Header'), 'SingleValue',
                                    cfg_dict['checksum'])
                        if "ttl" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Hop Limit'), 'SingleValue', cfg_dict['ttl'])
                        if "total_length" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'Auto', 'False')
                            setattr(stackObj.Field.find(DisplayName='Payload Length'), 'SingleValue', cfg_dict['total_length'])
                    if trafficType.lower() == 'raw':
                        if "src_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Source Address'), 'SingleValue',
                                    cfg_dict['src_addr'])
                        if "dst_addr" in cfg_dict:
                            setattr(stackObj.Field.find(DisplayName='Destination Address'), 'SingleValue',
                                    cfg_dict['dst_addr'])

    def change_mld_source_list(self, device_list=None, mld_source_list=None, port_list=None):
        """
        Modify MLD source Address
        :param device_list: Device group name
        :param mld_source_list: Mld source address
        :param port_list: Ports
        :return: True else raise exception
        :Example: change_mld_source_list(device_list=["DG1"],mld_source_list=["100::101:1","200::200:2","300::300:3"], port_list=["Port1","Port2"])
        """
        result = False
        if mld_source_list:
            sourceRange = len(mld_source_list)
        else:
            sourceRange = 1
        if port_list:
            for portName in port_list:
                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):
                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')
                    for topoObj in self.ixNetwork.Topology.find():
                        if vportObj.href in topoObj.Ports:
                            portIndex = (topoObj.Ports).index(vportObj.href)
                            if device_list and mld_source_list:
                                for deviceGroupName in device_list:
                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')
                                        if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                            for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                                mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                                                sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
                                                indexList = []
                                                for srcRange in range(0, sourceRange):
                                                    indexList.append(portIndex)
                                                    portIndex += 1
                                                for ipIndex,sourceIp in zip(indexList,mld_source_list):
                                                    sourceListValues[ipIndex] = sourceIp
                                                    mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                    else:
                                        log.info("The deviceGroup '%s' not configured under this port '%s'"%(deviceGroupName,portName))
                                result = True
                            elif device_list is None and mld_source_list:
                                for deviceGroupObj in topoObj.DeviceGroup.find():
                                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                                            sourceListValues = mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Values
                                            indexList = []
                                            for srcRange in range(0, sourceRange):
                                                indexList.append(portIndex)
                                                portIndex += 1
                                            for ipIndex, sourceIp in zip(indexList, mld_source_list):
                                                sourceListValues[ipIndex] = sourceIp
                                            mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                        result = True
                            else:
                                raise IxiaConfigException("Failed due to device_list/mld_source_list parameter not passed")
        if device_list and port_list is None:
            for deviceGroupName in device_list:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')
                    if deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                        for mldHostObj in deviceGroupObj.Ethernet.find().Ipv6.find().MldHost.find():
                            mldHostObj.MldMcastIPv6GroupList.NoOfSrcRanges = sourceRange
                            mldHostObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.ValueList(values=mld_source_list)
                        result = True
                else:
                    log.info("The deviceGroup '%s' not configured" %deviceGroupName)
        if result:
            return result
        else:
            raise IxiaConfigException("Failed to update MLD source Ip, Check Port List %s and Device Group %s configured on Ixia config"%(port_list,device_list))

    def change_igmp_source_list(self, device_list=None, igmp_source_list=None, port_list=None):
        """
        Modify IGMP source Address
        :param device_list: Device group name
        :param igmp_source_list: Igmp source address
        :param port_list: Ports
        :return: True else raise exception
        :Example: change_igmp_source_list(device_list=["DG1"],igmp_source_list=["1.1.1.1","2.2.2.2","3.3.3.3"], port_list=["Port1","Port2"])
        """
        result = False
        if igmp_source_list:
            sourceRange = len(igmp_source_list)
        else:
            sourceRange = 1
        if port_list:
            for portName in port_list:
                if self.ixNetwork.Vport.find(Name='^' + portName + '$'):
                    vportObj = self.ixNetwork.Vport.find(Name='^' + portName + '$')
                    for topoObj in self.ixNetwork.Topology.find():
                        if vportObj.href in topoObj.Ports:
                            portIndex = (topoObj.Ports).index(vportObj.href)
                            if device_list and igmp_source_list:
                                for deviceGroupName in device_list:
                                    if topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                                        deviceGroupObj = topoObj.DeviceGroup.find(Name='^' + deviceGroupName + '$')
                                        if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                            for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                                igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                                                sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
                                                indexList = []
                                                for srcRange in range(0, sourceRange):
                                                    indexList.append(portIndex)
                                                    portIndex += 1
                                                for ipIndex,sourceIp in zip(indexList,igmp_source_list):
                                                    sourceListValues[ipIndex] = sourceIp
                                                igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                    else:
                                        log.info("The deviceGroup '%s' not configured under this port '%s'"%(deviceGroupName,portName))
                                result = True
                            elif device_list is None and igmp_source_list:
                                for deviceGroupObj in topoObj.DeviceGroup.find():
                                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                                            sourceListValues = igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Values
                                            indexList = []
                                            for srcRange in range(0, sourceRange):
                                                indexList.append(portIndex)
                                                portIndex += 1
                                            for ipIndex, sourceIp in zip(indexList, igmp_source_list):
                                                sourceListValues[ipIndex] = sourceIp
                                            igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=sourceListValues)
                                        result = True
                            else:
                                raise IxiaConfigException("Failed due to device_list/igmp_source_list parameter not passed")
        if device_list and port_list is None:
            for deviceGroupName in device_list:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$'):
                    deviceGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + deviceGroupName + '$')
                    if deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                        for igmpHostObj in deviceGroupObj.Ethernet.find().Ipv4.find().IgmpHost.find():
                            igmpHostObj.IgmpMcastIPv4GroupList.NoOfSrcRanges = sourceRange
                            igmpHostObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.ValueList(values=igmp_source_list)
                        result = True
                else:
                    log.info("The deviceGroup '%s' not configured" %deviceGroupName)
        if result:
            return result
        else:
            raise IxiaConfigException("Failed to update Igmp source Ip, Check Port List %s and Device Group %s configured on Ixia config"%(port_list,device_list))

    def get_ipv4_tos(self, traffic_item_list=None):
        """
        Get IP priority set on traffic items
        :param traffic_item_list: List of traffic items to fetch IP priority

        :return: Dict of IP Priority configured in traffic item
                 Raise exception if traffic item not found

        :Example: get_ipv4_tos(traffic_item_list = ['Traffic Item 1','Traffic Item 2'])
        """
        self.log.info("Checking Ipv4 TOS information is available in TrafficItem")
        result = dict()
        tosDict = {'000 Routine': '00', '001 Priority': '20', '010 Immediate': '40', '011 Flash': '60', '100 Flash Override': '80', '101 CRITIC/ECP': 'A0', '110 Internetwork Control': 'C0', '111 Network Control': 'E0'}
        classPHB = {'Precedence 1':'20', 'Precedence 2':'40', 'Precedence 3':'60', 'Precedence 4':'80', 'Precedence 5':'A0', 'Precedence 6':'C0', 'Precedence 7':'E0'}
        if traffic_item_list == None:
            traffic_item_list = [trafficObj.Name for trafficObj in self.ixNetwork.Traffic.TrafficItem.find()]
        for trafficItemName in traffic_item_list:
            trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$').ConfigElement.find():
                for count, stackObj in enumerate(configElement.Stack.find(DisplayName="IPv4"),start=1):
                    if count == 1:
                        key = 'Outer'
                    if count == 2:
                        key = 'Inner'
                    if stackObj.Field.find(DisplayName="Precedence").ActiveFieldChoice == True:
                        key = key+'TOS'
                        try:
                            result.setdefault(trafficItemName, [] ).append({key:tosDict[stackObj.Field.find(DisplayName="Precedence").FieldValue]})
                        except:
                            pass
                    if stackObj.Field.find(DisplayName="Class selector PHB").ActiveFieldChoice == True:
                        key = key + 'Diff-serv'
                        try:
                            result.setdefault(trafficItemName, []).append({key: classPHB[stackObj.Field.find(DisplayName="Class selector PHB").FieldValue]})
                        except:
                            pass
                    if stackObj.Field.find(DisplayName="Raw priority").ActiveFieldChoice == True:
                        key = key + 'Raw Priority'
                        try:
                            result.setdefault(trafficItemName, []).append({key: stackObj.Field.find(DisplayName="Raw priority").FieldValue})
                        except:
                            pass
        return result

    def config_device_twamp_client(self, router_id, ip_version='ipv4', add_test_session=True, **kwargs):

        """
        Configure TWAMP Client on device

        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.
        :param ip_version: IPV4 or IPV6.
        :param add_test_session: Add TWAMP Test Session by default and if TwampControlRange has to be configured then the attribute 'Count' is mandatory.
        :param kwargs: Supported parameters as optional in kwargs with default values.
        :return: TWAMP Client handle if configured else raise an exception.
        Example:config_device_twamp_client(router_id= 'IP-4', ip_version='ipv4', add_test_session=True, ControlStartServerIp = '20.1.1.1', Count= 1)
        """

        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',
                      'ErrorEstimateMultiplier']
        controlArg = ['ControlServerIpIncrement', 'ControlServerPort', 'ControlStartServerIp', 'Count', 'Enabled',
                      'KeyId', 'Mode', 'ControlServerName', 'Secret']
        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',
                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',
                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',
                          'TypepDescriptor']

        userArg = {key.lower(): value for key, value in kwargs.items()}
        configOptions = {}
        configControl = {}
        configTestSession = {}

        for ixnArg in optionsArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configOptions[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in controlArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'ControlServerName'.lower():
                    configControl['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configControl[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in testSessionArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'TestSessionName'.lower():
                    configTestSession['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).TwampClient.add()
                    self.ixNetwork.Vport.find().ProtocolStack.TwampOptions.add(**configOptions)
                    if add_test_session:
                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                            Name=router_id).Range.add().TwampControlRange.add(**configControl)
                        self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                            Name=router_id).Range.add().TwampTestRange.add(**configTestSession)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def config_device_twamp_server(self, router_id, ip_version='ipv4', **kwargs):

        """
        Configure TWAMP Client on device

        :param router_id: Ixia Supports only Device Name on which TWAMP client have to configured.
        :param ip_version: IPV4 or IPV6.
        :param kwargs: Supported parameters as optional in kwargs with default values. 'Count & ReflectorPort' is mandatory.
        :return: TWAMP Client handle if configured else raise an exception.
        Example:config_device_twamp_server(router_id='IP-5', ip_version='ipv4', ControlPort = 2000, Count= 1, ReflectorPort = 13000)
        """

        serverArg = ['ControlPort', 'Count', 'EnableAccessControl', 'Enabled', 'IterationCount', 'KeyId',
                     'MaxTestSessions', 'Mode', 'Name', 'PermittedIp', 'PermittedIpIncrement', 'PermittedSenderPort',
                     'ReflectorPort', 'Secret']
        userArg = {key.lower(): value for key, value in kwargs.items()}
        configServer = {}

        for ixnArg in serverArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configServer[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    return self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).Range.add().TwampServerRange.add(**configServer)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def get_stream_name(self, stream_handle):
        """
        The function returns the Name of the traffic handle
        :param stream_handle: Traffic stream handle
        :return: Name of the traffic stream.
        Example: get_stream_name(stream_handle = 'TrafficItemObj')
        """
        return stream_handle.Name

    def get_twamp_peer_ip(self, router_id=None):
        """
        To fetch TWAMP peer IP and device IP of each TWAMP device in a dictonary.

        :param router_id: TWAMP Client Router ID of which Peer IP and device IP details are fetched.
        :return: Dictonary of TWAMP Client Router ID to device and peer IP of TWAMP Client.
        Example: get_twamp_peer_ip(router_id = 'TWAMPControl-R9')
        """
        twamp_peer_ip_dict = dict()
        if not router_id:
            device_list = []
            control_list = []
            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                controlObj = RangeObj.TwampControlRange.find()
                try:
                    device_list.append(RangeObj.IpRange)
                    control_list.append(controlObj)
                except:
                    pass
        else:
            device_list = []
            control_list = []
            for RangeObj in self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find().Range.find():
                controlObj = RangeObj.TwampControlRange.find()
                try:
                    if controlObj.Name == router_id:
                        device_list.append(RangeObj.IpRange)
                        control_list.append(controlObj)
                        break
                except:
                    pass
        if not device_list:
            if router_id:
                raise CafyException.InvalidValueError('%s no such device' % router_id)
            else:
                raise CafyException.InvalidValueError('No devices in configuration')
        for index in range(len(device_list)):
            try:
                twamp_peer_ip_dict[control_list[index].Name] = {}
                twamp_peer_ip_dict[control_list[index].Name]['Device IP'] = device_list[index].IpAddress
                twamp_peer_ip_dict[control_list[index].Name]['Peer IP'] = device_list[index].GatewayAddress
            except:
                pass
        return twamp_peer_ip_dict

    def get_mac_from_captured_packets(self, pcap_filename=None, pkt_mode="random", pkt_num=None,
                                      random_check_till_ip=5):
        """
        Used to fetch source and destination MAC from the captured packet file.
        :param pcap_filename: Pcap file name with location.
        :param pkt_mode: options are "random" and "fixed", default: "random" .
                         If set "random" - one randome packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,
                            if the packet is IP packet, returns source and destination MAC.
                            if the packet is ARP packet, another random packet is picked and process repeats for "random_check_till_ip" number of times.
                         If set "fixed" - packet with packet number="pkt_num" is used to fetch src and dst mac.
        :param pkt_num: packet with packet number="pkt_num" is used to fetch src and dst mac. Only when pkt_mode is "fixed"
        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.
        Example: get_mac_from_captured_packets(pcap_filename='sampledata1.pcap', pkt_mode="random", pkt_num=None, random_check_till_ip=5)
        """
        ret_mac = {}
        packets = []
        if pcap_filename:
            for ts, pkt in dpkt.pcap.Reader(open(pcap_filename, 'rb')):
                packets.append(pkt)
            if pkt_mode.lower() == "random":
                for count in range(random_check_till_ip):
                    log.info("try: %d" % count)
                    pkt_num = random.randrange(1, len(packets))
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    if isinstance(eth.data, dpkt.ip.IP):
                        ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)
                        ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)
                        break
                else:
                    raise CafyException.TgenInvalidInputError(
                        'No IP packet found after %s tries' % random_check_till_ip)
            elif pkt_mode.lower() == "fixed":
                if pkt_num:
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    if not isinstance(eth.data, dpkt.ip.IP):
                        raise CafyException.TgenInvalidInputError('\'pkt_num\' %s is not an IP packet' % pkt_num)
                    else:
                        ret_mac['src_mac'] = ':'.join(f'{x:02x}' for x in eth.src)
                        ret_mac['dst_mac'] = ':'.join(f'{x:02x}' for x in eth.dst)
                else:
                    raise CafyException.TgenInvalidInputError('\'pkt_num\' is must for pkt_mode = fixed')
        else:
            raise CafyException.TgenInvalidInputError('\'pcap_filename\' is a mandatory parameter.')

        return ret_mac

    def get_card_type(self, port):
        """
        To fetch card type using port name.

        :param port: Name/location of the port, whose card type is required.
        :return: Card type. Ex: "FX2-40G-Q2"

        :Example: get_card_type("7/5")
                  get_card_type("10.10.1.1/5/1")
        """
        port = port.split("/")
        port[0] = port[1] if len(port) > 2 else port[0]
        if self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$'):
            cardObj = self.ixNetwork.AvailableHardware.Chassis.find().Card.find(CardId='^' + port[0] + '$')
            if cardObj.Port.find(PortId='^' + port[1] + '$'):
                card_type = cardObj.Description
            else:
                self.log.error('%s not a valid port name or location' % port[1])
                card_type = None
        return card_type

    def set_invalid_mpls(self, traffic_items, cfg_dict):
        """
        API used to configure invalid mpls headers for a given list of streams
        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
            All values below should be strings:
                label (label) - Label identifier to be used [0 - 1048575]
                sbit (sBit) - Last label for a given stack [0/1]
                exp (exp) - Experimental bits value [0 - 7]
                ttl (ttl) - Time to live value  [0 - 255]
                active (Active) - Sets the mpls status to active (true/false)
        :return: True on success, exception on failure
        :Example: set_invalid_mpls(['Traffic ipv4'], {'label':'111', 'sbit':'1', 'exp':7, 'ttl':84, 'active':True})
        """
        result = False
        self.log.info("Setting INVALID MPLS Headers in Traffic Item/Items")
        if type(traffic_items) is list and type(cfg_dict) is dict:
            for trafficName in traffic_items:
                try:
                    for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name=trafficName).ConfigElement.find():
                        for mplsObj in configElement.Stack.find(StackTypeId='mpls'):
                            labelObj, expObj, sbitObj, ttlObj = mplsObj.Field.find(
                                Name='mpls_label_value'), mplsObj.Field.find(Name='mpls_exp'), mplsObj.Field.find(
                                Name='mpls_bos'), mplsObj.Field.find(Name='mpls_ttl')
                            labelObj.SingleValue = cfg_dict['label'] if 'label' in cfg_dict.keys() else None
                            expObj.SingleValue = cfg_dict['exp'] if 'exp' in cfg_dict.keys() else None
                            sbitObj.SingleValue = cfg_dict['sbit'] if 'sbit' in cfg_dict.keys() else None
                            ttlObj.SingleValue = cfg_dict['ttl'] if 'ttl' in cfg_dict.keys() else None
                            result = True
                except:
                    pass
        else:
            raise IxiaOperationException(
                'Given object types of traffic_items {}, cfg_dict {} is not supported. Supported object types are traffic_items should be list and cfg_dict should be dict'.format(
                    type(traffic_items), type(cfg_dict)))
        if result:
            return result
        else:
            raise IxiaConfigException('Either Streams or MPLS headers is not present')

    def set_rsvp_tunnel(self, tunnel_type, router_id=None, **kwargs):
        """
        Set RSVP tunnel attributes
        :param router_id: Router ID of the device
        :param tunnel_type: Ingress/Egress
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                tunnel_name: tunnel name from config
                source_ip_address: IP address of the RSVP PATH message sender
                source_ip_address_step: Source IP address step
                destination_ip_address: Destination IP address of the RSVP PATH message
                destination_ip_address_step: Destination IP address step
                tunnel_count: Integer/String representing the new tunnel count
                tunnel_id: tunnel identifier
                tunnel_id_step: Tunnel ID step for incrementing Tunnel ID when TunnelCount is greater than one
                lsp_count: Number of LSPs established within the tunnel. Lsp Count should be between 1 and 20
                lsp_id: LSP ID
                lsp_id_step: LSP ID step
        :return: True if successfull else raises exception
        :Example: set_rsvp_tunnel(router_id="192.0.0.1",tunnel_type="Ingress",tunnel_name="RSVP Tunnel",source_ip_address="10.10.10.1",source_ip_address_step="0.0.0.1",destination_ip_address="11.11.11.1",
                       destination_ip_address_step="0.0.0.1",tunnel_count=2,tunnel_id=11,tunnel_id_step=2,lsp_count=2,lsp_id=1,lsp_id_step=2)
        """
        tunnelName = kwargs.get('tunnel_name')
        deviceObjDict = {}
        result = False
        if router_id:
            for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                if deviceGroupObj.RouterData.find():
                    if router_id in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceObjDict[router_id] = deviceGroupObj
                    break
        else:
            try:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    for ipv4Obj in deviceGroupObj.Ethernet.find().Ipv4.find():
                        if ipv4Obj.RsvpteLsps.find():
                            deviceObjDict[deviceGroupObj.Name] = deviceGroupObj
            except:
                pass
        if deviceObjDict:
            if tunnel_type.lower() == "ingress":
                for key, deviceObj in deviceObjDict.items():
                    for rsvpIfObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():
                        rsvpIfObj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),
                                                  step_value=kwargs.get('destination_ip_address_step', None))
                    for rsvpTeObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        rsvpTeObj.Name = tunnelName
                        if rsvpTeObj.RsvpP2mpIngressLsps and rsvpTeObj.RsvpP2mpEgressLsps:
                            rsvpTeObj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', None)
                            rsvpTeObj.P2mpIngressLspCount = kwargs.get('lsp_count', None)
                            rsvpTeObj.RsvpP2mpIngressLsps.SourceIpv4.Increment(
                                start_value=kwargs.get('source_ip_address', None),
                                step_value=kwargs.get('source_ip_address_step', None))
                            rsvpTeObj.RsvpP2mpIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', None),
                                                                             step_value=kwargs.get('tunnel_id_step',
                                                                                                   None))
                            rsvpTeObj.RsvpP2mpIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', None),
                                                                          step_value=kwargs.get('lsp_id_step', None))
                            result = True
                        if rsvpTeObj.RsvpP2PIngressLsps and rsvpTeObj.RsvpP2PEgressLsps:
                            rsvpTeObj.IngressP2PLsps = kwargs.get('lsp_count', None)
                            rsvpTeObj.RsvpP2PIngressLsps.SourceIp.Increment(
                                start_value=kwargs.get('source_ip_address', None),
                                step_value=kwargs.get('source_ip_address_step', None))
                            rsvpTeObj.RsvpP2PIngressLsps.TunnelId.Increment(start_value=kwargs.get('tunnel_id', None),
                                                                            step_value=kwargs.get('tunnel_id_step',
                                                                                                  None))
                            rsvpTeObj.RsvpP2PIngressLsps.LspId.Increment(start_value=kwargs.get('lsp_id', None),
                                                                         step_value=kwargs.get('lsp_id_step', None))
                            result = True
            elif tunnel_type.lower() == "egress":
                for key, deviceObj in deviceObjDict.items():
                    for rsvpIfObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteIf.find():
                        rsvpIfObj.DutIp.Increment(start_value=kwargs.get('destination_ip_address', None),
                                                  step_value=kwargs.get('destination_ip_address_step', None))
                    for rsvpTeObj in deviceObj.Ethernet.find().Ipv4.find().RsvpteLsps.find():
                        rsvpTeObj.Name = tunnelName
                        if rsvpTeObj.RsvpP2mpEgressLsps:
                            rsvpTeObj.P2mpEgressTunnelCount = kwargs.get('tunnel_count', None)
                        result = True
            else:
                raise IxiaConfigException("Passed '%s' invalid Tunnel Type" % tunnel_type)
        else:
            raise IxiaConfigException('Device with Router ID %s not available in the config' % router_id)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return result

    def config_twamp_test_session(self, router_id=None, twamp_client_handle=None, **kwargs):
        """
        Configure or Create a Test session either with TWAMP client device or its config handle
        One of the argument is mandatory
        :param router_id: TWAMP Client device's router id
        :param twamp_client_handle: TWAMP config handler in Client device
        :return: Raises exception on failure
        Example:config_twamp_test_session('IP-6', twamp_client_handle=None,
                                        TestSessionName = 'TWAMPTest-R15', ControlRangeName= 'TWAMPControl-R10',
                                        TestSessionsCount= 1, SessionSenderPort= 2000,
                                        SessionSenderPortIncrement= 1, SessionReflectorPort=4000,
                                        SessionReflectorPortIncrement= 1,
                                        NumberOfPackets=10, PacketsPerSecond=10, Timeout=30, PacketLength= 128,
                                        PaddingWithZero= False,
                                        TypepDescriptor= 0
                                        )
        """
        optionsArg = ['SetupRate', 'TeardownRate', 'MaxOutstanding', 'SessionTimeout', 'ErrorEstimateScale',
                      'ErrorEstimateMultiplier']
        testSessionArg = ['TestSessionName', 'ControlRangeName', 'TestSessionsCount', 'SessionSenderPort',
                          'SessionSenderPortIncrement', 'SessionReflectorPort', 'SessionReflectorPortIncrement',
                          'NumberOfPackets', 'PacketsPerSecond', 'Timeout', 'PacketLength', 'PaddingWithZero',
                          'TypepDescriptor']

        userArg = {key.lower(): value for key, value in kwargs.items()}
        configOptions = {}
        configControl = {}
        configTestSession = {}

        for ixnArg in optionsArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                configOptions[ixnArg] = userArg.pop(ixnArg.lower())

        for ixnArg in testSessionArg:
            if re.search(ixnArg, str(userArg), re.IGNORECASE):
                if ixnArg.lower() == 'TestSessionName'.lower():
                    configTestSession['Name'] = userArg.pop(ixnArg.lower())
                else:
                    configTestSession[ixnArg] = userArg.pop(ixnArg.lower())

        if router_id == None:
            raise CafyException.TgenInvalidInputError('router_id is a mandatory parameter.')
        else:
            try:
                if self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(Name=router_id):
                    self.ixNetwork.Vport.find().ProtocolStack.Ethernet.find().IpEndpoint.find(
                        Name=router_id).Range.add().TwampTestRange.add(**configTestSession)
                else:
                    return IxiaOperationException(
                        "Given Router-ID '{}' is not found in the existing config".format(router_id))
            except:
                pass

    def set_protocol_stack_count(self, stack_count, device_name, ip_type="ipv4", **kwargs):
        """
        Modifying stack multiplier count for protocol stack.

        :param stack_count: Integer/String representing stack multiplier
        :param device_name: String devices name for whc stack multiplier need to be set
        :param ip_type: String demonstrating the IP version ipv4/ipv6
        :param kwargs:
                nested_device : if nested device, Need to pass nested_device = True
        :return: True if the operation is successful, False otherwise

        :Example: set_protocol_stack_count(stack_count=10, device_name='Device Group 1')
                  set_protocol_stack_count(stack_count=10, device_name='Device Group 1', nested_device=True)
        """
        self.log.info("Setting Stack Count for Device Group:%s" % (device_name))
        nested_device = kwargs.get('nested_device', False)
        if stack_count >= 1:
            if nested_device:
                if self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                        Name='^' + device_name + '$'):
                    if ip_type.lower() == "ipv4":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ipv4Loopback.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            else:
                if self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'):
                    if ip_type.lower() == "ipv4":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpVrf.find().Multiplier = stack_count
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            self.ixNetwork.Topology.find().DeviceGroup.find(
                                Name='^' + device_name + '$').Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            pass
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
        else:
            raise CafyException.InvalidValueError('Stack count (%s) has to be greater than or equal to 1' % stack_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def _dhcp_action_control(self, router_id, command_action, type):
        """
        internal function to perform dhcpv4/v6 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4/v6 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :param type: Perform on DHCPv4 or DHCPv6 client
        :return: True on success.
        """
        if re.match('\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format for DHCP. Please provide Device Group Name')
        elif command_action not in ['start', 'stop', 'rebind', 'renew', 'abort', 'restartDown']:
            raise IxiaConfigException('Only the following commands "start/stop/restartDown/renew/rebind/abort" can be '' performed on DHCP client.')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                try:
                    command_action = command_action[0].capitalize() + command_action[1:]
                    dhcpv4Obj = getattr(devicegroupObj.Ethernet.find(), type).find()
                    getattr(dhcpv4Obj, command_action)()
                    result = True
                except:
                    raise IxiaConfigException('"{}" is not configured in the given device group "{}"'.format(type, router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return result

    def perform_dhcpv6_command(self, router_id, command_action):
        """
        Performs dhcpv6 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv6 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :return: True on success.

        :Example: perform_dhcpv6_command("DHCPv6 Client", "stop")
                  perform_dhcpv6_command("DHCPv6 Client", "start")
        """
        return self._dhcp_action_control(router_id, command_action, "Dhcpv6client")

    def perform_dhcpv4_command(self, router_id, command_action):
        """
        Performs dhcpv4 commands.
        :param router_id: Mandatory parameter. This argument holds the 'Name' of the 'DeviceGroup' in which DHCPv4 client is configured.
        :param command_action: Mandatory parameter. desired command action.
            Possible choices: start/stop/restartdown/renew/rebind.
        :return: True on success.

        :Example: perform_dhcpv4_command("DHCPv4 Client", "stop")
                  perform_dhcpv4_command("DHCPv4 Client", "start")
        """
        return self._dhcp_action_control(router_id, command_action, "Dhcpv4client")

    def modify_isis_hello_padding(self, port_list, action='enable'):
        """
        To modify the hello padding settings of isis enabled devices.
        :param port_list: List of port names, whose isis devices needs modification.
        :param action: To enable or disable hello padding. Default: enable.
        :return True on success else raise exception.

        :Example: modify_isis_hello_padding(["Ethernet - 001"])
                  modify_isis_hello_padding(["Ethernet - 001"],'disable')
        """
        sup_dict = {'enable':True,'disable':False}
        if not isinstance(port_list, list):
            port_list = [port_list]
        portNameList = []
        for vport in self.ixNetwork.Vport.find():
            if vport.AssignedTo.replace(":", "/") in port_list or vport.Name in port_list:
                portNameList.append(vport.Name)
        for portName in portNameList:
            for topology in self.ixNetwork.Topology.find():
                if topology.Vports[0] == self.ixNetwork.Vport.find(Name=portName).href:
                    for device in topology.DeviceGroup.find():
                        if device.IsisL3Router.find():
                            device.IsisL3Router.find().EnableHelloPadding.Single(sup_dict[action])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def perform_pppoe_action(self, router_id, action, address_family="dual_stack"):

        """
        The API retries to connect to PPPoX sessions
        :param router_id: router id of emulated device
        :param action: action to perform options: start|stop|RestartDown|openipcp|CloseIpcp|OpenIpv6cp|CloseIpv6cp
        :param address_family: IpCp mode ipv4/ipv6/dual_stack
        :return: True on success.

        :Example: perform_pppoe_action("DG2", "start", 'dual_stack')
                 perform_pppoe_action("DG2", "stop", 'dual_stack')
        """

        result = False
        if re.match('\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}', router_id):
            raise IxiaConfigException('IXIA doesn"t support IP v4/v6 address format. Please provide Device Group Name')
        elif action.lower() not in ['start', 'stop', 'restartdown', 'connect', 'disconnect', 'retry', 'openipcp',
                                    'closeipcp', 'openipv6cp', 'closeipv6cp']:
            raise IxiaOperationException('IXIA supports only the following commands "Start|Stop|RestartDown|openipcp|'
                                         'CloseIpcp|OpenIpv6cp|CloseIpv6cp" on PPPoE client.')
        else:
            devicegroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + router_id + '$')
            if devicegroupObj:
                pppoxObj = devicegroupObj.Ethernet.find().Pppoxclient.find()
                if pppoxObj:
                    ncpType = pppoxObj.NcpType.Values
                    if re.fullmatch(ncpType[0], address_family, re.IGNORECASE):
                        if re.fullmatch('start|connect', action, re.IGNORECASE):
                            pppoxObj.Start()
                            result = True
                        if re.fullmatch('stop|disconnect', action, re.IGNORECASE):
                            pppoxObj.Stop()
                            result = True
                        if re.fullmatch('restartdown|retry', action, re.IGNORECASE):
                            pppoxObj.RestartDown()
                            result = True
                        if ncpType[0].lower() == 'dual_stack' and action.lower() in ['openipcp', 'closeipcp', 'openipv6cp', 'closeipv6cp']:
                            if re.fullmatch('openipcp', action, re.IGNORECASE):
                                pppoxObj.OpenIpcp()
                                result = True
                            if re.fullmatch('closeipcp', action, re.IGNORECASE):
                                pppoxObj.CloseIpcp()
                                result = True
                            if re.fullmatch('openipv6cp', action, re.IGNORECASE):
                                pppoxObj.OpenIpv6cp()
                                result = True
                            if re.fullmatch('closeipv6cp', action, re.IGNORECASE):
                                pppoxObj.CloseIpv6cp()
                                result = True
                    else:
                        raise IxiaConfigException('PPPoE client is configured with "{}" NCP Type. Please change '
                                                  'address_family value and call the API'.format(ncpType[0]))
                else:
                    raise IxiaConfigException('PppoxClient is not configured in the given device group "{}"'.format(router_id))
            else:
                raise IxiaConfigException('Given device group "{}" doesn"t exist.'.format(router_id))
        return result

    def generate_license_details(self, chassis_ip, username='admin', password='admin', license_feature=None):
        """
        API used to retrieve license details based on Ixia chassis
        :param chassis_ip: String , IXIA Chassis IP address
        :param username: Username of the Ixia Chassis
        :param password: Password of the Ixia Chassis
        :param license_feature: String , name of the License feature .
                        Ex: 'VM-IXN-TIER1','VM-IXN-TIER2','VM-PORT-TIER-1GBPS','VM-TIER-FRAMEWORK','VM-TIER-IxSERVER'
        :return : License details of the chassis IP

        Example: generate_license_details(chassis_ip='10.85.99.38',username='admin',password='roZes!23')
        """
        USERNAME_PASSWORD = {'username': username, 'password': password}

        # ---------- PERMITTED CONFIGURATION ENDS HERE ---------- #
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        JSON_USERNAME_PASS = json.dumps(USERNAME_PASSWORD)

        AUTH_KEY_CALL = "https://{IP}/api/v1/auth/session"
        AUTH_KEY_ADDRESS = (AUTH_KEY_CALL.format(IP=chassis_ip))

        PAYLOAD = JSON_USERNAME_PASS
        HEADER = {
            'content-type': "application/json"
        }

        API_response = requests.request("POST", AUTH_KEY_ADDRESS, data=PAYLOAD, headers=HEADER, verify=False)

        # parse API_response:
        API_JSON = json.loads(API_response.text)
        # create the apiKey variable
        API_KEY = (API_JSON["apiKey"])

        HEADERS = {
            'x-api-key': API_KEY,
            'content-type': "application/json"
        }

        license_retrieval_call = "https://{IP}/platform/api/v2/licensing/servers/1/operations/retrievecountedfeaturestats"
        license_retrieval_url = (license_retrieval_call.format(IP=chassis_ip))

        license_retrieval_response = requests.request("POST", license_retrieval_url, headers=HEADERS, verify=False)

        id_json = json.loads(license_retrieval_response.text)

        # create a variable for the license session id
        license_id = (id_json["id"])
        time.sleep(1)

        license_list_call = "https://{IP}/platform/api/v2/licensing/servers/1/operations/retrievecountedfeaturestats/{ID}/result"
        license_list_url = (license_list_call.format(IP=chassis_ip, ID=license_id))

        license_list_response = requests.request("GET", license_list_url, headers=HEADERS, verify=False)

        if license_feature:
            for licenses in license_list_response.json():
                if license_feature in licenses.values():
                    log.info(f'Showing license count for {chassis_ip} and featureName {license_feature}.\n {licenses}')
                    return licenses
            log.warning("License Feature Name given: '%s' is not available" % license_feature)
            return False
        log.info(f'Showing license count for {chassis_ip}.\n {license_list_response.text}')
        return license_list_response.json()

    def set_filtered_stream_results(self, port, protocol):
        """
        This api created custom traffic view stats named "ECN" to capture eggress tracking of active traffic items
        :param port: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"
        :param protocol: ipv4 or ipv6, based on which filter to apply is selected

        Example: set_filtered_stream_results(port="10.10.10.1/1/5",protocol = 'ipv4')
                 set_filtered_stream_results(port="10.10.10.1/1/6",protocol = 'ipv6')
        """
        streamList = self.get_active_streams()
        trafficList = list()
        for stream in streamList:
            for configElement in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream + '$').ConfigElement.find():
                if protocol.lower() == "ipv4":
                    if configElement.Stack.find(DisplayName="IPv4"):
                        trafficList.append(stream)
                else:
                    if configElement.Stack.find(DisplayName="IPv6"):
                        trafficList.append(stream)

        self.disable_traffic_item()
        self.enable_traffic_item(trafficList)

        if self.ixNetwork.Traffic.State in ['stopped','stoppedWaitingForStats','unapplied']:
            self.regenerate_traffic()
            self._apply_traffic()

        if self.ixNetwork.Statistics.View.find(Caption="ECN"):
            self.ixNetwork.Statistics.View.find(Caption="ECN").remove()
        self.ixNetwork.Statistics.View.add(Caption="ECN", Type='layer23TrafficFlow', Visible=True, TreeViewNodeName="Views\\Custom Views")
        afil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailableTrafficItemFilter.find()
        fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Layer23TrafficFlowFilter.find()
        port_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailablePortFilter.find()
        fil.update(AggregatedAcrossPorts=False, EgressLatencyBinDisplayOption="showEgressRows", PortFilterIds=port_fil,
                   TrafficItemFilterIds=afil)
        traffic_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Layer23TrafficFlowFilter.find()
        tracking_fil = self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').AvailableTrackingFilter.find()
        tracking_fil_list = list()
        for i in range(0,2):
            tracking_fil_list.append(tracking_fil[i].href)
        enum = traffic_fil.EnumerationFilter
        for elem in tracking_fil_list:
            enum.add(SortDirection=None, TrackingFilterId=elem)
        for stats in self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Statistic.find():
            stats.Enabled = True
        self.ixNetwork.Statistics.View.find(Caption='^' + "ECN" + '$').Enabled = True

    def disable_filter_stream(self, port):
        """
        This api removes the custom traffic view stats named "ECN"
        :param port: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"

        Example: disable_filter_stream(port="10.10.10.1/1/5")
                 disable_filter_stream(port="10.10.10.1/1/6")
        """
        self.log.info(" Disabling tracking on traffic items ")
        if self.ixNetwork.Statistics.View.find(Caption="ECN"):
            self.ixNetwork.Statistics.View.find(Caption="ECN").remove()

    def get_filtered_stream_results(self, port_number):
        """
        Returns the traffic stats from custom traffic stats view named "ECN" which has egress tracking and traffic class tracking
        :param port_number: str RX port Ex : "chassis/card/port" "10.10.10.1/1/5"
        :return: Dictionary of filtered stream data

        Example: get_filtered_stream_results(port_number="10.10.10.1/1/5")
                get_filtered_stream_results(port_number="10.10.10.1/1/5")
        """
        streamList = self.get_active_streams()
        rxPort = self.get_port_name_from_location(port_number)
        filteredResult = {}
        flowStats = StatViewAssistant(self.ixNetwork, 'Flow Statistics', LocalCsvStorage=CafyLog.work_dir)
        flowHeadersList = flowStats.ColumnHeaders
        flowStatHeaderValues = []

        customStats = StatViewAssistant(self.ixNetwork, 'ECN', LocalCsvStorage=CafyLog.work_dir)
        customHeadersList = customStats.ColumnHeaders
        customStatHeaderValues = []

        # flowstats
        for rowNumber, stat in enumerate(flowStats.Rows):
            headerDict = {}
            for column in flowHeadersList:
                headerDict[column] = stat[column]
            flowStatHeaderValues.append(headerDict)

        #customstats
        for rowNumber, stat in enumerate(customStats.Rows):
            headerDict = {}
            for column in customHeadersList:
                headerDict[column] = stat[column]
            customStatHeaderValues.append(headerDict)

        # list to remove excess keys as per customer request
        rem_list = ['First TimeStamp', 'Frames Delta', 'Last TimeStamp','Loss %','Packet Loss Duration (ms)','Rx Bytes','Rx Frame Rate','Rx Rate (Kbps)','Rx Rate (Mbps)',
                    'Rx Rate (Bps)','Tx Frame Rate','Tx Frames','Tx L1 Rate (bps)','Tx Rate (Bps)','Tx Rate (Kbps)','Tx Rate (Mbps)']
        # appending mandatory keys into 2nd and 3rd row of flow stats
        add_list = ['IPv4 :Class selector PHB','IPv6 :Traffic Class','Traffic Item','Tx Port','Tx Rate (bps)','Rx Port']

        # ECN bit from custom stats into ECN_dict
        ECN_dict = dict()
        for item in streamList:
            for i in range(len(customStatHeaderValues) - 1):
                if customStatHeaderValues[i]['Traffic Item'] == item:
                    [customStatHeaderValues[i].pop(k) for k in rem_list if k in customStatHeaderValues[i].keys()]
                    ECN_dict.setdefault(item, []).append(customStatHeaderValues[i])
                    if (len(customStatHeaderValues)//len(streamList) )== 3:
                        if customStatHeaderValues[i + 2]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 2].pop(k) for k in rem_list if k in customStatHeaderValues[i + 2].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 2])
                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])
                    if (len(customStatHeaderValues)//len(streamList) )== 2:
                        if customStatHeaderValues[i + 1]['Traffic Item'] == '':
                            [customStatHeaderValues[i + 1].pop(k) for k in rem_list if k in customStatHeaderValues[i + 1].keys()]
                            ECN_dict.setdefault(item, []).append(customStatHeaderValues[i + 1])

        # filteredResult dict adding traffic item with flow statistics flow
        if streamList:
            for trafficItemName in streamList:
                for trafficItemDict in flowStatHeaderValues:
                    [trafficItemDict.pop(k) for k in rem_list if k in trafficItemDict.keys()]
                    for key, value in trafficItemDict.items():
                        if value == trafficItemName and trafficItemDict['Rx Port'] == rxPort:
                            filteredResult.setdefault(trafficItemName, []).append(trafficItemDict)

        # using add_list adding mandatory keys from 1st flow into 2nd n 3rd flow
        for trafficName, flow in ECN_dict.items():
            for key, value in filteredResult.items():
                if key == trafficName:
                    for (eachflow, eachvalue) in zip(flow, value):
                        value[0]['Egress Tracking'] = eachflow['Egress Tracking']
                    for count in range(1, len(flow)):
                        filteredResult[trafficName].append(flow[count])
                        for k in add_list:
                            try:
                                flow[count][k] = value[0][k]
                            except:
                                pass

        for key, value in filteredResult.items():
            #remove 1st dict as its not required wrt spirent
            value.pop(0)
            for flow in value:
                for field in flow:
                    if field == 'IPv6 :Traffic Class':
                        try:
                            flow['Traffic Class (int)'] = flow['Egress Tracking']
                        except:pass
                        del flow['IPv6 :Traffic Class']

                    if field == 'IPv4 :Class selector PHB':
                        flow['DSCP (int)'] = flow['IPv4 :Class selector PHB']
                        del flow['IPv4 :Class selector PHB']

                    if field == 'Egress Tracking':
                        try:
                            flow['ECN (bits)'] = bin(int(flow['Egress Tracking'], 16))[2:]
                        except:
                            flow['ECN (bits)'] = flow['Egress Tracking']
                        del flow['Egress Tracking']

                    if field == 'Rx L1 Rate (bps)':
                        flow['Rx L1 Rate'] = int(float(flow['Rx L1 Rate (bps)']))
                        del flow['Rx L1 Rate (bps)']
                    if field == 'Rx Frames':
                        flow['Rx Count'] = flow['Rx Frames']
                        del flow['Rx Frames']
                try:
                    if flow['ECN (bits)'] == '0':
                        flow.update({'ECN': 'Non-ECT'})
                    elif flow['ECN (bits)'] == '1':
                        flow.update({'ECN': 'ECT(1)'})
                    elif flow['ECN (bits)'] == '10':
                        flow.update({'ECN': 'ECT(0)'})
                    elif flow['ECN (bits)'] == '11':
                        flow.update({'ECN': 'CE'})
                except:pass

        for key, value in filteredResult.items():
            filteredResult[key] = [ele for ele in ({key: val for key, val in sub.items() if val != ''} for sub in value) if ele]
        return filteredResult

    def add_network_group(self, device_name, protocol, **kwargs):
        """
        API to add Network group for ISIS,OSPF and BGP protocols , Supports both ipv4 and ipv6 network groups

        :param device_name: Name of the Device group on which the network routes to be added
        :param protocol: protocol on which the network routes to be added. Ex: protocol='isis' or 'bgp' or 'ospf'
        :param kwargs:
                network_address_step: Network prefix step value
                network_address_incr_step: Network IP address increment step Ex  Integer value for step value
                network_group_multiplier: Network group multiplier Ex 1 or 2
                v4_network_address_start: Ipv4 network address start value Ex '2.2.2.2'/['2.2.2.2']
                v4_network_address_incr_step: ipv4 network address increment step Ex: '0.0.0.1'
                v4_network_address_prefix_list: ipv4 network address prefix length Ex : [24, 32]
                network_address_type: Network address type it can be List/Increment
                network_group_name : Str Network group name
                ip_type: String demonstrating the IP version
                route_type: String demonstrating the Network Group version type
        return True on success or raise exception

        Examples:
            1.tgnObj.add_network_group(device_name='Device1', protocol='ospf')

            2.tgnObj.add_network_group(device_name='Device_isis', number_of_address = [10,20],protocol='isis',
              network_group_multiplier= 2, prefix_type ='list',v4_network_address_start=['2.2.2.2', '3.3.3.3'],
              v4_network_address_prefix_list=[32, 24],v4_network_address_incr_step='0.0.0.2',
              network_address_step=[20, 30], network_address_type='list')
        """
        v4_network_address_incr_step = kwargs.get('v4_network_address_incr_step', '0.0.0.1')
        v4_network_address_start = kwargs.get('v4_network_address_start', None)
        v4_network_address_prefix_list = kwargs.get('v4_network_address_prefix_list', None)
        v6_network_address_start = kwargs.get('v6_network_address_start', None)
        v6_network_address_prefix_list = kwargs.get('v6_network_address_prefix_list', None)
        v6_network_address_incr_step = kwargs.get('v6_network_address_incr_step', '0:0:1::')
        network_group_name = kwargs.get('network_group_name', None)
        network_group_multiplier = kwargs.get('network_group_multiplier', 1)
        prefix_type = kwargs.get('prefix_type', 'SingleValue')
        number_of_address = kwargs.get('number_of_address', [1])
        network_address_step = kwargs.get('network_address_step', [1])
        ip_type = kwargs.get('ip_type', 'ipv4')
        if ip_type.lower() == "ipv4":
            route_type = kwargs.get('route_type', 'ipv4')
        if ip_type.lower() == "ipv6":
            route_type = kwargs.get('route_type', 'ipv6')

        if kwargs.get('v6_network_address_start', None):
            if type(kwargs['v6_network_address_start']) == str:
                network_address_type = kwargs.get('network_address_type', 'increment')
            elif type(kwargs['v6_network_address_start']) == list:
                network_address_type = kwargs.get('network_address_type', 'list')
        if kwargs.get('v4_network_address_start', None):
            if type(kwargs['v4_network_address_start']) == str:
                network_address_type = kwargs.get('network_address_type', 'increment')
            elif type(kwargs['v4_network_address_start']) == list:
                network_address_type = kwargs.get('network_address_type', 'list')
        if kwargs.get('v4_network_address_start') == None and kwargs.get('v6_network_address_start') == None:
            network_address_type = kwargs.get('network_address_type', 'increment')

        protocolStatus = False
        try:
            networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').NetworkGroup.add(Multiplier=network_group_multiplier,
                                                               Name=network_group_name)
        except:
            raise IxiaConfigException("'%s' Device group not found to add Network Group" % device_name)

        # The protocol to which network group need to be connected
        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        if protocol.lower() == 'isis':
            protocolObj = deviceObj.Ethernet.find().IsisL3.find()
        elif protocol.lower() == 'ospf' and ip_type.lower() == 'ipv4':
            protocolObj = deviceObj.Ethernet.find().Ipv4.find().Ospfv2.find()
        elif protocol.lower() == 'bgp' and ip_type.lower() == 'ipv4':
            protocolObj = deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find()

        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        if protocol.lower() == 'ospf' and ip_type.lower() == 'ipv6':
            protocolObj = deviceObj.Ethernet.find().Ipv6.find().Ospfv3.find()
        if protocol.lower() == 'bgp' and ip_type.lower() == 'ipv6':
            protocolObj = deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find()

        if route_type.lower() == "ipv4":
            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(
                Name=networkGroupObj.Name).Ipv4PrefixPools.add()
        if route_type.lower() == "ipv6":
            ipPool = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find(
                Name=networkGroupObj.Name).Ipv6PrefixPools.add()
        ipPool.Connector.find().ConnectedTo = protocolObj.href

        # Verifying is protocol is present in the given device group
        for networkObj in self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').NetworkGroup.find(
            Name=networkGroupObj.Name):

            if route_type.lower() == "ipv4":
                ipPoolObj = networkObj.Ipv4PrefixPools.find()
            if route_type.lower() == "ipv6":
                ipPoolObj = networkObj.Ipv6PrefixPools.find()

            if protocol.lower() == 'isis':
                if ipPoolObj.IsisL3RouteProperty.find():
                    protocolStatus = True
            if protocol.lower() == 'ospf':
                if route_type.lower() == "ipv4":
                    if ipPoolObj.OspfRouteProperty.find():
                        protocolStatus = True
                if route_type.lower() == "ipv6":
                    if ipPoolObj.Ospfv3RouteProperty.find():
                        protocolStatus = True
            if protocol.lower() == 'bgp':
                if ipPoolObj.BgpIPRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpV6IPRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpL3VpnRouteProperty.find():
                    protocolStatus = True
                if ipPoolObj.BgpV6L3VpnRouteProperty.find():
                    protocolStatus = True

        # only if protocol is found go ahead and set the passed args
        if protocolStatus:
            if network_address_type.lower() == 'increment':
                if route_type.lower() == "ipv4":
                    ipPoolObj.NetworkAddress.Increment(start_value=v4_network_address_start,
                                                       step_value=v4_network_address_incr_step)
                if route_type.lower() == "ipv6":
                    ipPoolObj.NetworkAddress.Increment(start_value=v6_network_address_start,
                                                       step_value=v6_network_address_incr_step)
            if network_address_type.lower() == 'list':
                if route_type.lower() == "ipv4":
                    ipPoolObj.NetworkAddress.ValueList(v4_network_address_start)
                if route_type.lower() == "ipv6":
                    ipPoolObj.NetworkAddress.ValueList(v6_network_address_start)
            if prefix_type.lower() == 'list':
                if route_type.lower() == "ipv4":
                    ipPoolObj.PrefixLength.ValueList(v4_network_address_prefix_list)
                if route_type.lower() == "ipv6":
                    ipPoolObj.PrefixLength.ValueList(v6_network_address_prefix_list)

            if number_of_address is not None:
                ipPoolObj.NumberOfAddressesAsy.ValueList(number_of_address)
            if network_address_step is not None:
                ipPoolObj.PrefixAddrStep.ValueList(network_address_step)
        else:
            pass

        self.log.info("Network Group added Successfully")
        return True

    def change_port_transmit_mode(self, port=None, transmit_mode='interleaved'):
        """
        API to change the port transmit mode
        :param port: name of the port on which transmit mode to be changed.
                    Ex: port = '1/1' or port = ['10.10.1.1/1/2']
        :param transmit_mode: supported mode values - 'interleaved' , 'sequential'
        return: True on successful

        Example: tgnObj.change_port_transmit_mode(transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port=['1/1'], transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port='10.36.75.242/2/5', transmit_mode='sequential')
                 tgnObj.change_port_transmit_mode(port=['10.36.75.242/2/6'], transmit_mode='interleaved')
        """
        self.log.info('Changing the Port Transmit Mode')
        if port:
            if type(port) is str:
                port = port.split(",")
            portList = []
            for vport in self.ixNetwork.Vport.find():
                if vport.AssignedTo.replace(":", "/") in port or vport.Name in port:
                    portList.append(vport)
        else:
            portList = self.get_list_ports()
        for eachPort in portList:
            eachPort.TxMode = transmit_mode
        return True

    def set_advance_sequencing(self, enable=True):
        """
        Set or unset the Advance Sequencing to allow determination of re-order packets
        :param enable: boolean, true to enable. false if you want to disable feature
        :return: True if the operation is successful , False Otherwise
        """
        try:
            self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled = enable
        except:
            raise IxiaConfigException("Unable to change Advance Sequence Checking")
        return True

    def verify_inorder_reorder_traffic(self):
        """
        Verify no reordered packets on any traffic streams

        :return: Print out table showing in-order packets and re-ordered packets with Status
        """
        if not self.ixNetwork.Traffic.Statistics.AdvancedSequenceChecking.Enabled:
            raise IxiaConfigException("Advance Sequence Checking is not enabled")
        else:
            try:
                stats = self.get_stats(view_name='Traffic Item Statistics')

            except:
                raise IxiaConfigException("Unable to get Traffic Item Statistics")
            headers = ["Traffic Item", "In Order Frames", "Reordered Frames", "Status"]
            data = []
            item_headers = headers.copy()
            stats_headers = set()
            for one_obj in stats.values():
                for head in one_obj.keys():
                    stats_headers.add(head)
            Inorder_flag = False
            TX_Frames_flag = False
            ReOrder_flag = False
            for one_obj in stats.values():
                for key, value in list(one_obj.items()):
                    if key == "Reordered Frames" and int(value) > 0 :
                        one_obj.update({'Status': 'Fail'})
                        ReOrder_flag = True
                        break
                    elif key == "Reordered Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Pass'})
                    if key =="Tx Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Fail'})
                        TX_Frames_flag = True
                        break
                    elif key =="In Order Frames" and int(value) == 0:
                        one_obj.update({'Status': 'Fail'})
                        Inorder_flag = True
                        break
            for one_obj in stats.values():
                one_data = []
                for _head in item_headers:
                    if _head in one_obj.keys():
                        one_data.append(one_obj[_head])
                    else:
                        one_data.append('N/A')
                data.append(one_data)
            stats_tb = tabulate.tabulate(data,
                                         headers=item_headers,
                                         tablefmt='rst')

            self.log.info('Traffic Item:\n' + stats_tb)
            if TX_Frames_flag:
                raise IxiaConfigException("Tx Frames count is 0")
            elif Inorder_flag :
                raise IxiaConfigException("In-Order Frames count is 0")
            elif ReOrder_flag:
                raise IxiaConfigException("Re-Order Frames count is greater than 0")
            return stats_tb

    def _set_ldp_network_group_options(self, poolHandle, routeCount, prefixIp=None, prefixlen=None, routerID=None):
        """
        Set Route count and prefix based on Protocol handle.
        :param poolHandle: PrefixPool Handle
        :param routeCount: RouteCount to be updated
        :param prefixIp: prefixIp as reference
        :param prefixlen: prefixlen as reference
        :param routerID: routerID as reference
        :return:
        """
        if int(self.ixNetwork.Globals.BuildNumber[:1]) >= 9:
            if prefixIp and routerID:
                if prefixIp in poolHandle.NetworkAddress.Values:
                    ipPrefixIndex = (poolHandle.NetworkAddress.Values).index(prefixIp)
                    valueList = poolHandle.NumberOfAddressesAsy.Values
                    valueList[ipPrefixIndex] = routeCount
                    poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)
                    if prefixlen:
                        valueList = poolHandle.PrefixLength.Values
                        valueList[ipPrefixIndex] = prefixlen
                        poolHandle.PrefixLength.ValueList(values=valueList)
            elif routerID and prefixIp is None:
                for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
                    if deviceGroupObj.RouterData.find():
                        if routerID in deviceGroupObj.RouterData.find().RouterId.Values:
                            routerIDIndex = (deviceGroupObj.RouterData.find().RouterId.Values).index(routerID)
                            valueList = poolHandle.NumberOfAddressesAsy.Values
                            valueList[routerIDIndex] = routeCount
                            poolHandle.NumberOfAddressesAsy.ValueList(values=valueList)
                            if prefixlen:
                                valueList = poolHandle.PrefixLength.Values
                                valueList[routerIDIndex] = prefixlen
                                poolHandle.PrefixLength.ValueList(values=valueList)
            else:
                poolHandle.NumberOfAddressesAsy.Single(routeCount)
                if prefixlen:
                    poolHandle.PrefixLength.Single(prefixlen)
        # This block for 8.50 version
        if int(self.ixNetwork.Globals.BuildNumber[:1]) <= 8:
            poolHandle.NumberOfAddresses = routeCount
            if prefixlen:
                poolHandle.PrefixLength.Single(prefixlen)

    def _modify_ldp_route_count(self, network_group, route_count, ip_type, start_ip_prefix, prefix,
                                router_id, **kwargs):
        """
        Internal API to support setting route count and prefix length of BGP network group

        :param network_group: Network Group for which Route Count should be modified
        :param route_count: Route count
        :param ip_type: ipv4 or ipv6
        :param start_ip_prefix: start ip prefix as reference
        :param prefix: prefix
        :param router_id: router ID
        :return: result
        """
        protocolStatus = False
        deviceGroupName = None
        nested_network_group = kwargs.get('nested_network_group')
        networkGroupNameList = []
        for deviceGroupObj in self.ixNetwork.Topology.find().DeviceGroup.find():
            if deviceGroupObj.RouterData.find():
                for routerId in router_id:
                    if routerId in deviceGroupObj.RouterData.find().RouterId.Values:
                        deviceGroupName = deviceGroupObj.Name
                        break
        try:
            if deviceGroupName:
                for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find(
                        Name='^' + deviceGroupName + '$').NetworkGroup.find():
                    if network_group:
                        if network_group in networkGroup.Name:
                            networkGroupNameList.append(networkGroup.Name)
                            break
                    else:
                        networkGroupNameList.append(networkGroup.Name)
        except:
            pass
        if network_group:
            try:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if nested_network_group and network_group:
            try:
                networkGroupNameList = [networkObj.Name for networkObj in
                                        self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find()
                                        if network_group in networkObj.Name]
            except:
                pass
        if networkGroupNameList:
            for networkGroupName in networkGroupNameList:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + networkGroupName + '$')
                if nested_network_group:
                    try:
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + networkGroupName + '$')
                    except:
                        pass
                if ip_type.lower() == "ipv4":
                    for networkGroupObj in networkObj.Ipv4PrefixPools.find():
                        if networkGroupObj.LdpFECProperty.find():
                            protocolStatus = True
                            networkObj.Enabled.Single(True)
                            for routerId in router_id:
                                self._set_ldp_network_group_options(networkGroupObj, route_count,
                                                                    prefixIp=start_ip_prefix,
                                                                    prefixlen=prefix, routerID=routerId)
                if ip_type.lower() == "ipv6":
                    for networkGroupObj in networkObj.Ipv6PrefixPools.find():
                        if networkGroupObj.LdpIpv6FECProperty.find():
                            networkObj.Enabled.Single(True)
                            protocolStatus = True
                            for routerId in router_id:
                                self._set_ldp_network_group_options(networkGroupObj, route_count,
                                                                    prefixIp=start_ip_prefix,
                                                                    prefixlen=prefix, routerID=routerId)
        else:
            raise IxiaConfigException("Router Id or network_group not found ")
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        if protocolStatus:
            return protocolStatus
        else:
            raise IxiaConfigException("LDP protocol not configured or Configuration issue.")

    def set_ldp_route_count(self, route_count, ip_type="ipv4", **kwargs):
        """
        Modifying address count for BGP protocol. IXIA does not provide support for per-protocol address count. In fact, the count is configured for the IP address pool.

        :param route_count: Integer/String representing the new route count
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                router_id: Router ID of the device
                route_block_name: route block name from config
                start_ip: represents the first IP of the route block
                prefix: Integer/String representing the new prefix
                nested_network_group : if nested network group, Need to pass nested_network_group = True
                                if nested_network_group is True 'route_block_name' is mandatory
        :return: True if the operation is successful, False otherwise

        :Example: set_ldp_route_count(route_count=10, ports=["Ethernet - 001"], network_group="Network Group 9")
        """
        network_group = kwargs.get('route_block_name')
        if 'network_group' in kwargs:
            network_group = kwargs.get('network_group')
        self.log.info("Setting Ldp Route Count for route_block_name:%s" % (network_group))
        startIp = kwargs.get('start_ip')
        prefixLength = kwargs.get('prefix')
        routerId = kwargs.get('router_id')
        if not isinstance(routerId, list):
            routerId = [routerId]
        nestedGroup = kwargs.get('nested_network_group', False)
        if not network_group and routerId is None:
            raise IxiaConfigException('Please pass either Network group/Router Id')
        return self._modify_ldp_route_count(network_group, route_count, ip_type, start_ip_prefix=startIp,
                                            prefix=prefixLength, router_id=routerId,
                                            nested_network_group=nestedGroup)

    def modify_vlan(self, device_name, port_list=None, vlan_id=1, **kwargs):
        """
        Modifies device VLAN id and enable/disable vlan based on Device name or port name
        :param device_name: device group name to set vlan id
        :param port_list: list of port names - Ex: ['R1_T1_1']
        :param vlan_id: VLAN ID to be set. Default value is 1
        :param kwargs:
                vlan_number: vlan ID need to be modified
                            Ex: vlan_number = 101, vlan_id = 111, i.e vlan 104 will be changed to 111
                vlan_count : vlan number which need to be changes, defalut is 1
                            Ex : vlan_count = 1, vlan ID 1 will be changed
                                 vlan_count = 2, vlan ID 2 will be changed
                vlan_step : Step to increment vlan_id, default 1
                vlan_direction :  CHOICES 'increment|decrement|' default is 'increment'
                enable_vlan : enable/disable vlan based on device_name
                              Ex : enable_vlan = True, vlan is enabled on device_name
                                   enable_vlan = False, vlan is disabled on device_name
        :return: None
        :Example: modify_vlan(device_name='V4_V6_SSM',port_list=['PortConfig1/2/3 TenGigE0/0/0/2_R1'],enable_vlan=True)
                  modify_vlan(device_name='V4_V6_SM',port_list='PortConfig1/2/1 TenGigE0/0/0/0_R1', enable_vlan=True)
        """
        self.log.info("Modifying vlan id based on device group name / port name")
        ethObj = None
        try:
            ethObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find()
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
        except:
            raise IxiaOperationException("Device Group not Found in the Ixia Configuration")

        port_index_list = []
        if port_list:
            if type(port_list) == list:
                for port in port_list:
                    for topology in self.ixNetwork.Topology.find():
                        if self.ixNetwork.Vport.find(Name=port).href in topology.Vports:
                            topologyObj = topology.href
                            port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port).href))
                            for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():
                                if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                    ethObj = ethernet
            elif type(port_list) == str:
                for topology in self.ixNetwork.Topology.find():
                    if self.ixNetwork.Vport.find(Name=port_list).href in topology.Vports:
                        topologyObj = topology.href
                        port_index_list.append(topology.Vports.index(self.ixNetwork.Vport.find(Name=port_list).href))

                        for ethernet in topology.DeviceGroup.find(Name='^' + device_name + '$').Ethernet.find():
                            if re.match(topologyObj + '/deviceGroup', ethernet.href):
                                ethObj = ethernet

        vlan_count = kwargs.get('vlan_count', 1)
        vlan_number = kwargs.get('vlan_number', None)
        if vlan_count:
            vlanObj = ethObj.Vlan.find()[vlan_count - 1]
        else:
            vlanObj = ethObj.Vlan.find()[0]
        vlanList = vlanObj.VlanId.Values
        enableList = ethObj.EnableVlans.Values
        if 'enable_vlan' in kwargs:
            if 'device_id' in kwargs:
                enableList[kwargs['device_id'] - 1] = kwargs['enable_vlan']
                ethObj.EnableVlans.ValueList(enableList)
            elif 'vlan_number' in kwargs:
                vlan_index = vlanList.index(str(kwargs['vlan_number']))
                enableList[vlan_index] = kwargs['enable_vlan']
                ethObj.EnableVlans.ValueList(enableList)
            else:
                for port_index in port_index_list:
                    if deviceObj.Multiplier > 1:
                        count = 0
                        if port_index == 0:
                            count = port_index
                            while count < deviceObj.Multiplier:
                                enableList[count] = kwargs['enable_vlan']
                                count += 1
                            ethObj.EnableVlans.ValueList(enableList)
                        else:
                            index = port_index * deviceObj.Multiplier
                            while (index < deviceObj.Multiplier * (port_index + 1)):
                                enableList[index] = kwargs['enable_vlan']
                                index += 1
                            ethObj.EnableVlans.ValueList(enableList)
                    else:
                        enableList[port_index] = kwargs['enable_vlan']
                        ethObj.EnableVlans.ValueList(enableList)
        else:
            enable_vlan = kwargs.get('enable_vlan', None)
            try:
                self.ixNetwork.Topology.find().DeviceGroup.find(
                    Name='^' + device_name + '$').Ethernet.find().EnableVlans.Single(enable_vlan)
            except:
                pass

        if 'vlan_number' in kwargs or 'device_id' in kwargs:
            if 'vlan_number' in kwargs:
                vlan_index = vlanList.index(str(vlan_number))
                vlanList[vlan_index] = str(vlan_id)
                vlanObj.VlanId.ValueList(vlanList)
            elif 'device_id' in kwargs:
                vlan_index = kwargs['device_id'] - 1
                vlanList[vlan_index] = str(vlan_id)
                vlanObj.VlanId.ValueList(vlanList)
        else:
            vlan_direction = kwargs.get('vlan_direction', 'increment')
            if vlan_direction.lower() == 'decrement':
                vlanObj.VlanId.Decrement(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
            vlanObj.VlanId.Increment(start_value=vlan_id, step_value=kwargs.get('vlan_step', 1))
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()

    def load_bgp_routes(self, file_name, network_group, overwrite=True):
        """
        Adding start address and prefix from given CSV file into the BGP network group
        :param file_name: csvFile with contains start address and prefix
        :param network_group: Network group name to which route and prefix need to be added
        :param overwrite: boolean flag, to overwrite or to concat to existing address pools, default value is True
        :return: returns True on success
        Example: load_bgp_routes(file_name = "ipv4_routes.csv",network_group = "Network Group BGP")
                load_bgp_routes(file_name = "ipv6_routes.csv",network_group = "Network Group BGP", overwrite=False)
        """
        log.info("Adding Route Prefix to %s",network_group)
        routeEntries = 0
        originValuesDict = {"igp":"i", "egp":"e"}

        networkGroupObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                    Name='^' + network_group + '$')
        try:
            poolObj =  networkGroupObj.Ipv4PrefixPools.find()
            if poolObj.BgpIPRouteProperty.find():
                bgpRouteObj = poolObj.BgpIPRouteProperty.find()
            if poolObj.BgpV6IPRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()
            if poolObj.BgpL3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()
            if poolObj.BgpV6L3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()
            ip_type = "ipv4"
        except Exception as e:
            poolObj =  networkGroupObj.Ipv6PrefixPools.find()
            if poolObj.BgpIPRouteProperty.find():
                bgpRouteObj = poolObj.BgpIPRouteProperty.find()
            if poolObj.BgpV6IPRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6IPRouteProperty.find()
            if poolObj.BgpL3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpL3VpnRouteProperty.find()
            if poolObj.BgpV6L3VpnRouteProperty.find():
                bgpRouteObj = poolObj.BgpV6L3VpnRouteProperty.find()
            ip_type = "ipv6"

        networkPrefixValues = poolObj.PrefixLength.Values
        networkAddrValues = poolObj.NetworkAddress.Values
        aspath = bgpRouteObj.AsPathASString
        Med = bgpRouteObj.MultiExitDiscriminator.Values
        LocalPref = bgpRouteObj.LocalPreference.Values
        weight = bgpRouteObj.Weight.Values
        origin = bgpRouteObj.Origin.Values

        outputfile = CafyLog.work_dir + '/' + "output.csv"
        existingDetails = []

        if overwrite == False:
            routeEntries += bgpRouteObj.Count
            for addr, prefix, asstr, med, pref, weight, org in zip(networkAddrValues, networkPrefixValues, aspath, Med, LocalPref, weight, origin):
                entry = []
                entry.append(originValuesDict[org]) #first cell
                entry.append(addr +'/' + prefix) #add/prefix
                if ip_type == "ipv4":
                    entry.append("0.0.0.0") #next hop
                else:
                    entry.append("1.1.1.1")

                entry.append(med) #med
                entry.append(pref) #local  pref
                entry.append(weight) #wegith
                entry.append(asstr) #as path
                entry.append(originValuesDict[org])
                existingDetails.append(entry)

        with open(file_name, 'r') as csvinput:
            with open(outputfile, 'w') as csvoutput:
                writer = csv.writer(csvoutput, lineterminator='\n')
                reader = csv.reader(csvinput)
                row = next(reader)
                for row in reader:
                    rowEntry = []
                    rowEntry.append("i") # firs cell
                    rowEntry.append(row[0] + '/' + row[1]) #address/prefix
                    if len(row) <= 2:
                        if ip_type == "ipv4":
                            rowEntry.append("0.0.0.0") #next hop
                        else:
                            rowEntry.append("1.1.1.1")
                        rowEntry.extend(["0", "0", "0", "{1}"])
                    else:
                        try:
                            rowEntry.append(row[2]) # next hop
                            rowEntry.append(row[3]) #med
                            rowEntry.append(row[4]) #local pref
                            rowEntry.append(row[5]) #wegith
                            rowEntry.append(row[6]) #as path
                        except Exception as e:
                            pass
                    rowEntry.append("i") #as path
                    routeEntries +=1
                    existingDetails.extend([rowEntry])
                writer.writerows(existingDetails)

        try:
            bgpRouteObj.ImportBgpRoutes(Arg2='roundRobin', Arg3=True, Arg4='overwriteTestersAddress',
                                                Arg5='csv',Arg6=(Files(outputfile, local_file=True)),Arg7=routeEntries)
            networkGroupObj.Multiplier = routeEntries
            self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        except Exception as e:
            raise IxiaConfigException("Network Group '%s' not found on the config" % (network_group))
        return True

    def get_device_protocol_status(self, protocols=None, devices=None):
        """
        This api returns the protocol status (up | down | Not started) based of protocol or devices
        :param protocols: List of protocols to fetch status
        :param devices: List of device names
        :return:True on success otherwise return False

        Example: get_device_protocol_status(protocols = ["isis","bgp"], devices = ['Device ISIS 1','BGP Router 3'])
                 get_device_protocol_status(protocols = ["isis","ospf"])
                 get_device_protocol_status()
        """
        self.log.info(" Getting protocol status info ")
        resultDict = dict()
        if devices is None:
            devices = self.get_device_names()
        protocolsList = {'isis': 'IsisL3', 'bgp': 'BgpIpv4Peer',
                         'igmp': 'IgmpHost', 'igmpquerier': 'IgmpQuerier', 'ldpbasicrouter': 'LdpBasicRouter',
                         'ospfv2': 'Ospfv2', 'bgpv6': 'BgpIpv6Peer', 'ldpbasicrouterv6': 'LdpBasicRouterV6',
                         'pimv4interface': 'PimV4Interface',
                         'mld': 'MldHost', 'mldquerier': 'MldQuerier',
                         'pimv6interface': 'PimV6Interface', 'ospfv3': 'Ospfv3'}
        if protocols:
            for protocol in protocols:
                for eachDevice in devices:
                    eachDevice = eachDevice.replace('+', '\+').replace('*', '\*')
                    if protocol.lower() in protocolsList:
                        if protocol.lower() in ["isis"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
                        if protocol.lower() in ["bgp", "igmp", "igmpquerier", "ldpbasicrouter", "pimv4interface",
                                                "ospfv2"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
                        if protocol.lower() in ["bgpv6", "ldpbasicrouterv6", "mld", "mldquerier", "pimv6interface",
                                                "ospfv3"]:
                            try:
                                if eval('self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                        protocolsList[protocol.lower()] + '.find()'):
                                    if 'false' not in (list(set(
                                            eval(
                                                'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                                protocolsList[protocol.lower()] + '.find().Active.Values')))):
                                        resultDict.setdefault(protocol.lower(), []).append({eachDevice: list(set(eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' +
                                            protocolsList[protocol.lower()] + '.find().SessionStatus')))})
                            except:
                                pass
        else:
            for key, protocol in protocolsList.items():
                for eachDevice in devices:
                    eachDevice = eachDevice.replace('+', '\+').replace('*', '\*')
                    if key in ["isis"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
                    if key in ["bgp", "igmp", "igmpquerier", "ldpbasicrouter", "pimv4interface", "ospfv2"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv4.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
                    if key in ["bgpv6", "ldpbasicrouterv6", "mld", "mldquerier", "pimv6interface", "ospfv3"]:
                        try:
                            if 'down' in list(set(eval(
                                    'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' + protocol + '.find().SessionStatus'))):
                                if 'false' not in (list(set(
                                        eval(
                                            'self.ixNetwork.Topology.find().DeviceGroup.find(Name="' + eachDevice + '").Ethernet.find().Ipv6.find().' + protocol + '.find().Active.Values')))):
                                    resultDict.setdefault(key, []).append(eachDevice)
                        except:
                            pass
        return resultDict

    def add_new_bgp_route_block(self, device, ip_type='ipv4', **kwargs):
        """
        Add a bgp route block/prefix to an existing device

        :param device: device on which route block to be added
        :param ip_type: 'ipv4' or 'ipv6'(default value is 'ipv4')
        :param route_start: starting IP of route block
        :param route_prefix: Route prefix
        :param route_count: Number of routes
        :param route_prefix_step: Route prefix step to increment
        :return: True on success, exception on failure
        ex: tgn.add_new_bgp_route_block(device='Router 1',route_start='150.0.0.1',route_count='5', route_prefix_step='2', route_prefix='24')
        """

        if ip_type.lower() == 'ipv6':
            network_address_start = kwargs.get('route_start', '2000::1')
            network_address_prefix_list = kwargs.get('route_prefix', '64')
            network_address_count = kwargs.get('route_count', '1')
            network_address_prefix_step = kwargs.get('route_prefix_step', '1')
            network_address_incr_step = kwargs.get('route_address_incr', '::1')
            self.add_network_group(device_name=device, protocol='bgp',
                                   ip_type='ipv6',
                                   v6_network_address_start=network_address_start,
                                   v6_network_address_prefix_list=network_address_prefix_list,
                                   v6_network_address_incr_step=network_address_incr_step, )
        else:
            network_address_start = kwargs.get('route_start', '192.0.1.0')
            network_address_prefix_list = kwargs.get('route_prefix', '24')
            network_address_count = kwargs.get('route_count', '1')
            network_address_prefix_step = kwargs.get('route_prefix_step', '1')
            network_address_incr_step = kwargs.get('route_address_incr', '0.0.0.1')
            self.add_network_group(device_name=device, protocol='bgp',
                                   ip_type='ipv4',
                                   v4_network_address_start=network_address_start,
                                   v4_network_address_prefix_list=network_address_prefix_list,
                                   v4_network_address_incr_step=network_address_incr_step, )
        return True

    def config_pim_group_member(self, device_name, ip_version, group_name=None, **kwargs):
        """
        Configures PIM group-membership
        :param device_name: Name of the Device
        :param ip_version: ipv4/ipv6
        :param group_name: Name of the IPv4/Ipv6 Multicast group
        :param kwargs: Optional arguments
        :param pim_rp_ipv4: Rendezvous Point Router (RPR) IPv4 address
        :param pim_rp_ipv6: Rendezvous Point Router (RPR) IPv6 address
        :param pim_group_type: STARG/SG/STARSTARRP
        :param pimv4_join_src: Start IPv6 address of Join source range
        :param pimv4_prefix_length: prefix length of Join source IPv4 address
        :param pimv6_join_src: Start IPv6 address of Join source range
        :param pimv6_prefix_length: prefix length of Join source IPv6 address
        :return: True on successful configuration
        Example: tgn.config_pim_group_member(device_name='Device 1', ip_version = 'ipv4',
                                             pim_group_type='STARG', enable_prune=True)
        """

        if ip_version.lower() == 'ipv4':
            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \
                Ipv4.find().PimV4Interface.find()
            self.config_multicast_group(ip_version='ipv4', device_name=device_name,
                                        protocol='pimv4',
                                        group_name=group_name,
                                        start_ip=kwargs.get('pimv4_join_src', '192.0.1.0'),
                                        step='0.0.0.1',
                                        prefix=kwargs.get('pimv4_prefix_length', 24))
        else:
            pimDevice = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name).Ethernet.find(). \
                Ipv6.find().PimV6Interface.find()
            self.config_multicast_group(ip_version='ipv6', device_name=pimDevice.Name,
                                        protocol='pimv6',
                                        group_name=group_name,
                                        start_ip=kwargs.get('pimv6_join_src', '::2'),
                                        step='::1',
                                        prefix=kwargs.get('pimv6_prefix_length', 64))

        return True

    def modify_streamblock_params(self, cfg_dict, traffic_item_list=None):
        """
        Function NA for IXIA as these streamblock params are not applicable for IXIA

        Allows user to modify Streamblock parameters
        :param traffic_item_list: List of Traffic item for which modification is required
        :param cfg_dict: params that requires to be modified
            cfg_dict={'Allow_InvalidHeaders': False, 'enable_stream_generation': True, 'Enable_FcsErrorInsertion': False}
            Allow_InvalidHeaders (DefaultValue=False)
            Enable_FcsErrorInsertion (DefaultValue=False)
            Insert_Fcs (DefaultValue=True)
            enable_stream_generation (DefaultValue=True)
            enable_highSpeed_analysis (DefaultValue=True)
        :return: True if successful else raise Exception
        """
        pass

    def set_ipv4_traffic_destip(self, traffic_item, dest_ip):
        """
        Allows user to insert/change modifier for IPv4 Dest IP or its value alone at runtime
        :param traffic_item: List of stream names whose traffic class value to be changed
        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list
        :return: Returns True in case no exceptions
        """
        self.log.info("Modifying IPv4 Destination Address")
        if type(traffic_item) is str:
            traffic_item = [traffic_item]
        for eachTi in traffic_item:
            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
            if not trafficItem:
                raise IxiaConfigException("stream not found")
            configElement = trafficItem.ConfigElement.find()[0]
            ipv4Stack = configElement.Stack.find(StackTypeId='^ipv4$')
            try:
                if type(dest_ip) is str:
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = "singleValue"
                    ipv4Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip
                elif type(dest_ip) is list:
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueType = "valueList"
                    ipv4Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip
                else:
                    self.log.error("Invalid Destination IP address %" % dest_ip)
            except:
                raise IxiaConfigException("IPv4 destination address modification failed")
        return True

    def set_ipv6_traffic_destip(self, traffic_item, dest_ip):
        """
        Allows user to insert/change modifier for IPv6 Dest IP or its value alone at runtime
        :param traffic_item: List of stream names whose traffic class value to be changed
        :param dest_ip: List of dest_ip values that needs to be set for each traffic item in a list
        :return: Returns True in case no exceptions
        """
        self.log.info("Modifying IPv6 Destination Address")
        if type(traffic_item) is str:
            traffic_item = [traffic_item]
        for eachTi in traffic_item:
            trafficItem = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
            if not trafficItem:
                raise IxiaConfigException("stream not found")
            configElement = trafficItem.ConfigElement.find()[0]
            ipv6Stack = configElement.Stack.find(StackTypeId='^ipv6$')
            try:
                if type(dest_ip) is str:
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = "singleValue"
                    ipv6Stack.Field.find(DisplayName='Destination Address').FieldValue = dest_ip
                elif type(dest_ip) is list:
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueType = "valueList"
                    ipv6Stack.Field.find(DisplayName='Destination Address').ValueList = dest_ip
                else:
                    self.log.error("Invalid Destination IP address %" % dest_ip)
            except:
                raise IxiaConfigException("IPv6 destination address modification failed")
        return True

    def _update_field_values(self, field_entry, field_value):
        """
        This API takes the field_entry from traffic item stack and
        set values from field_value. This is a generic API to set/update protocol's stack field
        :param field_entry: Stack field object from traffic item
        :param field_value: value to be copied into stack field object.
                           This handles values of singlevalue/increment/valueList
        """
        try:
            if isinstance(field_value, dict):
                field_entry.Auto = False
                if 'start' in field_value:
                    field_entry.ValueType = 'increment'
                    field_entry.StartValue = field_value['start']
                if 'min' in field_value:
                    field_entry.ValueType = 'repeatableRandomRange'
                    field_entry.MinValue = field_value['min']
                if 'max' in field_value:
                    field_entry.MaxValue = field_value['max']
                if 'seed' in field_value:
                    field_entry.Seed = field_value['seed']
                if 'step' in field_value:
                    field_entry.StepValue = field_value['step']
                else:
                    field_entry.StepValue = 1
                if 'count' in field_value:
                    field_entry.CountValue = field_value['count']
                else:
                    field_entry.CountValue = 1
                if 'type' in field_value:
                    if field_value['type'] == 'random':
                        field_entry.ValueType = 'nonRepeatableRandom'
                        field_entry.RandomMask = 65535
                    if field_value['type'] == 'randomBitMask':
                        field_entry.ValueType = 'random'
                        field_entry.RandomMask = 65535
            elif isinstance(field_value, (str, int)):
                # process single value
                field_entry.Auto = False
                field_entry.ValueType = 'singleValue'
                field_entry.SingleValue = field_value
            elif isinstance(field_value, list):
                # process value list
                field_entry.Auto = False
                field_entry.ValueType = 'valueList'
                field_entry.ValueList = field_value
            result = True
        except:
            result = False
        return result

    def _config_udp_fields(self, cfg_dict, configElement):
        """
        API to set/update udp stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        if 'src_port_value' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Source-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_src_port = cfg_dict['src_port_value']
                    result = self._update_field_values(fieldValue[index - 1], udp_src_port)
        if "dest_port_value" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Dest-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_dest_port = cfg_dict['dest_port_value']
                    result = self._update_field_values(fieldValue[index - 1], udp_dest_port)
        if "udp_header_len" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Length")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_hdr_len = cfg_dict['udp_header_len']
                    result = self._update_field_values(fieldValue[index - 1], udp_hdr_len)
        if "udp_checksum" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="UDP-Checksum")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    udp_checksum = cfg_dict['udp_checksum']
                    result = self._update_field_values(fieldValue[index - 1], udp_checksum)
        return result

    def _config_tcp_fields(self, cfg_dict, configElement):
        """
        API to set/update tcp stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        tcp_ip_options = {'mss': 'maximumSegmentSize'}
        if 'src_port_value' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="TCP-Source-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_src_port = cfg_dict['src_port_value']
                    result = self._update_field_values(fieldValue[index - 1], tcp_src_port)
        if "dest_port_value" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="TCP-Dest-Port")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_dest_port = cfg_dict['dest_port_value']
                    result = self._update_field_values(fieldValue[index - 1], tcp_dest_port)
        if "tcp_data_offset" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Data Offset")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_dataoffset = cfg_dict['tcp_data_offset']
                    result = self._update_field_values(fieldValue[index - 1], tcp_dataoffset)
        if "tcp_options" in cfg_dict.keys():
            try:
                if cfg_dict['tcp_options']['option'] == 'mss':
                    field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[
                        cfg_dict['tcp_options']['option']] + '.kind'
                    field_value_obj = configElement.Stack.find().Field.find(FieldTypeId=field_type_id)[
                        cfg_dict['header_index'] - 1]
                    if cfg_dict['tcp_options']['action'] == 'enable':
                        field_value_obj.OptionalEnabled = True
                        result = True
                        if "tcp_mss_data" in cfg_dict.keys():
                            field_type_id = 'tcp.header.options.option.type.' + tcp_ip_options[
                                cfg_dict['tcp_options']['option']] + '.data'
                            field_value = configElement.Stack.find().Field.find(FieldTypeId=field_type_id)
                            for index in range(1, len(field_value) + 1):
                                if index == cfg_dict['header_index']:
                                    tcp_mss_value = cfg_dict['tcp_mss_data']
                                    result = self._update_field_values(field_value[index - 1], tcp_mss_value)
                    else:
                        field_value_obj.OptionalEnabled = False
                        result = True
                else:
                    self.log.warning('Please share proper TCP Option')
                    result = False
            except:
                result = False
                self.log.error('TCP option update failed')
        if "tcp_checksum" in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="TCP-Checksum")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_data_checksum = cfg_dict['tcp_checksum']
                    result = self._update_field_values(fieldValue[index - 1], tcp_data_checksum)
        if "tcp_control_bit" in cfg_dict.keys():
            for key, value in cfg_dict["tcp_control_bit"].items():
                if configElement.Stack.find().Field.find(DisplayName=key):
                    field_value = configElement.Stack.find().Field.find(DisplayName=key)
                    for index in range(1, len(field_value) + 1):
                        if index == cfg_dict['header_index']:
                            result = self._update_field_values(field_value[index - 1], value)
                else:
                    self.log.error(f'Invalid TCP Control Bit {key}')
                    result = False
        if "tcp_ecn" in cfg_dict.keys():
            for key, value in cfg_dict["tcp_ecn"].items():
                if configElement.Stack.find().Field.find(DisplayName=key):
                    field_value = configElement.Stack.find().Field.find(DisplayName=key)
                    for index in range(1, len(field_value) + 1):
                        if index == cfg_dict['header_index']:
                            result = self._update_field_values(field_value[index - 1], value)
                else:
                    self.log.error(f'Invalid TCP Control Bit {key}')
                    result = False
        if 'tcp_window' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Window")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_window = cfg_dict['tcp_window']
                    result = self._update_field_values(fieldValue[index - 1], tcp_window)
        
        if 'tcp_urgent_pointer' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Urgent Pointer")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    tcp_urgent_pointer = cfg_dict['tcp_urgent_pointer']
                    result = self._update_field_values(fieldValue[index - 1], tcp_urgent_pointer)
        
        print(result)

        return result

    def _config_mpls_fields(self, cfg_dict, configElement):
        """
        Internal Method to Configure MPLS stack under traffic item
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement:  Traffic Item Config Element
         """
        if 'mpls_ttl' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Time To Live")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_ttl = cfg_dict['mpls_ttl']
                    result = self._update_field_values(fieldValue[index - 1], mpls_ttl)
        if 'mpls_label_value' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="Label Value")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_label_value = cfg_dict['mpls_label_value']
                    result = self._update_field_values(fieldValue[index - 1], mpls_label_value)
        if 'mpls_exp' in cfg_dict.keys():
            fieldValue = configElement.Stack.find().Field.find(DisplayName="MPLS Exp")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    mpls_exp = cfg_dict['mpls_exp']
                    result = self._update_field_values(fieldValue[index - 1], mpls_exp)
        return result

    def _config_ipv4_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv4 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        ip_options_dict = {'nop': 'nop', 'security': 'security.type', 'lsrr': 'lsrr.type', 'pointer': 'pointer',
                           'route': 'routeData', 'ssrr': 'ssrr.type',
                           'record': 'recordRoute.type', 'streamId': 'streamId.type', 'timestamp': 'timestamp.type',
                           'endOptions': 'last', 'raValue': 'routerAlert.type'}
        header_index = cfg_dict['header_index']

        if 'ipv4_tot_len' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="total_len")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_tot_len = cfg_dict['ipv4_tot_len']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_tot_len)
        if 'ipv4_more_fragements' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="^fragment_flag$")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_mf = cfg_dict['ipv4_more_fragements']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_mf)
        if 'ipv4_fragement_offset' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name="fragment_offset")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_fo = cfg_dict['ipv4_fragement_offset']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_fo)
        if 'ipv4_modify_version' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='version')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_ver = cfg_dict['ipv4_modify_version']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_ver)
        if 'ipv4_src_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='source_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_src_ip = cfg_dict['ipv4_src_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_src_ip)
        if 'ipv4_dst_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV4")
            fieldValue = stack.find().Field.find(Name='dest_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_dst_ip = cfg_dict['ipv4_dst_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_dst_ip)
        if 'ipv4_header_checksum' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPv4")
            fieldValue = stack.find().Field.find(Name='^checksum$')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_checksum = cfg_dict['ipv4_header_checksum']
                    result = self._update_field_values(fieldValue[index - 1], ipv4_checksum)
        if 'ttl' in cfg_dict.keys():
            stack = configElement.find().Stack.find(DisplayName="IPv4")
            field_value = stack.Field.find(Name='^ttl$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    ipv4_ttl = cfg_dict['ttl']
                    result = self._update_field_values(field_value[index - 1], ipv4_ttl)
        if 'ipv4_protocol' in cfg_dict.keys():
            header_index = cfg_dict['header_index']
            stack = configElement.Stack.find(DisplayName="IPv4")
            field_value = stack.Field.find(Name='^protocol$')[header_index - 1]
            if cfg_dict['ipv4_protocol'].upper() == 'AUTO':
                field_value.Auto = True
            else:
                field_value.Auto = False
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = cfg_dict['ipv4_protocol']
            result = True
        if 'ipv4_ip_options' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPv4")
            ip_option = cfg_dict['ipv4_ip_options']
            try:
                field_type_id = 'ipv4.header.options.nextOption.option.' + ip_options_dict[ip_option['option']]
                ip_obj = stack.Field.find(FieldTypeId=field_type_id)[header_index - 1]
                if ip_option['action'] == 'enable':
                    ip_obj.OptionalEnabled = True
                else:
                    ip_obj.OptionalEnabled = False
                result = True
            except:
                result = False
                raise IxiaOperationException("IP options update failed")
        if 'ipv4_last_fragment' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='IPv4')
            field_value = stack.Field.find(Name='^last_fragment_flag$')[header_index - 1]
            try:
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = cfg_dict['ipv4_last_fragment']
                result = True
            except:
                result = False
                self.log.error("IPv4 Last Fragment update failed")

        return result

    def _config_ipv6_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        ipv6NextHeader_dict = {
            "HOPOPT": 0, "ICMP": 1, "IGMP": 2, "GGP": 3, "IP": 4, "ST": 5, "TCP": 6, "CBT": 7, "EGP": 8, "IGP": 9,
            "BBN-RCC-MON": 10, "NVP-II": 11, "PUP": 12, "ARGUS": 13, "EMCON": 14, "XNET": 15, "CHAOS": 16, "UDP": 17,
            "MUX": 18, "DCN-MEAS": 19, "HMP": 20, "PRM": 21, "XNS-IDP": 22, "TRUNK-1": 23, "TRUNK-2": 24, "LEAF-1": 25,
            "LEAF-2": 26, "RDP": 27, "IRTP": 28, "ISO-TP4": 29, "NETBLT": 30, "MFE-NSP": 31, "MERIT-INP": 32, "SEP": 33,
            "3PC": 34, "IDPR": 35, "XTP": 36, "DDP": 37, "IDPR-CMTP": 38, "TP++": 39, "IL": 40, "IPv6": 41, "SDRP": 42,
            "IPv6-Route": 43, "IPv6-Frag": 44, "IDRP": 45, "RSVP": 46, "GRE": 47, "MHRP": 48, "BNA": 49, "ESP": 50,
            "AH": 51, "I-NLSP": 52, "SWIPE": 53, "NARP": 54, "MOBILE": 55, "TLSP": 56, "SKIP": 57, "IPv6-ICMP": 58,
            "IPv6-NoNxt": 59, "IPv6-Opts": 60, "Any host internal protocol": 61, "CFTP": 62, "Any local network": 63,
            "SAT-EXPAK": 64, "KRYPTOLAN": 65, "RVD": 66, "IPPC": 67, "Any distributed file system": 68, "SAT-MON": 69,
            "VISA": 70, "IPCV": 71, "CPNX": 72, "CPHB": 73, "WSN": 74, "PVP": 75, "BR-SAT-MON": 76, "SUN-ND": 77,
            "WB-MON": 78, "WB-EXPAK": 79, "ISO-IP": 80, "VMTP": 81, "SECURE-VMTP": 82, "VINES": 83, "TTP": 84,
            "NSFNET-IGP": 85, "DGP": 86, "TCF": 87, "EIGRP": 88, "OSPFIGP": 89, "Sprite-RPC": 90, "LARP": 91, "MTP": 92,
            "AX.25": 93, "IPIP": 94, "MICP": 95, "SCC-SP": 96, "ETHERIP": 97, "ENCAP": 98, "Any private encryption": 99,
            "GMTP": 100, "IFMP": 101, "PNNI": 102, "PIM": 103, "ARIS": 104, "SCPS": 105, "QNX": 106, "A/N": 107,
            "IPComp": 108, "SNP": 109, "Compaq-Peer": 110, "IPX-in-IP": 111, "VRRP": 112, "PGM": 113,
            "Any 0-hop protocol": 114, "L2TP": 115, "DDX": 116, "IATP": 117, "STP": 118, "SRP": 119, "UTI": 120,
            "SMP": 121, "SM": 122, "PTP": 123, "ISIS over IPv4": 124, "FIRE": 125, "CRTP": 126, "CRUDP": 127,
            "SSCOPMCE": 128, "IPLT": 129, "SPS": 130, "PIPE": 131, "SCTP": 132, "FC": 133, "RSVP-E2E-IGNORE": 134,
            "Mobility Header": 135, "UDPLite": 136, "MPLS-in-IP": 137}
        if 'ipv6_version' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="version")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_version = cfg_dict['ipv6_version']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_version)
        if 'ipv6_traffic_class' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="trafficClass")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_traffic_class = cfg_dict['ipv6_traffic_class']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_traffic_class)
        if 'ipv6_flow_label' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="flowLabel")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_flow_label = cfg_dict['ipv6_flow_label']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_flow_label)
        if 'ipv6_payload_len' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="payloadLength")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_payload_len = cfg_dict['ipv6_payload_len']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_payload_len)
        if 'ipv6_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="nextHeader")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    if cfg_dict['ipv6_next_header'] in ipv6NextHeader_dict:
                        ipv6_next_header = ipv6NextHeader_dict[cfg_dict['ipv6_next_header']]
                        result = self._update_field_values(fieldValue[index - 1], ipv6_next_header)
        if 'ipv6_hop_limit' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name="hopLimit")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_hop_limit = cfg_dict['ipv6_hop_limit']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_hop_limit)
        if 'ipv6_src_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name='source_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_src_ip = cfg_dict['ipv6_src_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_src_ip)
        if 'ipv6_dst_address' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName="IPV6")
            fieldValue = stack.find().Field.find(Name='dest_ip')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_dst_ip = cfg_dict['ipv6_dst_address']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_dst_ip)
        return result

    def _config_ipv6_routing_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv6 routing header stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_routing_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Routing Header' + '$')
            field_value = stack.Field.find(Name='next_header')[header_index - 1]
            try:
                if cfg_dict['ipv6_routing_next_header'].upper() == 'AUTO':
                    field_value.Auto = True
                else:
                    field_value.Auto = False
                    field_value.ValueType = 'singleValue'
                    field_value.FieldValue = cfg_dict['ipv6_routing_next_header']
            except:
                self.log.info('IPv6 Routing Next header modification failed')

        return True

    def _config_ipv6_authentication_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv6 authentication header stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_auth_next_header' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Authentication Header' + '$')
            field_value = stack.Field.find(Name='next_header')[header_index - 1]
            try:
                if cfg_dict['ipv6_auth_next_header'].upper() == 'AUTO':
                    field_value.Auto = True
                else:
                    field_value.Auto = False
                    field_value.ValueType = 'singleValue'
                    field_value.FieldValue = cfg_dict['ipv6_auth_next_header']
            except:
                self.log.info('IPv6 Authentication Next header modification failed')
        return True

    def _config_ipv6_fragment_fields(self, cfg_dict, configElement):
        """
        API to set/update ipv4 stack fields under traffic item.
        :param cfg_dict: takes the ipv6 params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        header_index = cfg_dict['header_index']
        if 'ipv6_fragment_offset' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')
            fieldValue = stack.Field.find(Name='fragment_offset')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    ipv6_fragment_offset = cfg_dict['ipv6_fragment_offset']
                    result = self._update_field_values(fieldValue[index - 1], ipv6_fragment_offset)
        if 'ipv6_more_fragments' in cfg_dict.keys():
            stack = configElement.Stack.find(DisplayName='^' + 'IPv6 Fragment Header' + '$')
            field_value = stack.Field.find(Name='More Fragments')[header_index - 1]
        try:
            field_value.ValueType = 'singleValue'
            field_value.FieldValue = cfg_dict['ipv6_more_fragments']
        except:
            self.log.error('IPv6 More Fragments field modification failed')
        return True

    def _config_igmp_fields(self, cfg_dict, configElement):
        """
        API to set/update igmp stack fields under traffic item.
        :param cfg_dict: The igmp params and their respective values that
                        needs to be set/updated.Ex : igmp_version ,igmp_type,igmp_unused,igmp_checksum,igmp_group_address
        :param configElement: It is the configElement object obtained from traffic item object
        """
        stack = configElement.Stack.find(DisplayName="IGMP")
        if cfg_dict['protocol_name'] == 'igmpv1':
            stack = configElement.Stack.find(DisplayName="IGMPv1")
        if cfg_dict['protocol_name'] == 'igmpv2':
            stack = configElement.Stack.find(DisplayName="IGMPv2")
        if cfg_dict['protocol_name'] == 'igmpv3q':
            stack = configElement.Stack.find(DisplayName="IGMPv3 Membership Query")
        if cfg_dict['protocol_name'] == 'igmpv3r':
            stack = configElement.Stack.find(DisplayName="IGMPv3 Membership Report")

        if 'igmp_version' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name="version1")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_version = cfg_dict['igmp_version']
                    result = self._update_field_values(fieldValue[index - 1], igmp_version)
        if 'igmp_type' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name="type1")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_type = cfg_dict['igmp_type']
                    result = self._update_field_values(fieldValue[index - 1], igmp_type)
        if 'igmp_unused' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='unused')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_unused = cfg_dict['igmp_unused']
                    result = self._update_field_values(fieldValue[index - 1], igmp_unused)
        if 'igmp_checksum' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='checksum')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_checksum = cfg_dict['igmp_checksum']
                    result = self._update_field_values(fieldValue[index - 1], igmp_checksum)
        if 'igmp_group_address' in cfg_dict.keys():
            fieldValue = stack.Field.find(Name='group_address')
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    igmp_group_address = cfg_dict['igmp_group_address']
                    result = self._update_field_values(fieldValue[index - 1], igmp_group_address)
        return result

    def _config_icmp_fields(self, cfg_dict, configElement):
        """
        API to set/update icmp stack fields under traffic item.
        :param cfg_dict: The icmp params and their respective values that
                        needs to be set/updated.Ex : icmp_message_type ,icmp_code_option
                        protocol_name will be below icmp types
        :param configElement: It is the configElement object obtained from traffic item object
        """
        icmp_msg_dict = {3: 'Dest. Unreachable', 4: 'Src. Quench', 5: 'Redirect Message', 11: 'Time Exceeded',
                         12: 'Parameter Problem', 0: 'Echo reply', 8: 'Echo message', 13: 'TimeStamp message',
                         14: 'TimeStamp reply', 15: 'Information Request', 16: 'Information Reply'}
        icmp_code_dict = {'dest_unreachable': 'Dest. Unreachable code options', 'src_quench': 'Src. Quench option',
                          'info_request': 'Info Request option',
                          'info_response': 'Info Response option', 'time_exceeded': 'Time Exceeded option',
                          'redirect_msg': 'Redirect Message option'}
        icmp_code_sub_dict = {'net_unreach': 'Net unreachable', 'host_unreach': 'Host unreachable',
                              'protocol_unreach': 'Protocol unreachable',
                              'port_unreach': 'Port unreachable', 'fragment_needed': 'Fragmentation needed and DF set',
                              'source_fail': 'Source route failed',
                              'ttl_exceeded': 'TTL exceeded in transit',
                              'fragment_reassembly': 'Fragment reassembly time exceeded',
                              'redirect_nw': 'Redirect datagrams for network',
                              'redirect_host': 'Redirect datagrams for the Host',
                              'redirect_tos_nw': 'Redirect datagrams for the TOS and network',
                              'redirect_tos_host': 'Redirect datagrams for the TOS and host'}
        unused_type_dict = {'unused_type3': 'opt1', 'unused_type4': 'opt2', 'unused_type11': 'opt3',
                            'unused_next_field': 'unsd'}
        header_index = cfg_dict['header_index']
        if 'icmp_message_type' in cfg_dict.keys():
            if cfg_dict['icmp_message_type'] in icmp_msg_dict:
                icmp_msg = cfg_dict['icmp_message_type']
                if (icmp_msg == 3 or icmp_msg == 4 or icmp_msg == 5 or icmp_msg == 11 or icmp_msg == 12):
                    stack = configElement.Stack.find(StackTypeId="^icmpv1$")
                else:
                    stack = configElement.Stack.find(StackTypeId="^icmpv2$")
                field_value = stack.Field.find(Name="msg_type")[header_index - 1]
                field_value.FieldValue = icmp_msg_dict[icmp_msg]
                result = True
        if 'icmp_code_options' in cfg_dict.keys():
            if cfg_dict['icmp_code_options'] in icmp_code_dict:
                stack = configElement.Stack.find(StackTypeId="^icmpv1$")
                field_value = stack.Field.find(DisplayName=icmp_code_dict[cfg_dict['icmp_code_options']])[header_index - 1]
                field_value.ActiveFieldChoice = True
                result = True
        if 'icmp_code_sub_options' in cfg_dict.keys():
            icmpSubOption = cfg_dict['icmp_code_sub_options']
            stack = configElement.Stack.find(StackTypeId="^icmpv1$")
            if icmpSubOption == 'net_unreach' or icmpSubOption == 'host_unreach' or icmpSubOption == 'protocol_unreach' or icmpSubOption == 'port_unreach' or icmpSubOption == 'fragment_needed' or icmpSubOption == 'source_fail':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['dest_unreachable'])[header_index - 1]
            elif icmpSubOption == 'ttl_exceeded' or icmpSubOption == 'fragment_reassembly':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['time_exceeded'])[header_index - 1]
            elif icmpSubOption == 'redirect_nw' or icmpSubOption == 'redirect_host' or icmpSubOption == 'redirect_tos_nw' or icmpSubOption == 'redirect_tos_host':
                field_value = stack.Field.find(DisplayName=icmp_code_dict['redirect_msg'])[header_index - 1]
            try:
                field_value.ActiveFieldChoice = True
                field_value.ValueType = 'singleValue'
                field_value.FieldValue = icmp_code_sub_dict[icmpSubOption]
                result = True
            except Exception as err:
                raise IxiaConfigException('ICMP Code options updation failed with {}'.format(err))
        if 'icmp_code_value' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv2$")
            field_value = stack.Field.find(Name="Code")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmp_code = cfg_dict['icmp_code_value']
                    result = self._update_field_values(field_value[index - 1], icmp_code)
        if 'icmp_identifier' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv2$")
            field_value = stack.Field.find(Name="^id_fier$")
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmp_identifier = cfg_dict['icmp_identifier']
                    result = self._update_field_values(field_value[index - 1], icmp_identifier)
        if 'icmp_unused_type' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv1$")
            field_value = stack.Field.find(Name='^' + unused_type_dict[cfg_dict['icmp_unused_type']] + '$')
            field_value[header_index - 1].ActiveFieldChoice = True
            if 'icmp_unused_code' in cfg_dict.keys():
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmp_unused_code = cfg_dict['icmp_unused_code']
                        result = self._update_field_values(field_value[index - 1], icmp_unused_code)
        return result

    def _config_icmpv6_fields(self, cfg_dict, configElement):
        """
        API to set/update icmpv6 stack fields under traffic item.
        :param cfg_dict: The icmp params and their respective values that
                        needs to be set/updated.Ex : icmpv6_message_type ,icmpv6_code_option
                        protocol_name will be below icmp types
        :param configElement: It is the configElement object obtained from traffic item object
        """
        icmpv6_msg_dict = {1: 'destinationUnreachableMessage.mesageType',2:'packetTooBigMessage.messageType',
                           3: 'timeExceededMessage.messageType',4:'parameterProblemMessage.messageType',
                           128: 'echoRequestMessage.messageType',129:'echoReplyMessage.messageType'}
        icmpv6_code_dict = {'hop_limit':'Hop limit exceeded in transit','fragment_reassembly':'Fragment reassembly time exceeded',
                            'erroneous_header':'Erroneous header field encountered',
                            'unrecognized_header':'Unrecognized Next Header type encountered',
                            'unrecognized_ipv6':'Unrecognized IPv6 option encountered','no_route':'No route to destination',
                            'commun_prohibited':'Communication with destination administratively prohibited',
                            'not_assigned':'Not assigned','add_unreachable':'Address unreachable',
                            'port_unreachable':'Port unreachable'}
        header_index = cfg_dict['header_index']

        if 'icmpv6_message_type' in cfg_dict.keys():
            if cfg_dict['icmpv6_message_type'] in icmpv6_msg_dict:
                stack = configElement.Stack.find(StackTypeId="^icmpv6$")
                fieldTypeId = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[
                    cfg_dict['icmpv6_message_type']]
                field_value = stack.Field.find(FieldTypeId=fieldTypeId)[header_index - 1]
                field_value.ActiveFieldChoice = True
                result = True
        if 'icmpv6_code_options' in cfg_dict.keys():
            if 'icmpv6_message_type' in cfg_dict.keys():
                stack = configElement.Stack.find(StackTypeId="^icmpv6$")
                if cfg_dict['icmpv6_code_options'] in icmpv6_code_dict:
                    field_value = None
                    if cfg_dict['icmpv6_message_type'] == 3:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.timeExceededMessage.code')[header_index - 1]
                    elif cfg_dict['icmpv6_message_type'] == 4:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.parameterProblemMessage.code')[header_index - 1]
                    elif cfg_dict['icmpv6_message_type'] == 1:
                        field_value = stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.destinationUnreachableMessage.code')[header_index - 1]
                    else:
                        self.log.error('Please select valid message type to update code option')
                    if field_value:
                        try:
                            field_value.FieldValue = icmpv6_code_dict[cfg_dict['icmpv6_code_options']]
                            result = True
                        except Exception as err:
                            raise IxiaConfigException(
                                'Invalid Code Type for given message type: exception raised {}'.format(err))
                else:
                    result = False
                    self.log.error('Please share valid ICMPv6 code option')
            else:
                result = False
                self.log.error('Please select message type to update code option')
        if 'icmpv6_code' in cfg_dict.keys():
            field_type_id = 'icmpv6.icmpv6Message.icmpv6MessegeType.' + icmpv6_msg_dict[cfg_dict['icmpv6_message_type']]
            field_type_id = field_type_id.replace('messageType', 'code')
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            field_value = stack.Field.find(FieldTypeId=field_type_id)
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    icmpv6_code = cfg_dict['icmpv6_code']
                    result = self._update_field_values(field_value[index - 1], icmpv6_code)
        if 'icmpv6_mtu' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            if cfg_dict['icmpv6_message_type'] == 2:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.packetTooBigMessage.maximumTransmissionUnit')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_mtu = cfg_dict['icmpv6_mtu']
                        result = self._update_field_values(field_value[index - 1], icmpv6_mtu)
            else:
                self.log.error('MTU value is only supported for Packet Too Big Message Type')
        if 'icmpv6_identifier' in cfg_dict.keys():
            stack = configElement.Stack.find(StackTypeId="^icmpv6$")
            if cfg_dict['icmpv6_message_type'] == 128:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoRequestMessage.identifier')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_identifier = cfg_dict['icmpv6_identifier']
                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)
            elif cfg_dict['icmpv6_message_type'] == 129:
                field_value = stack.Field.find(
                    FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.echoReplyMessage.identifier')
                for index in range(1, len(field_value) + 1):
                    if index == cfg_dict['header_index']:
                        icmpv6_identifier = cfg_dict['icmpv6_identifier']
                        result = self._update_field_values(field_value[index - 1], icmpv6_identifier)
            else:
                self.log.error('Identifier value is only supported for Echo Request(128) or Echo Response(129) Message Types')
        return result

    def _config_vlan_fields(self, cfg_dict, configElement):
        """
        API to set/update vlan stack fields under traffic item.
        :param cfg_dict: takes the vlan params and their respective values that needs to be set/updated
        :param configElement: is the configElement object obtained from traffic item object
        """
        stack = configElement.Stack.find(DisplayName="VLAN")
        if 'vlan_id' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_id")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_id = cfg_dict['vlan_id']
                    result = self._update_field_values(fieldValue[index - 1], vlan_id)
        if 'vlan_priority' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_user_priority")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_priority = cfg_dict['vlan_priority']
                    result = self._update_field_values(fieldValue[index - 1], vlan_priority)
        if 'vlan_cfi' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_cfi")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_cfi = cfg_dict['vlan_cfi']
                    result = self._update_field_values(fieldValue[index - 1], vlan_cfi)
        if 'vlan_protocol' in cfg_dict.keys():
            fieldValue = stack.find().Field.find(Name="vlan_tag_type")
            for index in range(1, len(fieldValue) + 1):
                if index == cfg_dict['header_index']:
                    vlan_protocol_id = cfg_dict['vlan_protocol']
                    result = self._update_field_values(fieldValue[index - 1], vlan_protocol_id)
        return result

    def _config_custom_fields(self, cfg_dict, config_element):
        """
        API to set/update custom stack fields under traffic item.
        :param cfg_dict: takes the custom params and their respective values that needs to be set/updated
                         Ex:custom_length,custom_data
        :param config_element: is the config element object obtained from traffic item object
        """
        stack = config_element.Stack.find(DisplayName="Custom")
        if 'custom_length' in cfg_dict.keys():
            field_value = stack.Field.find(Name='^' + 'Length' + '$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    custom_len = cfg_dict['custom_length']
                    result = self._update_field_values(field_value[index - 1], custom_len)
        if 'custom_data' in cfg_dict.keys():
            field_value = stack.Field.find(Name='^' + 'Data' + '$')
            for index in range(1, len(field_value) + 1):
                if index == cfg_dict['header_index']:
                    custom_data_value = cfg_dict['custom_data']
                    result = self._update_field_values(field_value[index - 1], custom_data_value)
        return result

    def modify_packet_stream_header(self, cfg_dict, traffic_item_list=None):
        """
        API to modify Traffic item protocol headers like TCP,UDP,IGMPv1,IGMPv2
        :param cfg_dict: A dictionary containing header items whose value needs to modify
        :param traffic_item_list: List of traffic items
        :return True on success otherwise return False
        Ex : modify_packet_stream_header(traffic_item_list=['T1'], cfg_dict={'protocol_name': 'udp','header_index':1,'src_port_value': 30,
                                         'dest_port_value': 60}))
        """
        self.log.info('Modifying traffic item header')
        result = False
        if type(traffic_item_list) != list:
            log.info('Invalid traffic_items_list type. Please use list')
        # ‘header_index’ by default need to consider it as 1.
        if 'header_index' not in cfg_dict:
            cfg_dict['header_index'] = 1
        for trafficItemName in traffic_item_list:
            trafficItemName = trafficItemName.replace('+', '\+').replace('*', '\*')
            trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItemName + '$')
            #import pdb;pdb.set_trace()
            if not trafficItemObj:
                raise IxiaConfigException("Traffic item not found")
            for configElement in trafficItemObj.ConfigElement.find():
                if cfg_dict["protocol_name"] == 'udp':
                    result = self._config_udp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'tcp':
                    result = self._config_tcp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'mpls':
                    result = self._config_mpls_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv4':
                    result = self._config_ipv4_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6':
                    result = self._config_ipv6_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'custom':
                    result = self._config_custom_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'igmp':
                    result = self._config_igmp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'vlan':
                    result = self._config_vlan_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'icmp':
                    result = self._config_icmp_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'icmpv6':
                    result = self._config_icmpv6_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Routing':
                    result = self._config_ipv6_routing_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Auth':
                    result = self._config_ipv6_authentication_fields(cfg_dict, configElement)
                elif cfg_dict["protocol_name"] == 'ipv6Fragment':
                    result = self._config_ipv6_fragment_fields(cfg_dict, configElement)
        
        import pdb;pdb.set_trace()
        return result

    def inject_traffic_error(self,traffic_item=None, crc_error="goodCrc", disparity_error=False):
        """
        API to inject CRC, disparity errors for traffic items

        :param traffic_item: Name of traffic item on which to inject error
        :param crc_error: To inject CRC error, Supported values - "badCrc" , "goodCrc"
        :param disparity_error: To inject disparity error if True
        :return True: On success

        Examples: inject_traffic_error(traffic_item=["ipv4"], crc_error="badCrc")
                  inject_traffic_error(traffic_item=["ipv4"], crc_error="goodCrc")
                  inject_traffic_error(traffic_item=["ipv4","ipv6"], disparity_error=True)
        """
        if traffic_item:
            for eachTi in traffic_item:
                if self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi):
                    trafficItemObj = self.ixNetwork.Traffic.TrafficItem.find(Name=eachTi)
                    trafficItemObj.ConfigElement.find().Crc = crc_error
                    trafficItemObj.ConfigElement.find().EnableDisparityError = disparity_error
                else:
                    self.log.error("Traffic Item not found")
        else:
            for eachTi in self.ixNetwork.Traffic.TrafficItem.find():
                eachTi.ConfigElement.find().Crc = crc_error
                eachTi.ConfigElement.find().EnableDisparityError = disparity_error
        return True

    def modify_ignore_link_status(self, status, port_list=None):
        """
        Enable or disable ignore link status for a given set of ports. Not applicable to Ixia

        :param port_list: (list) The port(s) to configure
            e.g. ['10.85.74.39/4/1', '10.85.74.39/4/2']
        :param status: (str) enable or disable ignore link status
            e.g. 'enable', 'disable'
        :return: True on success, exception otherwise
        """
        pass

    def create_dhcpv6_pd_host(self, host_router_id=None, cpe_router_id=None, source_mac=None, hosts_per_cpe=1):
        """
        Configures dhcpv6 PD host and home gateway link between CPE and host.
        Host gets IPv6 address from prefix delegated to CPE.

        This API is	Not applicable to ixia.

        :param host_router_id: Mandatory parameter. Router ID of host emulated device on which command needs to be performed.
        :param cpe_router_id: Mandatory parameter. Router ID of CPE emulated device on which command needs to be performed.
        :param source_mac: source mac
        :param hosts_per_cpe: host count per CPE.
        :return: True on success
        """
        pass

    def add_device_wizard(self, port, protocols, new_config, **kwargs):
        """
        API to create number of devices via wizard. Not applicable to Ixia.
        :param port: port string
        :param protocols: Protocols to be enabled eg: IGMP/MLD/PIM
        :param new_config: True if you want to clear the config else False
        :param kwargs: Optional arguments
        :param l3_type: IPV4/IPV6/IPV4V6
        :param count: Number of routers to create per port/VLAN.
        :param count_block_per_port: Count block per port
        :param count_per_block: Count per block
        :param block_mode: Single device/Block of many devices
        :param router_id: Router Id.
        :param ipv6_router_id: IPv6 Router Id
        :param duplicate_name_resolution: How duplicate device names are handled.
        :param device_name: Template string for defining device names
        :param block_index: Starting device block index.
        :param Role: Role to assign to the devices (Host/Router)
        # VLAN
        :param vlan_count: VLANs per port
        :param vlan_id: VLAN ID
        :param vlan_id_step: VLAN ID step value
        :param vlan_repeat_mode: How VLAN IDs are repeated.
        :param vlan_priority: VLAN priority.
        :param vlan_tpid: Tag protocol identifier.
        # IPV4
        :param ipv4_addr: IPv4 address.
        :param ipv4_addr_step: IPv4 address step value.
        :param ipv4_gateway: IPv4 gateway address.
        :param ipv4_gateway_step: IPv4 gateway address step value.
        :param ipv4_prefix_length: IPv4 address prefix length.
        :param ipv4_tos: TOS value used in the IP header.
        :param ipv4_tos_type: Formatting of the TOS value.
        # IPV6
        :param ipv6_addr: IPv6 address value
        :param ipv6_addr_step: IPv6 address step value
        :param ipv6_addr_type: Type of IPv6 address
        :param ipv6_gateway: IPv6 gateway address
        :param ipv6_gateway_step: IPv6 gateway address step
        :param ipv6_prefix_length: IPv6 address prefix length
        :param ipv6_traffic_class: Traffic Class
        # IGMP
        :param igmp_version: IGMP_V1/IGMP_V2/IGMP_V3.
        :param delete_igmp_existing_group: YES/NO. Whether to delete the existing IGMP group in the system
        :param igmp_dev_grp_mapping: Mapp b/w device and subscribed multicast group
        :param igmp_start_group_addr: IPv4 multicast group address.
        :param igmp_step_per_port: IPv4 multicast group step.
        :param igmp_group_count: Number of multicast groups to subscribe to.
        :param igmp_filter_mode: Mode for specifying filtered sources.
        :param igmp_filter_sources: Explicit set of sources from which multicast group is interested
        :param igmp_src_addr: Multicast source IPv4 address
        :param igmp_src_step: Step for the multicast source address
        :param igmp_src_prefix: Multicast source IPv4 prefix length
        :param igmp_src_count: Number of multicast sources
        # MLD
        :param mld_version: MLD_V1/MLD_V2
        :param delete_mld_existing_group: YES/NO. Whether to delete the existing MLD group in the system
        :param mld_dev_grp_mapping: Mapp b/w device and subscribed multicast group
        :param mld_group_count: Number of multicast groups to subscribe to.
        :param mld_start_addr: IPv6 multicast group address.
        :param mld_addr_step: IPv4 multicast group step.
        :param mld_filter_mode: Mode for specifying filtered sources.
        :param mld_filter_sources: Explicit set of sources from which multicast group is interested
        :param mld_src_addr: Multicast source IPv6 address
        :param mld_src_step: Step for the multicast source address
        :param mld_src_prefix: Multicast source IPv6 prefix length
        :param mld_src_count: Number of multicast sources
        # PIM
        :param pim_version: IP version to be used for communication with the neighbor.
        :param pim_mode: Emulated router's PIM mode.
        :param pim_dr_priority: Designated Router priority of this router.

        Example:
              add_device_wizard(port_list=['10.66.236.41/1/1', '10.66.236.41/1/2'],
              protocols=['IGMP', 'MLD', 'PIM'], l3_type = 'IPV4V6', vlan_count = 250, vlan_id = 30,
              igmp_version='IGMP_V3', igmp_group_count=20, igmp_filter_mode='INCLUDE', igmp_filter_sources = 'CUSTOM',
              mld_version = 'MLD_V2', mld_group_count = 40, mld_filter_mode = 'INCLUDE', mld_filter_sources = 'CUSTOM',
              pim_mode = 'SSM', pim_version = 'IPV6')
        """
        pass

    def set_invalid_l2_eth(self, traffic_items, cfg_dict):
        """
        API used to configure invalid L2 ethernet headers for a given list of streams. Not applicable to Ixia.

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
        """
        pass

    def modify_network_group_address_count(self,network_group=None, ip_type=None, address_count=1,**kwargs):
        """
        This API is used for modifying the Network group address count
        :param network_group:Network Group name to modify group address Count
        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'
        :param address_count: Group Address Count for IPv4/IPv6
        :param kwargs: Optional arguments
                        nested_network_group: If nested network group to be modified
        :return: True on success otherwise raise exception
        """
        nested_network_group = kwargs.get('nested_network_group',None)
        if ip_type==None:
            ip_type='ipv4'
        self.log.info("Changing Group address count for Network Group")
        # Modify Group address count for Network Group
        if network_group and nested_network_group:
            if ip_type.lower()=='ipv4':
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
            else:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                DeviceGroup.find().NetworkGroup.find(Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
            if isinstance(address_count, dict):
                cfg_dict = address_count
                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))
            elif isinstance(address_count, int):
                networkObj.NumberOfAddressesAsy.Single(address_count)
            elif isinstance(address_count, list):
                networkObj.NumberOfAddressesAsy.ValueList(address_count)
        elif network_group:
            if ip_type.lower()=='ipv4':
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                    Ipv4PrefixPools.find()
            else:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(Name='^' + network_group + '$').\
                    Ipv6PrefixPools.find()
            if isinstance(address_count, dict):
                cfg_dict = address_count
                networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),step_value=cfg_dict.get('step', 1))
            elif isinstance(address_count, int):
                networkObj.NumberOfAddressesAsy.Single(address_count)
            elif isinstance(address_count, list):
                networkObj.NumberOfAddressesAsy.ValueList(address_count)
        elif network_group == None:
            for networkGroup in self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find():
                if ip_type.lower()=='ipv4':
                    try:
                        networkObj = networkGroup.Ipv4PrefixPools.find()
                    except:
                        self.log.warning("Network Group does not have IPv4 Block")
                else:
                    try:
                        networkObj = networkGroup.Ipv6PrefixPools.find()
                    except:
                        self.log.warning("Network Group does not have IPv6 Block")
                if networkObj:
                    if isinstance(address_count, dict):
                        cfg_dict = address_count
                        networkObj.NumberOfAddressesAsy.Increment(start_value=cfg_dict.get('start', 1000),
                                                                  step_value=cfg_dict.get('step', 1))
                    elif isinstance(address_count, int):
                        networkObj.NumberOfAddressesAsy.Single(address_count)
                    elif isinstance(address_count, list):
                        networkObj.NumberOfAddressesAsy.ValueList(address_count)
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Network Group address count added Successfully")
        return True

    def modify_ldp_params(self, config_dict, device_name=None):
        """
        This API is responsible for updating LDP parameters
        :param config_dict: configuration details to get updated under LDP stack
        :param device_name: Optional, device_name under which LDP device is configured.
        :return: True on success otherwise raise exception
        """
        if device_name == None:
            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find().LdpBasicRouter.find()
        else:
            ldpObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^'+device_name+'$').LdpBasicRouter.find()

        if len(ldpObjs) == 0:
            raise IxiaConfigException("No LDP devices found")
        if len(ldpObjs.LdpLeafRangeV4) > 0:
            for ldpObj in ldpObjs:
                try:
                    if 'lsp_count_per_root' in config_dict:
                        lspCountRootObj = ldpObj.LdpLeafRangeV4.LspCountPerRoot
                        if isinstance(config_dict['lsp_count_per_root'], dict):
                            cfg_dict = config_dict['lsp_count_per_root']
                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),
                                                      step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lsp_count_per_root'], int):
                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])
                        elif isinstance(config_dict['lsp_count_per_root'], list):
                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])
                    if 'lable_start' in config_dict:
                        lblStartValObj = ldpObj.LdpLeafRangeV4.LabelValueStart
                        if isinstance(config_dict['lable_start'], dict):
                            cfg_dict = config_dict['lable_start']
                            lblStartValObj.Increment(start_value=cfg_dict.get('start', 10001),
                                                     step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lable_start'], int):
                            lblStartValObj.Single(config_dict['lable_start'])
                        elif isinstance(config_dict['lable_start'], list):
                            lblStartValObj.ValueList(config_dict['lable_start'])
                    if 'lable_step' in config_dict:
                        lblStepValObj = ldpObj.LdpLeafRangeV4.LabelValueStep
                        if isinstance(config_dict['lable_step'], dict):
                            cfg_dict = config_dict['lable_step']
                            lblStepValObj.Increment(start_value=cfg_dict.get('start', 1),
                                                    step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lable_step'], int):
                            lblStepValObj.Single(config_dict['lable_step'])
                        elif isinstance(config_dict['lable_step'], list):
                            lblStepValObj.ValueList(config_dict['lable_step'])
                except:
                    pass
        if len(ldpObjs.LdpRootRangeV4) > 0:
            for ldpObj in ldpObjs:
                try:
                    if 'lsp_count_per_root' in config_dict:
                        lspCountRootObj = ldpObj.LdpRootRangeV4.LspCountPerRoot
                        if isinstance(config_dict['lsp_count_per_root'], dict):
                            cfg_dict = config_dict['lsp_count_per_root']
                            lspCountRootObj.Increment(start_value=cfg_dict.get('start', 1000),
                                                      step_value=cfg_dict.get('step', 1))
                        elif isinstance(config_dict['lsp_count_per_root'], int):
                            lspCountRootObj.Single(config_dict['lsp_count_per_root'])
                        elif isinstance(config_dict['lsp_count_per_root'], list):
                            lspCountRootObj.ValueList(config_dict['lsp_count_per_root'])
                except:
                    pass
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_bgpmVpn_sender(self, config_dict, device_name, ip_version="ipv4", nested=False):
        """
        This API is to update values from sender-side for given bgp mVPN device
        :param config_dict: configuration details to get updated under bgp mVPN sender-side
        :param device_name: Name of the device group
        :param ip_version: supported values "ipv4" or "ipv6"
        :param nested: True if device group is nested. Default False
        :return: True on success otherwise raise exception
        """
        if nested == True:
            if ip_version == "ipv4":
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                    BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                        BgpMVpnSenderSitesIpv6.find()
            else:
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv6 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                    BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                        BgpMVpnSenderSitesIpv6.find()
        else:
            if ip_version == "ipv4":
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnSenderSitesIpv6.find()
            else:
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnSenderSitesIpv6.find()

        if len(networkObjs) == 0:
            raise IxiaConfigException("No devices found to update BgpMVpnSenderSites")
        for senderSiteObj in networkObjs:
            if 'group_address_count' in config_dict:
                grpAddrCountObj = senderSiteObj.GroupAddressCount
                if isinstance(config_dict['group_address_count'], dict):
                    cfg_dict = config_dict['group_address_count']
                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),
                                              step_value=cfg_dict.get('step', 1))
                elif isinstance(config_dict['group_address_count'], int):
                    grpAddrCountObj.Single(config_dict['group_address_count'])
                elif isinstance(config_dict['group_address_count'], list):
                    grpAddrCountObj.ValueList(config_dict['group_address_count'])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_bgpmVpn_receiver(self, config_dict, device_name, ip_version="ipv4", nested=False):
        """
        This API is responsible to update values from receiver-side for given bgp mVPN device
        :param config_dict: configuration details to get updated under bgp mVPN sender-side
        :param device_name: Name of the device group
        :param ip_version: supported values "ipv4" or "ipv6"
        :param nested: True if device group is nested. Default False
        :return: True on success otherwise raise exception
        """
        if nested == True:
            if ip_version == "ipv4":
                # Check if BgpMVpnReceiverSitesIpv4 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                    BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv4PrefixPools.find(). \
                        BgpMVpnReceiverSitesIpv6.find()
            else:
                # Check if BgpMVpnReceiverSitesIpv6 exists under ipv4 pools
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                    DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                    BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(). \
                        DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().Ipv6PrefixPools.find(). \
                        BgpMVpnReceiverSitesIpv6.find()
        else:
            if ip_version == "ipv4":
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv4PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()
            else:
                networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv4.find()
                if len(networkObjs) == 0:
                    networkObjs = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$'). \
                    NetworkGroup.find().Ipv6PrefixPools.find().BgpMVpnReceiverSitesIpv6.find()
        if len(networkObjs) == 0:
            raise IxiaConfigException("No devices found to update BgpMVpnReceiverSites")
        for receiverSiteObj in networkObjs:
            if 'group_address_count' in config_dict:
                grpAddrCountObj = receiverSiteObj.GroupAddressCount
                if isinstance(config_dict['group_address_count'], dict):
                    cfg_dict = config_dict['group_address_count']
                    grpAddrCountObj.Increment(start_value=cfg_dict.get('start', 1000),
                                              step_value=cfg_dict.get('step', 1))
                elif isinstance(config_dict['group_address_count'], int):
                    grpAddrCountObj.Single(config_dict['group_address_count'])
                elif isinstance(config_dict['group_address_count'], list):
                    grpAddrCountObj.ValueList(config_dict['group_address_count'])
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def add_igmp_mld_group_member(self, device_name, protocol, group_name, **kwargs):
        """
        API to configure igmp/mld group membership and source list on top of existing membership
        :param device_name: Device name for which extra IGMP/MLD membership needs to be added
        :param protocol: igmp or mld
        :param group_name: Multicast Group Name required to configure as mld group membership
        :param kwargs: Optional kwargs
        :param deviceGroupMapping: mapping between device and subscribed multicast group (MANY_TO_MANY/ONE_TO_ONE/ROUND_ROBIN)
        :param filterMode: mode for the associated multicast groups and sources (EXCLUE/INCLUDE)
        :param SourceList: sources are list or range of addresses (TRUE/FALSE)
        :param userDefinedSources: Controls the use of user-defined multicast sources (TRUE/FALSE)
        :param source_ipv6: Start IPv6address list
        :param valueType: 'range' or 'list'
        :param addrIncr: Network address increment
        :param networkCount: Number of networks
        :param prefixLength: IPv6address prefix length
        :return: True on successful configuration
        Ex: tgn.add_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1'),
        user_defined_sources=True, device_group_mapping='MANY_TO_MANY', filter_mode='INCLUDE', source_ip='1.0.0.11',
        addr_increment=1, network_count=10, prefix_length=24, source_list=False)
        """
        result = False
        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)) == 0:
            raise IxiaConfigException("No device found with give name", device_name)
        if protocol.lower() not in ['igmp', 'mld']:
            raise IxiaConfigException("Invalid protocol specified, only igmp and mld are allowed!")
        if 'filterMode' in kwargs:
            if kwargs.get('filterMode').lower() == "include":
                source_mode = 'include'
            elif kwargs.get('filterMode').lower() == 'exclude':
                source_mode = 'exclude'

        source_list = kwargs.get('source_list', False)
        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if protocol.lower() == 'igmp':
            self.log.info("Configuring IGMP Group Member '{}' on '{}'".format(group_name, device_name))
            sourceIP = kwargs.get('source_ip', '192.0.1.0')
            valueType = kwargs.get('value_type', 'range')
            addrIncr = kwargs.get('addr_increment', '0.0.0.1')
            networkCount = kwargs.get('network_count', 1)
            prefixLength = kwargs.get('prefix_length', 32)
            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
            if len(igmpObj) == 0:
                raise IxiaConfigException("Invalid igmp group name specified")
            if 'filterMode' in kwargs:
                srcModeObj = igmpObj.IgmpMcastIPv4GroupList.SourceMode
                srcModeObj.Single(source_mode)
            igmpObj.IgmpMcastIPv4GroupList.Active.Single(True)
            if source_list == True:
                result = self.change_igmp_source_list(device_list=[device_name], igmp_source_list=sourceIP)
            elif source_list == False:
                try:
                    igmpObj.IgmpMcastIPv4GroupList.IgmpUcastIPv4SourceList.StartUcastAddr.Increment(
                        start_value = sourceIP, step_value = addrIncr)
                except:
                    result = False
            if result == False:
                raise IxiaConfigException("IGMP source address updation failed")
        elif protocol.lower() == 'mld':
            sourceIP = kwargs.get('source_ipv6', '2000::1')
            valueType = kwargs.get('value_type', 'range')
            addrIncr = kwargs.get('addr_increment', '::1')
            networkCount = kwargs.get('network_count', 1)
            prefixLength = kwargs.get('prefix_length', 128)
            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name=group_name)
            if len(mldObj) == 0:
                raise IxiaConfigException("Invalid mld group name specified")
            if 'filterMode' in kwargs:
                srcModeObj = mldObj.MldMcastIPv6GroupList.SourceMode
                srcModeObj.Single(source_mode)
            mldObj.MldMcastIPv6GroupList.Active.Single(True)
            if source_list == True:
                result = self.change_mld_source_list(device_list=[device_name], mld_source_list=sourceIP)
            elif source_list == False:
                try:
                    mldObj.MldMcastIPv6GroupList.MldUcastIPv6SourceList.StartUcastAddr.Increment(
                        start_value = sourceIP, step_value = addrIncr)
                except:
                    result = False
            if result == False:
                raise IxiaConfigException("MLD source address updation failed")
        return True

    def delete_igmp_mld_group_member(self, device_name, protocol, group_name):
        """
        Allows user to Delete IGMP/MLD Group membership
        :param device_name: Device name for which IGMP/MLD membership needs to be deleted
        :param protocol: 'igmp' or 'mld'
        :param group_name: Mcast group name for which membership needs to be deleted
        :return: True on Success
        Example: tgn.delete_igmp_mld_group_member(device_name='Device 6', protocol='igmp', group_name='Ipv4Group 1')
        """
        if len(self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')) == 0:
            raise IxiaConfigException("No device found with give name", device_name)
        if protocol.lower() not in ['igmp', 'mld']:
            raise IxiaConfigException("Invalid protocol specified, only igmp and mld are allowed!")

        deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name=device_name)
        if protocol.lower() == 'igmp':
            self.log.info("Deleting IGMP Group Member '{}' on '{}'".format(group_name, device_name))
            igmpObj = deviceObj.Ethernet.find().Ipv4.find().IgmpHost.find(Name=group_name)
            if len(igmpObj) == 0:
                raise IxiaConfigException("Invalid igmp group name specified")
            igmpObj.IgmpMcastIPv4GroupList.Active.Single(False)
        elif protocol.lower() == 'mld':
            mldObj = deviceObj.Ethernet.find().Ipv6.find().MldHost.find(Name='^' + group_name + '$')
            if len(mldObj) == 0:
                raise IxiaConfigException("Invalid mld group name specified")
            mldObj.MldMcastIPv6GroupList.Active.Single(False)

    def start_stop_link_fault(self, port, faultmode='LOCAL', action=True):
        """
        Insert(stop/start) LOCAL/REMOTE Link Fault.

        :param port: port name or port handle or
                     interface name from Json file.
        :param faultmode: CHOICES LOCAL/REMOTE link fault.
        :param action: CHOICES True(start link fault)/False(Stop link fault)
        :return True
        """
        cardTypeList = ['atlasFourHundredGigLan', 'atm', 'ethernet', 'ethernetImpairment', 'ethernetvm',
                        'fc', 'fortyGigLan', 'hundredGigLan', 'krakenFourHundredGigLan', 'novusHundredGigLan',
                        'novusTenGigLan', 'pos', 'tenFortyHundredGigLan', 'tenGigLan', 'tenGigWan',
                        'aresOneFourHundredGigLan']
        cardType = self.ixNetwork.Vport.find(Name=port).Type
        vport = self.ixNetwork.Vport.find(Name=port)
        if cardType in cardTypeList:
            cardType = cardType[0].upper() + cardType[1:]

        cardObj = eval('vport.L1Config.' + cardType)

        if 'TypeAOrderedSets' not in dir(cardObj) or 'TypeBOrderedSets' not in dir(cardObj) or 'StartErrorInsertion' in dir(cardObj):
            self.log.error('card is Not supported for error insertion')
            return False

        if faultmode == "LOCAL":
            if 'TypeAOrderedSets' in dir(cardObj):
                cardObj.TypeAOrderedSets = "localFault"
            if 'TypeBOrderedSets' in dir(cardObj):
                cardObj.TypeBOrderedSets = "localFault"
            if 'StartErrorInsertion' in dir(cardObj):
                if action == True:
                    cardObj.StartErrorInsertion = True
                else:
                    cardObj.StartErrorInsertion = False
            return True
        elif faultmode == "REMOTE":
            if 'TypeAOrderedSets' in dir(cardObj):
                cardObj.TypeAOrderedSets = "remoteFault"
            if 'TypeBOrderedSets' in dir(cardObj):
                cardObj.TypeBOrderedSets = "remoteFault"
            if 'StartErrorInsertion' in dir(cardObj):
                if action == True:
                    cardObj.StartErrorInsertion = True
                else:
                    cardObj.StartErrorInsertion = False
            return True
        return False

    def set_invalid_netio(self, traffic_items, cfg_dict):
        """
        API used to configure invalid NetIO headers for a given list of streams. This API is not applicable to ixia

        :param traffic_items: A str of list of traffic items whose headers will be changed
        :param cfg_dict: A config dictionary containing the header values to be changed
        """
        pass

    def config_traffic_options(self, **kwargs):
        """
        API to configure Global options related to Traffic generation available in Settings. This API is not applicable to ixia
        :param kwargs: Spirent specific Traffic Option parameters
        delete_inactive_streams_from_mem: to manage inactive stream block memory usage on test modules (True/False)
        enable_global_analyzer_preload: Indicate if all streamblocks analyzer preload flag will be set to (True/False)
        enable_txqueue_full_retrymode: Determines if transmit is retried when the queue is full on Virtual ports (True/False)
        exclude_ethernet_fcs: Exclude the last 4 bytes of the packet from pcap file when generating stream block (True/False)
        smoothen_random_length: Indicate if smoothen random length distribution per port is generated (True/False)
        traffic_start_interval: Delay in units of 64 microseconds between start of port transmissions
        traffic_start_interval_unit: The traffic start interval unit (UNITOF64US/UNITOF500NS)
        traffic_start_mode: Controls how the ports start sending traffic (ASYNCHRONOUS/SYNCHRONOUS)
        traffic_streamid_startindex: The first StreamID start index to use (1-65535)
        unique_randomlength_seed_perport: Indicate if unique random seeds are created on all ports (True/False)
        :return: True if successful else raise Exception
        :Example: tgn.config_traffic_options(DeleteInactiveStreamsFromMemory = delete_inactive_streams_from_mem, TrafficStartInterval = traffic_start_interval)
        """
        pass

    def create_subs_dynamic_view(self, ip_type="ipv4"):
        """
        Create and subscribe to a dynamic view (Similar to creating user defined views on GUI). This API is not applicable to ixia
        :param ip_type: To select IPv4/IPv6 src/dest address while creating the view.

        :return: None
        """
        pass

    def unsubsribe_dynamic_view(self, drv):
        """
        Unsubscribe from previously created dynamic view. This API is not applicable to ixia
        (User-defined view on GUI).
        :param drv: Dynamic result view object created during subscribe.
        :return: None
        """
        pass

    def port_laser_on_off(self, ports=None, operation="on"):
        """
        API to Turn Laser On/Off of given port

        :param ports: List of name of ports
        :param operation: operation to be set on port "on"/"off"

        Examples: port_laser_on_off(ports=["Ethernet - 001"],operation="off")
                  port_laser_on_off(ports=["Ethernet - 001", "Ethernet - 002"],operation="on")
        """
        res = ""
        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                portObj = getattr(vport.L1Config, capitalizedCardType)
                res = res + f"{vport_name} Laser: {operation}\n"
                if operation.lower() == "off":
                    try:
                        portObj.LaserOn = False
                        self.log.info(res)
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
                elif operation.lower() == "on":
                    try:
                        portObj.LaserOn = True
                        self.log.info(res)
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_insert_local_fault(self, ports=None, source_value='localFault', dest_value='remoteFault', **kwargs):
        """
        API to Insert L1 local/remote fauls and then initiate their transmission

        :param ports: List of name of ports
        :param source_value: str 'localFault'/'remoteFault'
        :param dest_value: str 'localFault'/'remoteFault'
        :param kwargs:
                    send_sets_mode: str "typeAOnly"/"typeBOnly"
                    wait_interval : sleep time default 0
                    repetition : Number of time opertaion to be repeated Ex : 5


        Examples: port_insert_local_fault(ports=["Ethernet - 001"], source_value='localFault', dest_value='remoteFault',
                                           send_sets_mode="typeAOnly")
                   port_insert_local_fault(ports=["Ethernet - 001"], source_value='remoteFault', dest_value='localFault',
                                            send_sets_mode="typeBOnly")
                  port_insert_local_fault(ports=["Ethernet - 001"], source_value='remoteFault', dest_value='localFault',
                                            send_sets_mode="alternate", wait_interval = 5 ,  repetition = 3)
        """
        send_sets_mode = kwargs.get("send_sets_mode")
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)

        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                vp = getattr(vport.L1Config, capitalizedCardType)

                while repetition != 0:
                    try:
                        # localFault | remoteFault
                        vp.TypeAOrderedSets = source_value
                        vp.TypeBOrderedSets = dest_value

                        # alternate | typeAOnly | typeBOnly
                        vp.SendSetsMode = send_sets_mode

                        vp.StartErrorInsertion = True
                        self.log.info('Local Faults applied for port : {}'.format(vport_name))
                    except:
                        self.log.info(
                            'card type not supported to perform laser operation for port : {}'.format(vport_name))
                    time.sleep(wait_interval)
                    repetition -= 1
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_clock_source_faults(self, ports=None, loopback_mode="none", **kwargs):
        """
        Inserting clock faults bases on loopback modes

        :param ports: List of name of ports
        :param loopback_mode: Str loopback mode to be set Ex : "none"/"lineLoopback"/"internalLoopback"
        :param kwargs:
                    wait_interval : (int) sleep time default 0
                    repetition : (int) Number of time opertaion to be repeated Ex : 5

        Examples: port_clock_source_faults(ports=["Ethernet - 001"], loopback_mode= "internalLoopback", wait_interval=5, repetition=2)
                  port_clock_source_faults(ports=["Ethernet - 001"], loopback_mode="lineLoopback" )
        """

        wait_interval = kwargs.get("wait_interval", 1)
        repetition = kwargs.get("repetition", 1)

        if ports is None:
            ports = [port.Name for port in self.ixNetwork.Vport.find() if port]

        for vport_name in ports:
            vport = self.ixNetwork.Vport.find(Name='^' + vport_name + '$')
            if vport:
                portType = vport.Type
                capitalizedCardType = re.sub('([a-zA-Z])', lambda x: x.groups()[0].upper(), portType, 1)
                portObj = getattr(vport.L1Config, capitalizedCardType)

                while repetition != 0:
                    portObj.LoopbackMode = loopback_mode
                    self.log.info(f"Loopback mode: {portObj.LoopbackMode}")
                    time.sleep(wait_interval)
                    repetition -= 1
            else:
                self.log.info('port : {} not available in the config'.format(vport_name))

    def port_send_undersize_packets(self, traffic_item_name=None, **kwargs):
        """
        Sending frames with modified attributes for frame size, crc
        :param traffic_item_name: str Name of the traffic item Ex: "Traffic_ipv4"
        :param kwargs:
                undersize: undersize frame to be set or not True/False
                desired_frame_size : Frame size to be set on traffic item
                runt: True/False
                crc : Treu/False
                wait_interval : (int) sleep time default 0
                repetition : (int) Number of times operation to be repeated Ex : 5

        Examples: port_send_undersize_packets(traffic_item_name=["Traffic_item_1"], crc=True, desired_frame_size=128)
                  port_send_undersize_packets(traffic_item_name=[Traffic_item_1], runt=True, desired_frame_size=45,wait_interval = 5, repetition = 2 )
        """
        wait_interval = kwargs.get("wait_interval", 0)
        repetition = kwargs.get("repetition", 1)

        if traffic_item_name is None:
            traffic_item_name = self.get_traffic_items()

        undersize = kwargs.get("undersize", False)
        runt = kwargs.get("runt", False)
        crc = kwargs.get("crc", False)
        desired_frame_size = kwargs.get("desired_frame_size", "128")

        for traffic_item in traffic_item_name:
            # Get the config element:
            configElement = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item + '$').ConfigElement.find()[
                0]
            while repetition != 0:
                if configElement:
                    if undersize:
                        configElement.FrameSize.FixedSize = desired_frame_size

                    if runt or crc:
                        configElement.FrameSize.FixedSize = desired_frame_size
                        configElement.Crc = 'goodCrc'

                    self.log.info('Attributes modified in traffic item {}'.format(traffic_item))
                    self.regenerate_traffic()
                else:
                    self.log.info('traffic item {} not available in the config / not supported'.format(traffic_item))
                time.sleep(wait_interval)
                repetition -= 1

    def enable_network_group(self, network_group_list, enable=True):
        """
        Enable/Disable network group
        :param network_group_list: List of network Group Name
        :param enable: Enable/Disable Network Group Ex : 'True'/'False'
        :return: True if successful
                raise exception if network group not found in config
        Example: enable_network_group(network_group_list=['Network Group 1'],enable = True)
                 enable_network_group(network_group_list=['Network Group 2'],enable = False)
        """
        self.log.info('Enable/Disable Network Group')
        for network_group in network_group_list:
            try:
                if self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$'):
                    networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$')
                    networkObj.Enabled.Single(enable)
                else:
                    self.log.info("%s Not in config " % network_group)
            except:
                raise IxiaOperationException("Network Group - '%s' - '%s' Failed" % (network_group, enable))
        return True

    def set_bgp_vrf_stack_multiplier(self, stack_count, device_name, ip_type = "ipv4", **kwargs):
        """
        Set device count
        :param stack_count: Stack Multiplier count Should be >=1
        :param device_name: List of Device Group Name
        :param ip_type: String demonstrating the IP version
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_device: For IXIA Device name if device count of nested DG to be set
                                And for nested device device_name param in mandatory
        :return: True if successful
                raise exception if router id not found in Ixia

        :Example:
                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1')
                  set_bgp_vrf_stack_multiplier(stack_count = 25,device_name='IPv4 Device Group 1',nested_device='Nested IPv4 Device 1')
       """
        nested_device = kwargs.get('nested_device')
        if stack_count >= 1:
            if nested_device is None:
                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$')
                if deviceObj:
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.Ethernet.find().Ipv4.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.Ethernet.find().Ipv6.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % device_name")
            if nested_device:
                deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device_name + '$').NetworkGroup.find().DeviceGroup.find(Name='^' + nested_device + '$')
                if deviceObj:
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.Ipv4Loopback.find().BgpIpv4Peer.find().BgpIpv4MVrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.Ipv6Loopback.find().BgpIpv6Peer.find().BgpV6Vrf.find().Multiplier = stack_count
                        except:
                            raise IxiaConfigException("Changing the element in a started Protocol is not permitted ")
                else:
                    raise IxiaConfigException("Device Group (%s) Not found in the config' % nested_device")
        else:
            raise CafyException.InvalidValueError('Device count (%s) has to be greater than or equal to 1' % stack_count)
        return True

    def set_isis_sr_mpls(self, device_list=None, active='True'):
        """
        Setting ISIS SR MPLS

        :param device_list: list of device e.g. ["Device_Group_1"]
        :param active: operation to be set for SR MPLS Ex : 'True'/'False'
        :return: True on success else raises exception

        :Example: set_isis_sr_mpls(device_list=["Device_Group_1"], operation='True')
        """
        if device_list is None:
            device_list = self.get_device_names()
        self.log.info('Setting SR MPLS')
        for device in device_list:
            device = device.replace('+', '\+').replace('*', '\*')
            deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
            if deviceObj.IsisL3Router.find():
                try:
                    deviceObj.IsisL3Router.find().EnableSR = active
                except:
                    self.log.info('Could not set SR MPLS operation on device : {}'.format(device))
            else:
                self.log.info('Device/Protocol not avalible : {} '.format(device))
        return True

    def set_isis_sid_label(self, network_group_list, ip_type="ipv4", active='True', **kwargs):
        """
        Enable/Disable the SID/Index/Label in ISIS Network Group

        :param network_group_list: list of device e.g. ["Network_Group_1"]
        :param ip_type: IP type  Ex : "ipv4"/"ipv6"
        :param active: operation to be set for SR MPLS Ex : 'True'/'False'
        :param kwargs :
                        devices: List of device group names
                        address_list: List of start Address of Network Group

        :return: True on success else raises exception

        :Example: set_isis_sid_label(network_group_list=["Network_Group_1"], active='True')
                  set_isis_sid_label(network_group_list=["Network_Group_v6"], ip_type = "ipv6", active='False')
                  set_isis_sid_label(network_group_list=["Network Group 1"], ip_type = "ipv4", active='True' ,devices=["R1-main"], address_list = ["131.0.1.1"])
        """
        self.log.info('Setting ISIS SID/Index/Label ')
        devices = kwargs.get("devices", None)
        address_list = kwargs.get("address_list", None)

        if devices and address_list:
            for device in devices:
                for ngroup in network_group_list:
                    for startaddress in address_list:
                        if ip_type.lower() == "ipv4":
                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv4PrefixPools.find()
                            address = networkObj.NetworkAddress.Values

                        if ip_type.lower() == "ipv6":
                            networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv6PrefixPools.find()
                            address = networkObj.NetworkAddress.Values
                        if startaddress in address:
                            ipIndex = address.index(startaddress)
                            try:
                                valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values
                                valuesList[ipIndex] = active.lower()
                                bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel
                                bgpIpObj.ClearOverlays()
                                bgpIpObj.ValueList(values=valuesList)
                            except:
                                pass

        if devices and address_list == None:
            for device in devices:
                for ngroup in network_group_list:
                    device = device.replace('+', '\+').replace('*', '\*')
                    deviceObj = self.ixNetwork.Topology.find().DeviceGroup.find(Name='^' + device + '$')
                    if ip_type.lower() == "ipv4":
                        try:
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv4PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(
                                active)
                        except:
                            pass
                    if ip_type.lower() == "ipv6":
                        try:
                            deviceObj.NetworkGroup.find(
                                Name='^' + ngroup + '$').Ipv6PrefixPools.find().IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Single(
                                active)
                        except:
                            pass

        if devices == None and address_list:
            for ngroup in network_group_list:
                for startaddress in address_list:
                    if ip_type.lower() == "ipv4":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + ngroup + '$').Ipv4PrefixPools.find()
                        address = networkObj.NetworkAddress.Values

                    if ip_type.lower() == "ipv6":
                        networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                            Name='^' + ngroup + '$').Ipv6PrefixPools.find()
                        address = networkObj.NetworkAddress.Values
                    if startaddress in address:
                        ipIndex = address.index(startaddress)
                        try:
                            valuesList = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel.Values
                            valuesList[ipIndex] = active.lower()
                            bgpIpObj = networkObj.IsisL3RouteProperty.find().IsisL3PrefixesSrSid.find().ConfigureSIDIndexLabel
                            bgpIpObj.ClearOverlays()
                            bgpIpObj.ValueList(values=valuesList)
                        except:
                            pass

        # support for configureSIDIndexLabel not present in ixnetwork_restpy verion 1.0.45 so using REST API
        if self.tgn_server_type == "linux":
            api_key = self.testPlatform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        if devices == None and address_list == None:
            for ngroup in network_group_list:
                networkObj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + ngroup + '$')
                if ip_type.lower() == "ipv4":
                    try:
                        isisL3Obj = networkObj.Ipv4PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'
                    except:
                        pass
                if ip_type.lower() == "ipv6":
                    try:
                        isisL3Obj = networkObj.Ipv6PrefixPools.find().IsisL3RouteProperty.find().href + '/isisL3PrefixesSrSid'
                    except:
                        pass

                if isisL3Obj:
                    body = requests.get(server_url + isisL3Obj, headers=headers, verify=False)
                    isisSid = server_url + body.json()['configureSIDIndexLabel'] + '/singleValue'
                    data = {'value': active}
                    requests.patch(isisSid, json=data, headers=headers, verify=False)

        return True

    def modify_traffic_tx_rx_port(self,trafficList,rxPort=None, txPort=None):
        """
        To modify Tx/Rx ports of traffic items
        :param rxPort:Port Name has to be changed for Traffic Item in receiving side. Default: None.
        :param txPort:Port Name has to be changed for Traffic Item in transmitting side. Default: None.
        :param trafficList: Traffic Item to be changed
        Examples:
            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5'],rxPort=['10.39.70.2/3/7'],trafficList=['Traffic Item 1'])
            modify_traffic_tx_rx_port(txPort=['10.39.70.2/3/5','10.39.70.2/3/6'],rxPort=['10.39.70.2/3/7','10.39.70.2/3/8'],
                                        trafficList=['Traffic Item 1','Traffic Item 2'])
        """
        self.log.info("Modifying Tx and Rx ports of traffic item")
        if rxPort == None and txPort == None:
            self.log.error('rxPort or txPort should be passed')
        rxPortNamesList = []
        txPortNamesList = []
        if rxPort:
            for eachPort in rxPort:
                if (re.search('\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                    portUpdated = eachPort.replace("/", ":")
                    rxPortName = self.ixNetwork.Vport.find(AssignedTo=portUpdated).Name
                    rxPortNamesList.append(rxPortName)
                    rxPort = rxPortNamesList
        if txPort:
            for eachPort in txPort:
                if (re.search('\d+.\d+.\d+.\d+/\d+/\d+', eachPort)):
                    portUpdated = eachPort.replace("/", ":")
                    txPortName = self.ixNetwork.Vport.find(AssignedTo=portUpdated).Name
                    txPortNamesList.append(txPortName)
                    txPort = txPortNamesList
        if trafficList:
            for trafficItem in trafficList:
                trafficObj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + trafficItem + '$')
                if rxPort:
                    try:
                        rxPortDest = []
                        for eachRxPort in rxPort:
                            rxPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href
                            rxPortDestStr = rxPortHref + '/protocols'
                            rxPortDest.append(rxPortDestStr)
                        endPointObj = trafficObj.EndpointSet.find()
                        endPointObj.Destinations = rxPortDest
                    except:
                        self.log.error('RxPort modification failed')
                if txPort:
                    try:
                        txPortDest = []
                        for eachRxPort in txPort:
                            txPortHref = self.ixNetwork.Vport.find(Name=eachRxPort).href
                            txPortDestStr = txPortHref + '/protocols'
                            txPortDest.append(txPortDestStr)
                        endPointObj = trafficObj.EndpointSet.find()
                        endPointObj.Sources = txPortDest
                    except:
                        self.log.error('TxPort modification failed')
        return True

    def duplicate_traffic_item(self, traffic_item=None, count=1):
        """
        API to duplicate traffic items

        :param traffic_item: Name of traffic item which needs to be duplicated
        :param count: Number of duplicates to be created
        :return True: On success
        Examples:
            duplicate_traffic_item(traffic_item=['traffic(1)','traffic[2]','Traffic Item$'],count=1)
-           duplicate_traffic_item(count=2)
            duplicate_traffic_item(traffic_item='traffic(1)')
        """
        if isinstance(traffic_item, str):
            traffic_item = [traffic_item]

        if not traffic_item:
            for trafficObj in self.ixNetwork.Traffic.TrafficItem.find():
                trafficObj.Duplicate(arg2=count)
            self.log.info('Duplicates are created for all traffic items {} times'.format(count))
        else:
            for eachTraffic in traffic_item:
                trafficList = [trafficObj for trafficObj in self.ixNetwork.Traffic.TrafficItem.find() if
                               (trafficObj.Name == eachTraffic)]
                if trafficList:
                    trafficList[0].Duplicate(arg2=count)
                    self.log.info('Duplicate item is created for {} {} times'.format(eachTraffic, count))
                else:
                    self.log.error('{} is not found'.format(eachTraffic))
        self.regenerate_traffic()
        return True

    def set_igmp_mld_rate(self, device_type, rate, **kwargs):
        """
        update join rate for IGMP/MLD device
        :param device_type: igmp, mld
        :param rate: rate to be configured
        :param kwargs :
                    device_name: name of IGMP/MLD device
        :return: True on success else raises exception
        :Example: set_igmp_mld_rate(device_type='igmp', rate=4000)
                  set_igmp_mld_rate(device_type='igmp', rate=3000, device_name='IGMP2')
        """
        if device_type.lower() not in ['igmp', 'mld']:
            raise Exception("Invalid device type", device_type)
        vport_dict = {}
        device_name = kwargs.get('device_name', None)
        if device_name is None:
            # Set IGMP/MLD global values
            rate_count = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Count
            if isinstance(rate, int) or isinstance(rate, float):
                rate = [rate] * rate_count
            elif isinstance(rate, list):
                if len(rate) != rate_count:
                    raise Exception(f"mismatch length between configured {rate_count} and provided {len(rate)}")
            if device_type.lower() == 'igmp':
                self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList(values=rate)
            else:
                self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList(values=rate)
        else:
            if device_type.lower() == 'igmp':
                host = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv4.find().IgmpHost.find(Name=device_name)
                rate_values = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.Values
                row_names = self.ixNetwork.Globals.Topology.IgmpHost.RowNames
                value_list = self.ixNetwork.Globals.Topology.IgmpHost.RatePerInterval.ValueList
            elif device_type.lower() == 'mld':
                host = self.ixNetwork.Topology.find().DeviceGroup.find().Ethernet.find().Ipv6.find().MldHost.find(Name=device_name)
                rate_values = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.Values
                row_names = self.ixNetwork.Globals.Topology.MldHost.RowNames
                value_list = self.ixNetwork.Globals.Topology.MldHost.RatePerInterval.ValueList
            if len(host) == 0:
                raise Exception("Host not found with device name", device_name)
            for row_name in row_names:
                for vport in self.ixNetwork.Vport.find():
                    if row_name == vport.Name:
                        vport_dict[vport.href] = vport.Name
            for topo_entry in self.ixNetwork.Topology.find():
                if topo_entry.href in host.href:
                    for port_name in topo_entry.Ports:
                        port_index = row_names.index(vport_dict[port_name])
                        rate_values[port_index] = rate
                        value_list(values=rate_values)
            return True

    def _get_stream_ipv4_details(self, config_element):
        """
        Gets the value of the IPv4 headers DF,MF,Protocol and IP options field for the specified traffic items
        :param config_element: Config Element of traffic item
        :return: A list of results containing IPv4 field values for the specified streams
        """
        self.log.info("Getting IPv4 Header details of Traffic Item")
        results = {}
        ipv4_stack = config_element.find().Stack.find(StackTypeId='ipv4')
        if ipv4_stack:
            field_value = ipv4_stack.Field.find(Name='^' + 'fragment_flag' + '$')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='last_fragment_flag')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='source_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='dest_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv4_stack.Field.find(Name='protocol')
            results.update({field_value.DisplayName: field_value.FieldValue})
            for ip_option_obj in ipv4_stack.Field.find(FieldTypeId='ipv4.header.options.nextOption.option.'):
                if ip_option_obj and ip_option_obj.ActiveFieldChoice:
                    results.update({ip_option_obj.DisplayName: ip_option_obj.FieldValue})
        else:
            self.log.error('IPv4 Stack is not found in traffic item')
        return results

    def _get_stream_ipv6_details(self, config_element):
        """
        Gets the value of the IPv6 headers Source IP,Destination IP and Next Header
        :param config_element: Config Element of traffic item
        :return: A list of results containing IPv6 field values for the specified streams
        """
        self.log.info("Getting IPv6 Header details of Traffic Item")
        results = {}
        ipv6_stack = config_element.find().Stack.find(StackTypeId='ipv6')
        if ipv6_stack:
            field_value = ipv6_stack.Field.find(Name='source_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv6_stack.Field.find(Name='dest_ip')
            results.update({field_value.DisplayName: field_value.SingleValue})
            field_value = ipv6_stack.Field.find(Name='nextHeader')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.error('IPv6 Stack is not found in traffic item')
        return results

    def _get_stream_icmp_details(self, header_name, config_element):
        """
        Gets the value of the ICMP headers Message Type and Code Options
        :param header_name: header Name for which details to be fetched
        :param config_element: Config Element of traffic item
        :return: A list of results containing ICMP field values for the specified streams
        """
        self.log.info("Getting ICMP Header details of Traffic Item")
        results = {}
        icmp3_code_list = ['Dest. Unreachable code options', 'Src. Quench option', 'Info Request option',
                         'Info Response option', 'Time Exceeded option', 'Redirect Message option']
        if header_name.upper() == 'ICMP3':
            icmp_stack = config_element.find().Stack.find(StackTypeId="^icmpv1$")
            if icmp_stack:
                field_value = icmp_stack.Field.find(Name='msg_type')
                results.update({field_value.DisplayName: field_value.FieldValue})
                for icmp3code in icmp3_code_list:
                    icmp3_code_obj = icmp_stack.Field.find(DisplayName=icmp3code)
                    if icmp3_code_obj and icmp3_code_obj.ActiveFieldChoice:
                        results.update({icmp3_code_obj.DisplayName: icmp3_code_obj.FieldValue})
            else:
                self.log.info('ICMP Msg Type 3,4,5,11,12 Stack is not found in traffic item')
        if header_name.upper() == 'ICMP0':
            icmp_stack = config_element.find().Stack.find(StackTypeId="^icmpv2$")
            if icmp_stack:
                field_value = icmp_stack.Field.find(Name='msg_type')
                results.update({field_value.DisplayName: field_value.FieldValue})
                field_value = icmp_stack.Field.find(Name="Code")
                results.update({field_value.DisplayName: field_value.FieldValue})
                field_value = icmp_stack.Field.find(Name="^id_fier$")
                results.update({field_value.DisplayName: field_value.FieldValue})
            else:
                self.log.error('ICMP Msg Type 0,8,13,14,15,16 Stack is not found in traffic item')
        return results

    def _get_stream_icmpv6_details(self, config_element):
        """
        Gets the value of the ICMPv6 headers Message Type and Code Options
        :param config_element: Config Element of traffic item
        :return: A list of results containing ICMPv6 field value for the specified streams
        """
        self.log.info("Getting ICMPv6 Header details of Traffic Item")
        results = {}
        icmpv6_stack = config_element.find().Stack.find(StackTypeId="^icmpv6$")
        if icmpv6_stack:
            for icmpv6_msg_obj in icmpv6_stack.Field.find(FieldTypeId='icmpv6.icmpv6Message.icmpv6MessegeType.'):
                if icmpv6_msg_obj.ActiveFieldChoice:
                    results.update({icmpv6_msg_obj.DisplayName: icmpv6_msg_obj.FieldValue})
        else:
            self.log.error('ICMPv6 Stack is not found in traffic item')
        return results

    def _get_stream_tcp_details(self, config_element):
        """
        Gets the value of the TCP header values
        :param config_element: Config Element of traffic item
        :return: A list of results containing TCP field value for the specified streams
        """
        self.log.info("Getting TCP Header details of Traffic Item")
        results = {}
        tcp_stack = config_element.find().Stack.find(StackTypeId="^tcp$")
        if tcp_stack:
            field_value = tcp_stack.Field.find(Name='tcp_src_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
            field_value = tcp_stack.Field.find(Name='tcp_dst_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.info('TCP Stack is not found in traffic item')
        return results

    def _get_stream_udp_details(self, config_element):
        """
        Gets the value of the UDP header values
        :param config_element: Config Element of traffic item
        :return: A list of results containing UDP field value for the specified streams
        """
        self.log.info("Getting UDP Header details of Traffic Item")
        results = {}
        udp_stack = config_element.find().Stack.find(StackTypeId="^udp$")
        if udp_stack:
            field_value = udp_stack.Field.find(Name='udp_src_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
            field_value = udp_stack.Field.find(Name='udp_dst_prt')
            results.update({field_value.DisplayName: field_value.FieldValue})
        else:
            self.log.info('UDP Stack is not found in traffic item')
        return results

    def _get_stream_header_list(self, config_element):
        """
        Gets the value of all the traffic item headers configured
        :param config_element: Config Element of traffic item
        :return: A list of Traffic stream headers configured on the specified stream
        """
        self.log.info("Getting Header details of Traffic Item")
        results = [header.DisplayName for header in config_element.Stack.find() if header]
        return results

    def get_traffic_stream_header(self, traffic_item, header_type_list, header_name_list):
        """
        API to get Traffic item header contents like IPv4,IPv6,ICMPv4,ICMPv6
        :param traffic_item: Traffic Item where header is present
        :param header_name_list: header Name for which details to be fetched
        :param header_type_list: header Type for which details to be fetched
        :return True on success otherwise return False
        Ex : get_traffic_stream_header(traffic_item='Traffic Item 1',header_name='ipv4','headerType'='ipv4'))
        """
        self.log.info('Getting traffic item header details')
        header_contents = {}
        traffic_item_name = traffic_item.replace('+', '\+').replace('*', '\*')
        traffic_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_item_name + '$')
        if not traffic_item_obj:
            raise IxiaConfigException("Traffic item not found")
        for config_element in traffic_item_obj.ConfigElement.find():
            for header_name in header_name_list:
                header_type = header_type_list[header_name_list.index(header_name)]
                if header_type == 'all':
                    result = self._get_stream_header_list(config_element)
                elif header_type == 'ipv4':
                    result = self._get_stream_ipv4_details(config_element)
                elif header_type == 'ipv6':
                    result = self._get_stream_ipv6_details(config_element)
                elif header_type == 'icmp':
                    result = self._get_stream_icmp_details(header_name, config_element)
                elif header_type == 'icmpv6':
                    result = self._get_stream_icmpv6_details(config_element)
                elif header_type == 'tcp':
                    result = self._get_stream_tcp_details(config_element)
                elif header_type == 'udp':
                    result = self._get_stream_udp_details(config_element)
                header_contents.update({header_name: result})
        return header_contents

    def add_rocev2_header(self, traffic_item, destination_qp=None):
        """
        API to add Rocev2 traffic header
        :param traffic_item: List of Traffic Items to add Rocev2 header
        :param destination_qp: Type of data to be passed in custom header like fixed,list,increment,random
        :return True on success otherwise return False
        Example:
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],
                                  destination_qp={'random':{'min':'0x32','max':'ffffff','seed':'111','step':1,'count':100}})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'increment':{'start':'0x16','step':2,'count':100}})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'list':['0x32','0x16']})
                add_rocev2_header(traffic_item=['Traffic Item 1'],destination_qp={'fixed':'0x64'})
                add_rocev2_header(traffic_item=['Traffic Item 1','Traffic Item 2'],destination_qp={'fixed':'0x64'})
        """
        if destination_qp is None:
            destination_qp = {'fixed': 1}
        self.log.info('Adding Rocev2 header')
        for traffic in traffic_item:
            self.add_stream_header(traffic, 'custom', 'custom')
            self.add_stream_header(traffic, 'custom', 'custom')
        self.modify_packet_stream_header(traffic_item_list=traffic_item,cfg_dict={'protocol_name': 'custom', 'custom_length': '40','custom_data': '0x640f28403', 'header_index': 1})
        if 'fixed' in destination_qp.keys():
            custom_data = destination_qp['fixed']
        elif 'increment' in destination_qp.keys():
            custom_data = destination_qp['increment']
        elif 'list' in destination_qp.keys():
            custom_data = destination_qp['list']
        elif 'random' in destination_qp.keys():
            custom_data = destination_qp['random']
        else:
            raise IxiaConfigException('Invalid Destination QP value')
        self.modify_packet_stream_header(traffic_item_list=traffic_item,cfg_dict={'protocol_name': 'custom', 'custom_length': '24','custom_data': custom_data, 'header_index': 2})
        self.log.info('Traffic Header Rocev2 added successfully with destination QP value')
        return True

    def set_bgp_high_scale_mode(self, bgp="v4", active=True):
        """
        Setting BGP High scale mode in Globals

        :param bgp: BGP v4 or v6 Ex : 'v4'/'v6'
        :param active: operation to be set for High Scale mode Ex : True/False
        :return: True on success else raises exception

        :Example: set_bgp_high_scale_mode(active=False)
                  set_bgp_high_scale_mode(bgp="v6", active=True)
        """
        self.log.info('Setting BGP High Scale Mode')
        if self.tgn_server_type == "linux":
            api_key = self.testPlatform.ApiKey
            headers = {'content_type': 'application/json', 'x-api-key': api_key}
            server_url = 'https://' + self.server_ip + ':' + str(self.port)
            requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)
        else:
            headers = {"content_type": "application/json"}
            try:
                server_url = 'http://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False, timeout=5)
            except:
                server_url = 'https://' + self.server_ip + ':' + str(self.port)
                requests.get(server_url + self.ixNetwork.href, headers=headers, verify=False)

        if bgp.lower() == "v4":
            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv4Peer.href
        if bgp.lower() == "v6":
            bgp_obj = self.ixNetwork.Globals.Topology.BgpIpv6Peer.href

        body = requests.get(server_url + bgp_obj, headers=headers, verify=False)
        bgp_scale = server_url + body.json()['highScaleRouteMode'] + '/singleValue'
        data = {'value': active}
        requests.patch(bgp_scale, json=data, headers=headers, verify=False)

    def change_ipv4_diff_serv(self, cfg_dict, traffic_item_list):
        """
        Changes the Diff serv values in ipv4 stacks for a given set of traffic streams

        :param cfg_dict: Dict including the data need to be modified\n
                cfg_dict accepted keys (case-sensitive): 'displayName', 'valueType','singleValue', 'valueList',header_index \n
                'displayName' : 'default','classSelector','assuredForwarding','expeditedForwarding'
                'valueType'   : 'singleValue','valueList'
                Example: cfg_dict={'displayName':'classSelector','valueType':'singleValue','singleValue':'10'}
        :param traffic_item_list: List of traffic Items name. \n
                Example: traffic_item_list=["Traffic Item 1", "Traffic Item 2"]
        :return: Returns True in case no exceptions
        :Example: change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],
                        cfg_dict={'displayName':'default','valueType':'singleValue','singleValue':'0'})
                  change_ipv4_diff_serv(traffic_item_list=['Traffic1','Traffic2'],
                  cfg_dict={'displayName':'classSelector','valueType':'valueList','valueList':[16,24],'header_index':2})
        """
        self.log.info("Changing Diff Serv values in IPv4")
        if 'header_index' not in cfg_dict:
            cfg_dict['header_index'] = 1
        header_index = cfg_dict['header_index'] - 1
        diff_serve_hop_dict = {'default': 'Default PHB', 'classSelector': 'Class selector PHB',
                            'assuredForwarding': 'Assured forwarding PHB',
                            'expeditedForwarding': 'Expedited forwarding PHB'}

        for traffic_item_name in traffic_item_list:
            traffic_item_name = traffic_item_name.replace('+', '\+').replace('*', '\*')
            for config_element in self.ixNetwork.Traffic.TrafficItem.find(
                    Name='^' + traffic_item_name + '$').ConfigElement.find():
                if config_element.Stack.find(DisplayName="IPv4"):
                    if cfg_dict['displayName'] in diff_serve_hop_dict.keys():
                        try:
                            stack_obj = config_element.Stack.find(DisplayName="IPv4")[header_index]
                            field_value = stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']])
                            field_value.ActiveFieldChoice = True
                            field_value.ValueType = cfg_dict['valueType']
                            if 'valueList' in cfg_dict['valueType']:
                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),
                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                        cfg_dict['valueList'])
                            elif 'singleValue' in cfg_dict['valueType']:
                                setattr(stack_obj.Field.find(DisplayName=diff_serve_hop_dict[cfg_dict['displayName']]),
                                        cfg_dict['valueType'][0].upper() + cfg_dict['valueType'][1:],
                                        cfg_dict['singleValue'])
                        except Exception as err:
                            raise IxiaConfigException(f"Diff serv value update failed {err}")
                    else:
                        self.log.error('Invalid Diff-Serv hop value')
                else:
                    raise IxiaConfigException(f"IPv4 stack is not configured in {traffic_item_name}")
        self.log.info('IPv4 Diff-Serv Values updated in Traffic Items')
        return True

    def get_traffic_frame_size(self, traffic_item_list=None):
        """
        get the frame size of traffic.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :return: True on success else raises exception.

        :Example:
            get_traffic_frame_size(traffic_item_list=['Traffic Item 1'])
        """
        self.log.info("Getting Traffic Frame Size")
        cfg_dict=dict()
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()

        for traffic_name in traffic_item_list:
            traffic_name =  traffic_name.replace('+', '\+').replace('*', '\*')
            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' +traffic_name+ '$'):
                streams = traffic.ConfigElement.find()
                for stream in streams:
                    if stream.FrameSize.Type == "fixed":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Frame Size":stream.FrameSize.FixedSize})
                    elif stream.FrameSize.Type == "increment":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Start":stream.FrameSize.IncrementFrom,
                                                                      "End":stream.FrameSize.IncrementTo,"Step":stream.FrameSize.IncrementStep})
                    elif stream.FrameSize.Type == "random":
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,"Random Max":stream.FrameSize.RandomMax,
                                                                      "Random Min":stream.FrameSize.RandomMin})
                    elif stream.FrameSize.Type in ["presetDistribution", "weightedPairs"]:
                        cfg_dict.setdefault(traffic_name, []).append({"Frame Type": stream.FrameSize.Type,
                                                                      "weighted Range Pairs":stream.FrameSize.WeightedRangePairs})
        return cfg_dict

    def get_traffic_rate(self, traffic_item_list='Traffic Item 1'):
        """
        get the rate of traffic.

        :param traffic_item_list: List of traffic Items name. All Items if it is None.
        :return: True on success else raises exception.

        :Example:
            get_traffic_rate(traffic_item_list=['Traffic Item 1'])
        """
        self.log.info("Getting Traffic Rate")
        rate_type_dict = {'bitsPerSecond': 'bitsPerSec', 'kilobitsPerSecond': 'kbitsPerSec',
                        'megabitsPerSecond': 'mbitsPerSec', 'framesPerSecond': 'framesPerSec',
                        'percentLineRate': 'lineRate'}
        if traffic_item_list is None:
            traffic_item_list = self.get_traffic_items()
        cfg_dict = dict()
        for traffic_name in traffic_item_list:
            traffic_name = traffic_name.replace('+', '\+').replace('*', '\*')
            #print(traffic_name)
            print("***************")
            print(self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_name + '$'))
            for traffic in self.ixNetwork.Traffic.TrafficItem.find(Name='^' + traffic_name + '$'):
                streams = traffic.ConfigElement.find()
                
                for stream in streams:
                    print(stream)
                    print("444444444444444444444")
                    print("stream.FrameRate")
                    print(stream.FrameRate)
                    print(self.ixNetwork.Traffic.DynamicRate.find(TrafficItemName=traffic_name))
                    for frame_rate in stream.FrameRate:
                        if frame_rate.Type == "percentLineRate":
                            cfg_dict.setdefault(traffic_name, []).append({"Rate Type": rate_type_dict[frame_rate.Type],
                                                                          "Rate": str(int(frame_rate.Rate))+"%"})
                        else:
                            cfg_dict.setdefault(traffic_name, []).append({"Rate Type":rate_type_dict[frame_rate.Type],"Rate":frame_rate.Rate})
        return cfg_dict

    def port_ownership(self):
        """
        Function used to clear port ownership and take port ownership
        Forcefully take port ownership of ports owned by other users and connect ports

        :Example:
            port_ownership()
        """
        ports = self.ixNetwork.Vport.find()
        if ports:
            ports.ConnectPorts(arg2=True)
        else:
            self.log.error('No Ports Found or invalid configuration')

    def set_bgp_next_hop(self, network_group, next_hop_type, **kwargs):
        """
        Modifying Next Hop options for BGP protocol.
        :param network_group: represents the network group
        :param next_hop_type: String representing the next hop type(manaul,local_ip)
        :param kwargs: Vendor (IXIA/Spirent) specific parameters need to be passed in kwargs.
                nested_network_group : if nested network group, Need to pass nested_network_group = True
                                if nested_network_group is True 'route_block_name' is mandatory
                ip_type:String representing ip type (ipv4 or ipv6)
                next_hop_ip_type: String representing the next hop ip type(ipv4 or ipv6)
                next_hop_ipv4_adr,String representing next hop ipv4 address
                next_hop_ipv6_adr,String representing next hop ipv6 address
        :return: True if the operation is successful, False otherwise
        :Example:
            set_bgp_next_hop(network_group='Network Group 1',ip_type='ipv6',next_hop_type='manually',
                            next_hop_ipv4_adr='12.24.56.79',next_hop_ipv6_adr='ef12::f23:3')
        """
        ip_type = kwargs.get('ip_type', 'ipv4')
        next_hop_ip_type = kwargs.get('next_hop_ip_type', 'ipv4')
        next_hop_ipv4_adr = kwargs.get('next_hop_ipv4_adr', '0.0.0.0')
        next_hop_ipv6_adr = kwargs.get('next_hop_ipv6_adr', '::')

        self.log.info(f"Setting Bgp Next hop  options for Network Group {network_group}")

        network_group_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
            Name='^' + network_group + '$')

        if network_group_obj:
            return self._modify_bgp_next_hop_options(network_obj=network_group_obj, ip_option=ip_type,
                                                     next_hop_option=next_hop_type,
                                                     next_hop_ip_option=next_hop_ip_type,
                                                     next_hop_ipv4_address=next_hop_ipv4_adr,
                                                     next_hop_ipv6_address=next_hop_ipv6_adr)
        else:
            self.log.error(f"BGP Network Group {network_group} Not Found")

    def _modify_bgp_next_hop_options(self, network_obj, ip_option, next_hop_option, next_hop_ip_option,
                                     next_hop_ipv4_address,
                                     next_hop_ipv6_address):
        """
        This function is used internally
        :param network_obj: Network Group Object
        :param ip_option: IP type of Network group
        :param next_hop_option: String representing the next hop type(manual,local_ip)
        :param next_hop_ip_option: String representing the next hop ip type(ipv4 or ipv6)
        :param next_hop_ipv4_address:next_hop_ipv4_adr,String representing next hop ipv4 address
        :param next_hop_ipv6_address:next_hop_ipv6_adr,String representing next hop ipv6 address
        """
        self.log.info(f"Modifying Bgp Next hop options for Network Group {network_obj.Name}")
        next_hop_type_dict = {'manually': 'manual', 'local_ip': 'sameaslocalip'}
        if ip_option.lower() == 'ipv4':
            if network_obj.Ipv6PrefixPools.find():
                bgp_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpIPRouteProperty.find()
            elif network_obj.Ipv4PrefixPools.find():
                bgp_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpIPRouteProperty.find()
            else:
                bgp_route_property_obj = None
            if bgp_route_property_obj:
                try:
                    bgp_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])
                    bgp_route_property_obj.NextHopIPType.Single(next_hop_ip_option)
                    bgp_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)
                    bgp_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)
                except:
                    self.log.error('Modification of BGP Next Hop options failed')
            else:
                self.log.error('BGP Network Route is not found in Topology')
        else:
            if network_obj.Ipv6PrefixPools.find():
                bgp_v6_route_property_obj = network_obj.Ipv6PrefixPools.find().BgpV6IPRouteProperty.find()
            elif network_obj.Ipv4PrefixPools.find():
                bgp_v6_route_property_obj = network_obj.Ipv4PrefixPools.find().BgpV6IPRouteProperty.find()
            else:
                bgp_v6_route_property_obj = None
            if bgp_v6_route_property_obj:
                try:
                    bgp_v6_route_property_obj.NextHopType.Single(next_hop_type_dict[next_hop_option])
                    bgp_v6_route_property_obj.NextHopIPType.Single(next_hop_ip_option)
                    bgp_v6_route_property_obj.Ipv4NextHop.Single(next_hop_ipv4_address)
                    bgp_v6_route_property_obj.Ipv6NextHop.Single(next_hop_ipv6_address)
                except:
                    self.log.error('Modification of BGP Next Hop options failed')
            else:
                self.log.error('BGP Network Route is not found in Topology')
        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        return True

    def modify_route_start_address(self, start_address, network_group=None, ip_type='ipv4', **kwargs):
        """
        This API is used for modifying the Network group address count
        :param start_address:Start address of the route to be set
        :param network_group:Network Group name to modify group address Count
        :param ip_type: Type of Network group address pool. Supported values - 'ipv4', 'ipv6'
        :param kwargs: Optional arguments
                        nested_network_group: nested network group name If nested network group to be modified
                                              Ex : 'Network Group 1'
        :return: True on success otherwise raise exception

        :Example: modify_route_start_address(start_address = "100.1.1.1", nested_network_group = "Network Group 1")
                  modify_route_start_address(start_address ={'start':"100.1.1.1",'step':'0.0.0.2'}, nested_network_group = "Network Group 1")
                  modify_route_start_address(start_address =["10.1.1.1","20.1.1.1","30.1.1.1"], nested_network_group = "Network Group 1")
        """
        nested_network_group = kwargs.get('nested_network_group', None)
        self.log.info("setting start address for Network Group ")
        # Modify Group start address for Network Group
        if network_group and nested_network_group:
            if ip_type.lower() == 'ipv4':
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$'). \
                        DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
                except:
                    pass

            else:
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + network_group + '$'). \
                        DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
                except:
                    pass

            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start'),
                                                     step_value=cfg_dict.get('step', "0.0.0.1"))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)
        elif network_group is None and nested_network_group:
            if ip_type.lower() == 'ipv4':
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv4PrefixPools.find()
                except:
                    pass
            else:
                try:
                    network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().DeviceGroup.find().DeviceGroup.find().NetworkGroup.find(
                        Name='^' + nested_network_group + '$').Ipv6PrefixPools.find()
                except:
                    pass

            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),
                                                     step_value=cfg_dict.get('step', 1))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)
        elif network_group and nested_network_group is None:
            if ip_type.lower() == 'ipv4':
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$').Ipv4PrefixPools.find()
            else:
                network_obj = self.ixNetwork.Topology.find().DeviceGroup.find().NetworkGroup.find(
                    Name='^' + network_group + '$').Ipv6PrefixPools.find()
            if isinstance(start_address, dict):
                cfg_dict = start_address
                network_obj.NetworkAddress.Increment(start_value=cfg_dict.get('start', 1000),
                                                     step_value=cfg_dict.get('step', 1))
            elif isinstance(start_address, str):
                network_obj.NetworkAddress.Single(start_address)
            elif isinstance(start_address, list):
                network_obj.NetworkAddress.ValueList(start_address)

        self.ixNetwork.Globals.Topology.ApplyOnTheFly()
        self.log.info("Network Group start address added Successfully")
        return True

    def get_all_frame_headers(self, stream_name:str):
        """
        This API returns Mac and Ethernet type of given traffic item
        :param stream_name: Stream name where stream header details to be fetched
        :return: Dict of headers frames with field values
        :Example: get_all_frame_headers(stream_name='Traffic_1')
        output: {'header_1_ethernetii': {'dstMac': '01:01:10:00:03:00', 'srcMac': '01:01:20:aa:00:cd', 'etherType': '800'},
        'header_2_ipv4': {'version': '4', 'totalLength': '1500', 'identification': '0', 'fragOffset': '0', 'ttl': '64',
        'protocol': 'IPv6', 'checksum': '0', 'sourceAddr': '10.10.33.60', 'destAddr': '25.66.82.31'},
        'header_3_ipv6': {'version': '6', 'trafficClass': '0', 'flowLabel': '0', 'payloadLength': '1440',
        'nextHeader': 'TCP', 'hopLimit': '64', 'sourceAddr': '120::2', 'destAddr': '140::4'},
        'header_4_tcp': {'sourcePort': 'MSDP', 'destPort': 'LDP', 'ackNum': '0', 'offset': '5', 'reserved': '0',
        'cwrBit': '0', 'ecnBit': '0', 'urgBit': '0', 'ackBit': '1', 'pshBit': '0', 'rstBit': '0', 'synBit': '1',
        'finBit': '0', 'window': '0', 'checksum': '0', 'urgentPtr': '0'},
        'header_5_udp': {'sourcePort': 'RIP', 'destPort': 'NTP'},
        'header_6_gre': {'keyPresent': '0:No Key field', 'seqNumPresent': '0:No sequence number field',
        'reserved0': '0', 'version': '0', 'protocolType': '8100'},
        'header_7_vlan': {'vlanPriority': '1', 'vlanCfi': '0', 'vlanId': '6', 'vlanProtocol': '8100'}}
        """
        self.log.info(f'Fetching headers from traffic stream: {stream_name}')

        ethernet_field_dict = {'destinationAddress': 'dstMac', 'ether_type': 'etherType', 'sourceAddress': 'srcMac'}

        ipv4_field_dict = {'checksum': 'checksum', 'dest_ip': 'destAddr', 'fragment_offset': 'fragOffset',
                           'total_len': 'totalLength',
                           'protocol': 'protocol', 'source_ip': 'sourceAddr', 'identification': 'identification',
                           'ttl': 'ttl', 'version': 'version'}

        gre_field_dict = {'sequence_present': 'seqNumPresent', 'key_present': 'keyPresent', 'reserved0': 'reserved0',
                          'protocol': 'protocolType', 'version': 'version'}

        tcp_field_dict = {'u_bit': 'urgBit', 'protocol': 'protocolType', 's_bit': 'synBit', 'r_bit': 'rstBit',
                          'c_bit': 'cwrBit', 'p_bit': 'pshBit', 'a_bit': 'ackBit', 'f_bit': 'finBit', 'e_bit': 'ecnBit',
                          'ack_num': 'ackNum', 'reserved': 'reserved', 'seqNum': 'seq_num', 'data_offset': 'offset',
                          'tcp_src_prt': 'sourcePort', 'tcp_dst_prt': 'destPort',
                          'tcp_window': 'window', 'tcp_checksum': 'checksum', 'urgent_ptr': 'urgentPtr'}

        udp_field_dict = {'udp_src_prt': 'sourcePort', 'udp_dst_prt': 'destPort'}

        ipv6_field_dict = {'payloadLength': 'payloadLength', 'hopLimit': 'hopLimit',
                           'flowLabel': 'flowLabel', 'source_ip': 'sourceAddr', 'trafficClass': 'trafficClass',
                           'version': 'version', 'dest_ip': 'destAddr',
                           'nextHeader': 'nextHeader'}
        vlan_field_dict = {'vlan_user_priority': 'vlanPriority', 'vlan_id': 'vlanId', 'vlan_cfi': 'vlanCfi',
                           'vlan_tag_type': 'vlanProtocol'}

        regex_dict = {'ethernet': ethernet_field_dict, 'ipv4$': ipv4_field_dict, 'ipv6$': ipv6_field_dict,
                      'gre': gre_field_dict,
                      'tcp': tcp_field_dict, 'udp': udp_field_dict, 'vlan$': vlan_field_dict}

        header_contents = {}
        field_dict = {}
        stream_name = stream_name.replace('+', '\+').replace('*', '\*')
        stream_item_obj = self.ixNetwork.Traffic.TrafficItem.find(Name='^' + stream_name + '$')
        if not stream_item_obj:
            raise IxiaConfigException("Traffic item not found")

        for index, stack in enumerate(stream_item_obj.ConfigElement.find().Stack.find(), start=1):
            stack_name = 'header_' + str(index) + '_' + stack.DisplayName.lower().replace(' ', '')
            header_contents.update({stack_name: {}})
            for pattern in regex_dict.keys():
                if re.search(pattern, stack_name):
                    field_dict = regex_dict[pattern]
                    break

            if field_dict:
                for field in stack.Field.find():
                    if field.Name in field_dict.keys():
                        header_contents[stack_name].update({field_dict[field.Name]: field.FieldValue})
        return header_contents

    def get_values_from_captured_packets(self, pcap_filename: AnyStr, header: str = 'ipv4', pkt_mode: str = "random",
                                         pkt_num: int = None, random_check_till_ip: int = 5):
        """
        Used to fetch source and destination IP and TCP MSS value from the captured packet file.
        :param pcap_filename: Packet capture file name with location
        :param header: IP header type Ex : "ipv4" or "ipv6"
        :param pkt_mode: options are "random" and "fixed", default: "random"
        If set "random" - one random packet from the pcap file is picked , checks whether the packet is IP packet or ARP packet,
        If the packet is IP packet, returns source and destination MAC.
        If the packet is ARP packet, another random packet is picked and process repeats for "random_check_till_ip" number of times
        If set "fixed" - packet with packet number="pkt_num" is used to fetch src and dst mac.
        :param pkt_num: packet with packet number="pkt_num" is used to fetch src and dst mac. Only when pkt_mode is "fixed"
        :param random_check_till_ip: Number of tries, random packet turns out to be ARP packet.

        Example: output = get_values_from_captured_packets(pcap_filename='sampledata1.pcap')
                 output : { 'dst_ip': '2303:d01:148::c001:201:48',
                            'dst_mac': '00:12:01:00:00:01',
                            'src_ip': '3303:d01:1122:404:6:200::',
                            'src_mac': 'c4:b2:39:ec:35:34',
                            'tcp_mss': '05a6'}
        """
        ret_header_values = {}
        packets = []
        header = header.lower()
        if pcap_filename:
            with open(pcap_filename, 'rb') as pcap_file:
                for _, pkt in dpkt.pcap.Reader(pcap_file):
                    packets.append(pkt)
            if pkt_mode.lower() == "random":
                for count in range(random_check_till_ip):
                    self.log.info(f'Try: {count}')
                    pkt_num = random.randrange(1, len(packets))
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    ethernet = Ether(packets[int(pkt_num)])
                    if isinstance(eth.data, dpkt.ip.IP) and header == "ipv4" or isinstance(eth.data, dpkt.ip6.IP6) and header == "ipv6":
                        ret_header_values['src_mac'] = ethernet.src
                        ret_header_values['dst_mac'] = ethernet.dst
                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)
                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)

                        try:
                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)
                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)
                        except:
                            pass

                        try:
                            tcp_mss = '.'.join(f'{x: 02x}' for x in eth.data.data.opts).split(".")[-2::]
                            if tcp_mss:
                                ret_header_values['tcp_mss'] = "".join([str(item) for item in tcp_mss])
                        except:
                            pass
                        break
                    else:
                        raise IxiaConfigException(f'No IP packet found after tries: {random_check_till_ip}')
            elif pkt_mode.lower() == "fixed":
                if pkt_num:
                    eth = dpkt.ethernet.Ethernet(packets[int(pkt_num)])
                    ethernet = Ether(packets[int(pkt_num)])
                    if not isinstance(eth.data, dpkt.ip.IP) and header == "ipv4":
                        raise CafyException.TgenInvalidInputError(f'Packet is not an IP packet: {pkt_num}')
                    elif not isinstance(eth.data, dpkt.ip6.IP6) and header == "ipv6":
                        raise CafyException.TgenInvalidInputError(f'Packet is not an IPv6 packet: {pkt_num}')
                    else:
                        ret_header_values['src_mac'] = ethernet.src
                        ret_header_values['dst_mac'] = ethernet.dst
                        ret_header_values['src_ip'] = inet_to_str(eth.data.src)
                        ret_header_values['dst_ip'] = inet_to_str(eth.data.dst)
                        try:
                            ret_header_values['src_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.src)
                            ret_header_values['dst_ip'+'_'+str(pkt_num)] = inet_to_str(eth.data.data.data.data.dst)
                        except:
                            pass
                        try:
                            tcp_mss = '.'.join(f'{x:02x}' for x in eth.data.data.opts).split(".")[-2::]
                            if tcp_mss:
                                ret_header_values['tcp_mss'] = "".join([str(item) for item in tcp_mss])
                        except:
                            pass
                else:
                    raise CafyException.TgenInvalidInputError(f'pkt_mode fixed is must for: {pkt_num}')
        else:
            raise CafyException.TgenInvalidInputError(f'mandatory parameter: {pcap_filename}')
        return ret_header_values

    def get_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None):
        """
        The API returns the SRV6 OAM session status, My discriminator, Peer Discriminator,
        TX Interval, Timeout multiplier, Reply source address and Session ID  for the given router ids

        :param device_name: SRV6OAM device name
        :param router_ids: List of router_ids
        :return: Dictionary of router ids with their corresponding SRV6OAM session status

        :Example: get_srv6_oam_parameters(device_name = "PE1",router_ids=['192.0.0.1','192.0.0.5'])
        """
        router_id_status_mapping = dict()
        self.log.info(f"Getting SRV6OAM session status for device {device_name}")

        try:
            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
        except:
            self.log.error("Device Group Not Found")

        try:
            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId
            session_status_list =  ipv6_obj.Srv6Oam.find().SessionStatus
            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values
            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values
            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values
            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values
            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values

            if router_ids:
                for router_id in router_ids:
                    if router_id in router_id_list:
                        router_id_index = router_id_list.index(router_id)
                        value_dict = dict()
                        value_dict.setdefault('session_status' , session_status_list[router_id_index])
                        value_dict.setdefault('my_discriminator' , my_discriminator_list[router_id_index])
                        value_dict.setdefault('peer_discriminator', peer_discriminator_list[router_id_index])
                        value_dict.setdefault('tx_interval', tx_interval_list[router_id_index])
                        value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[router_id_index])
                        value_dict.setdefault('reply_source_address', reply_source_address_list[router_id_index])
                        value_dict.setdefault('session_id', router_id_index + 1)
                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)
            else:
                for index, router_id in enumerate(router_id_list):
                    value_dict = dict()
                    value_dict.setdefault('session_status', session_status_list[index])
                    value_dict.setdefault('my_discriminator', my_discriminator_list[index])
                    value_dict.setdefault('peer_discriminator', peer_discriminator_list[index])
                    value_dict.setdefault('tx_interval', tx_interval_list[index])
                    value_dict.setdefault('timeout_multiplier', timeout_multiplier_list[index])
                    value_dict.setdefault('reply_source_address', reply_source_address_list[index])
                    value_dict.setdefault('session_id', index + 1)
                    router_id_status_mapping.setdefault(router_id, []).append(value_dict)
        except:
            self.log.error("Device Group or SRV6OAM config Not Found")
        return router_id_status_mapping

    def set_srv6_oam_parameters(self, device_name: str, router_ids: Optional[List[str]] = None,
                                sbfd_initiator : Optional[List[str]] = None, my_discriminator: Optional[List[str]] = None,
                                peer_discriminator: Optional[List[str]] = None, tx_interval: Optional[List[str]] = None,
                                timeout_multiplier: Optional[List[str]] = None, reply_source_address: Optional[List[str]] = None,
                                reply_source_address_mode: Optional[str] = None, reply_source_address_step: Optional[str] = None):
        """
        The API sets the SRV6 OAM parameters like My discriminator, Peer Discriminator,
        TX Interval, Timeout multiplier, Reply source address for the given router ids

        :param device_name: SRV6OAM device name
        :param router_ids: List of router_ids
        :param sbfd_initiator: SRV6 OAM s-bfd_initiator to be enabled or disabled Ex : s-bfd_initiator = "True" or "False"
        :param my_discriminator: SRV6 OAM my discriminator to be set on the device Ex : my_discriminator = ["1000000"]
        :param peer_discriminator: SRV6 OAM peer discriminator to be set on the device Ex : peer_discriminator = ["1999999"]
        :param tx_interval: SRV6 OAM tx interval to be set on the device Ex : tx_interval = ["50"]
        :param timeout_multiplier: SRV6 OAM timeout multiplier to be set on the device Ex : timeout_multiplier = ["3"]
        :param reply_source_address: SRV6 OAM reply source address to be set on the device Ex : reply_source_address = ["5000:0:0:1:0:0:0:0"]
        :param reply_source_address_mode: SRV6 OAM reply source address mode type to be set Ex : reply_source_address = 'increment' or 'decrement'
        :param reply_source_address_step: SRV6 OAM reply source address step to be set on the device Ex : reply_source_address = "::0.0.0.1"
        :return: True on success else raises exception

        :Example: set_srv6_oam_parameters(device_name = "PE1",router_ids = ['192.0.0.1','192.0.0.4','192.0.0.5'],
                                           sbfd_initiator = ['True','False','True'],
                                           my_discriminator = ["100","200","300"], peer_discriminator = ["199","299","399"],
                                           tx_interval = ["10","20","30"], timeout_multiplier = ["3","6","9"],
                                           reply_source_address = ["1000:0:0:1:0:0:0:0","2000:0:0:1:0:0:0:0","3000:0:0:1:0:0:0:0"])
        """
        self.log.info(f"Setting SRV6OAM session status for device {device_name}")

        try:
            ipv6_obj = self.ixNetwork.Topology.find().DeviceGroup.find(
                Name='^' + device_name + '$').Ethernet.find().Ipv6.find()
        except:
            self.log.error("Device Group Not Found")

        if ipv6_obj.Srv6Oam.find():
            router_id_list = ipv6_obj.Srv6Oam.find().LocalRouterId
            sbfd_initiator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Values
            my_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Values
            peer_discriminator_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Values
            tx_interval_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Values
            timeout_multiplier_list = ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Values
            reply_source_address_list = ipv6_obj.Srv6Oam.find().RxSrcAddr.Values
        else:
            self.log.error("SRV6OAM config Not Found")

        if router_ids:
            for index,router_id in enumerate(router_ids):
                if router_id in router_id_list:
                    router_id_index = router_id_list.index(router_id)
                    if sbfd_initiator:
                        sbfd_initiator_list[router_id_index] = sbfd_initiator[index].lower()
                    if my_discriminator:
                        my_discriminator_list[router_id_index] = my_discriminator[index]
                    if peer_discriminator:
                        peer_discriminator_list[router_id_index] = peer_discriminator[index]
                    if tx_interval:
                        tx_interval_list[router_id_index] = tx_interval[index]
                    if timeout_multiplier:
                        timeout_multiplier_list[router_id_index] = timeout_multiplier[index]
                    if reply_source_address:
                        reply_source_address_list[router_id_index] = reply_source_address[index]

            if sbfd_initiator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.ValueList(
                    values=sbfd_initiator_list)
            if my_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.ValueList(
                    values=my_discriminator_list)
            if peer_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.ValueList(
                    values=peer_discriminator_list)
            if tx_interval:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.ValueList(values=tx_interval_list)
            if timeout_multiplier:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.ValueList(
                    values=timeout_multiplier_list)
            if reply_source_address:
                ipv6_obj.Srv6Oam.find().RxSrcAddr.ValueList(values=reply_source_address_list)
        else:
            if sbfd_initiator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().EnableSBfdInitiator.Single(sbfd_initiator[0].lower())
            if my_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().MyDiscriminator.Single(my_discriminator[0])
            if peer_discriminator:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().PeerDiscriminator.Single(peer_discriminator[0])
            if tx_interval:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TxInterval.Single(tx_interval[0])
            if timeout_multiplier:
                ipv6_obj.Srv6Oam.find().Srv6OamDestination.find().TimeoutMultiplier.Single(timeout_multiplier[0])
            if reply_source_address and reply_source_address_mode:
                if reply_source_address_mode.lower() == 'increment':
                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Increment(reply_source_address[0], reply_source_address_step)
                elif reply_source_address_mode.lower() == 'decrement':
                    ipv6_obj.Srv6Oam.find().RxSrcAddr.Decrement(reply_source_address[0], reply_source_address_step)
            if reply_source_address and not reply_source_address_mode:
                ipv6_obj.Srv6Oam.find().RxSrcAddr.Single(reply_source_address[0])

        Helper.sleep(5, msg='Waiting before applying the changes')
        self.ixNetwork.Globals.Topology.ApplyOnTheFly(async_operation=True)
        return True

    def _update_traffic_stream_frame_size(self, traffic_item_info: Dict, traffic_item, rate_type_dict: Dict):
        """
        This is an internal API to update frame size for specific traffic item
        :param traffic_item_info: config sent from user
        :param traffic_item: traffic item restpy object
        :param rate_type_dict: mapping dict to map rate type values
        """
        try:
            if traffic_item_info.get('type', None) in ['BITS_PER_SECOND', 'KILOBITS_PER_SECOND', 'MEGABITS_PER_SECOND',
                                                       'BYTES_PER_SECOND', 'KILOBYTES_PER_SECOND',
                                                       'MEGABYTES_PER_SECOND']:
                traffic_item.ConfigElement.find().FrameRate.find().BitRateUnitsType = rate_type_dict[
                    traffic_item_info['type']]

                if traffic_item_info.get('rate', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')

                if traffic_item_info.get('type', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Type = 'bitsPerSecond'
            else:
                if traffic_item_info.get('rate', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Rate = traffic_item_info.get('rate')
                if traffic_item_info.get('type', None):
                    traffic_item.ConfigElement.find().FrameRate.find().Type = rate_type_dict[
                        traffic_item_info.get('type')]
        except Exception as err_msg:
            raise IxiaConfigException(f"failed to set frame rate param. exited with error message {err_msg}")

    def modify_bulk_streams(self, cfg_dict: Dict):
        """
        The API modifies frame rate (currently supported)
        :param cfg_dict: dictionary of traffic streams along with its attributes and values to be modified

        Examples:
        cfg_dict = {'V4_SM_BSR_RP_R3_Src': {'rate': 100,'type':'FRAMES_PER_SECOND'}}
        tgnObj.modify_bulk_streams(cfg_dict)

        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'PERCENT_LINE_RATE'}}
        tgnObj.modify_bulk_streams(cfg_dict)

        cfg_dict = {'V4_SM_STATIC_RP_R4_Src': {'rate': 50, 'type':'BITS_PER_SECOND'}}
        tgnObj.modify_bulk_streams(cfg_dict)
        """
        rate_type_dict = {'BITS_PER_SECOND': 'bitsPerSec', 'KILOBITS_PER_SECOND': 'kbitsPerSec',
                          'MEGABITS_PER_SECOND': 'mbitsPerSec', 'BYTES_PER_SECOND': 'bytesPerSec',
                          'KILOBYTES_PER_SECOND': 'kbytesPerSec', 'MEGABYTES_PER_SECOND': 'mbytesPerSec',
                          'FRAMES_PER_SECOND': 'framesPerSecond', 'PERCENT_LINE_RATE': 'percentLineRate'}

        cfg_list = [{key: value} for key, value in cfg_dict.items()]
        for _, traffic_item_info in enumerate(cfg_list):
            stream_name = list(traffic_item_info.keys())[0]
            traffic_items = self.ixNetwork.Traffic.TrafficItem.find(Name=stream_name)
            if len(traffic_items) == 0:
                raise IxiaConfigException("invalid traffic stream name specified or traffic stream not found. exiting")

            with BatchUpdate(self.ixNetwork):
                for _, traffic_item in enumerate(traffic_items):
                    if traffic_item.Name == stream_name:
                        config = list(traffic_item_info.values())[0]
                        self._update_traffic_stream_frame_size(config, traffic_item, rate_type_dict)
        return True

    def save_config(self, file:str):
        """
        This API exports the loaded config to specified JSON file
        :param file: path name of the JSON file to be saved locally
        exception if error occurs
        """
        if not file.endswith('.json'):
            raise IxiaConfigException("Need JSON file name as part of user input")

        tgn_file_path = self.ixNetwork.Globals.ConfigFileName
        if self.tgn_server_type == 'windows':
            if '/' in tgn_file_path:
                common_path = "sdmStreamManager\\common\\"
                json_file = os.path.split(file)[1]
                remote_file_path = os.path.split(tgn_file_path)[0].replace('IxNetwork', common_path) + json_file
            elif '\\' in tgn_file_path:
                tgn_file_path = tgn_file_path.replace("\\", "/")
                json_file = os.path.split(file)[1]
                remote_file_path = os.path.split(tgn_file_path)[0] + "/" + json_file
        elif self.tgn_server_type == 'linux':
            common_path = "sdmStreamManager/common/"
            json_file = os.path.split(file)[1]
            remote_file_path = os.path.split(tgn_file_path)[0] + "/" + json_file

        try:
            self.ixNetwork.ResourceManager.ExportConfigFile(["/descendant-or-self::*"], False, "json", Files(json_file))
            self.session.DownloadFile(remote_file_path, file)
        except Exception as err_msg:
            raise IxiaConfigException(f"Failed to export config. exited with error message {err_msg}")
